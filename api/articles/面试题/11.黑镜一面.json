{"title":"11.黑镜一面","uid":"9e13f3b46bb4f0248b7fc78b0ae5b39a","slug":"面试题/11.黑镜一面","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/11.黑镜一面.json","keywords":null,"cover":[],"content":"<ol>\n<li>什么是事件冒泡和事件捕获</li>\n</ol>\n<p><a href=\"https://www.pipipi.net/27549.html\">https://www.pipipi.net/27549.html</a></p>\n<ol start=\"2\">\n<li>vue和react的事件实现原理</li>\n</ol>\n<p><code>React</code>基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等</p>\n<p>在<code>React</code>中这套事件机制被称之为合成事件</p>\n<h4 id=\"合成事件（SyntheticEvent）\"><a href=\"#合成事件（SyntheticEvent）\" class=\"headerlink\" title=\"合成事件（SyntheticEvent）\"></a>合成事件（SyntheticEvent）</h4><p>合成事件是 <code>React</code>模拟原生 <code>DOM</code>事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器</p>\n<p>根据 <code>W3C</code>规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要获得原生<code>DOM</code>事件，可以通过<code>e.nativeEvent</code>属性获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const handleClick = (e) =&gt; console.log(e.nativeEvent);;</span><br><span class=\"line\">const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>从上面可以看到<code>React</code>事件和原生事件也非常的相似，但也有一定的区别：</p>\n<ul>\n<li><p>事件名称命名方式不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 原生事件绑定方式</span><br><span class=\"line\">&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">// React 合成事件绑定方式</span><br><span class=\"line\">const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件处理函数书写不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 原生事件 事件处理函数写法</span><br><span class=\"line\">&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">// React 合成事件 事件处理函数写法</span><br><span class=\"line\">const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>虽然<code>onclick</code>看似绑定到<code>DOM</code>元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听</p>\n<p>这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象</p>\n<p>当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升</p>\n<h2 id=\"二、执行顺序\"><a href=\"#二、执行顺序\" class=\"headerlink\" title=\"二、执行顺序\"></a>二、执行顺序</h2><p>关于<code>React</code>合成事件与原生事件执行顺序，可以看看下面一个例子：</p>\n<p><a href=\"javascript:void(0);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import  React  from &#x27;react&#x27;;</span><br><span class=\"line\">class App extends React.Component&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.parentRef = React.createRef();</span><br><span class=\"line\">    this.childRef = React.createRef();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    console.log(&quot;React componentDidMount！&quot;);</span><br><span class=\"line\">    this.parentRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;原生事件：父元素 DOM 事件监听！&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    this.childRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;原生事件：子元素 DOM 事件监听！&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    document.addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class=\"line\">      console.log(&quot;原生事件：document DOM 事件监听！&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  parentClickFun = () =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;React 事件：父元素事件监听！&quot;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  childClickFun = () =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;React 事件：子元素事件监听！&quot;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div ref=&#123;this.parentRef&#125; onClick=&#123;this.parentClickFun&#125;&gt;</span><br><span class=\"line\">        &lt;div ref=&#123;this.childRef&#125; onClick=&#123;this.childClickFun&#125;&gt;</span><br><span class=\"line\">          分析事件执行顺序</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"javascript:void(0);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></p>\n<p>输出顺序为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原生事件：子元素 DOM 事件监听！ </span><br><span class=\"line\">原生事件：父元素 DOM 事件监听！ </span><br><span class=\"line\">React 事件：子元素事件监听！ </span><br><span class=\"line\">React 事件：父元素事件监听！ </span><br><span class=\"line\">原生事件：document DOM 事件监听！ </span><br></pre></td></tr></table></figure>\n\n<p>可以得出以下结论：</p>\n<ul>\n<li>React 所有事件都挂载在 document 对象上</li>\n<li>当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件</li>\n<li>所以会先执行原生事件，然后处理 React 事件</li>\n<li>最后真正执行 document 上挂载的事件</li>\n</ul>\n<p>对应过程如图所示：</p>\n<p> <img src=\"https://img2020.cnblogs.com/blog/1161361/202107/1161361-20210723102001982-34763226.png\" alt=\"img\"></p>\n<p>所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：</p>\n<ul>\n<li>阻止合成事件间的冒泡，用e.stopPropagation()</li>\n<li>阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()</li>\n<li>阻止合成事件与最外层document上的原生事件上的冒泡，通过判断e.target来避免</li>\n</ul>\n<p><a href=\"javascript:void(0);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.addEventListener(&#x27;click&#x27;, e =&gt; &#123;   </span><br><span class=\"line\">    if (e.target &amp;&amp; e.target.matches(&#x27;div.code&#x27;)) &#123;  </span><br><span class=\"line\">        return;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    this.setState(&#123;   active: false,    &#125;);   &#125;); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"javascript:void(0);\"><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></a></p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p><code>React</code>事件机制总结如下：</p>\n<ul>\n<li>React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)</li>\n<li>React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。</li>\n<li>React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback</li>\n<li>React 有一套自己的合成事件 SyntheticEvent</li>\n</ul>\n<ol start=\"3\">\n<li>判断数组有几种方法</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a instanceof Array;</span><br><span class=\"line\">a.constructor === Array; </span><br><span class=\"line\">Object.prototype.toString.call(a) === &#x27;[Object Array]&#x27;;</span><br><span class=\"line\">Array.isArray(a);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>Web pack loader的执行循序</li>\n<li>箭头函数和普通函数的区别</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this指向不同</span><br><span class=\"line\">箭头函数没有arguments，不能用...</span><br><span class=\"line\">箭头函数不能实例化，不能当构造函数</span><br><span class=\"line\">箭头函数没有原型，箭头函数不具备super</span><br><span class=\"line\">箭头函数没有new.target</span><br><span class=\"line\">箭头函数都是匿名函数，普通函数可以有匿名函数也可以有具名函数</span><br></pre></td></tr></table></figure>\n\n","text":" 什么是事件冒泡和事件捕获 https://www.pipipi.net/27549.html vue和react的事件实现原理 React基于浏览器的事件机制...","permalink":"/post/面试题/11.黑镜一面","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%88SyntheticEvent%EF%BC%89\"><span class=\"toc-text\">合成事件（SyntheticEvent）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">二、执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">三、总结</span></a>","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"1.尚方能源一面","uid":"4ec3ab85b3f89beb24c14eb859217c27","slug":"面试题/1.尚方能源一面","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/1.尚方能源一面.json","keywords":null,"cover":[],"text":" 字符串截取方法有哪些 str.slice(start,end) //从索引start开始到索引end结束不包括end。 start为起始索引，end为结束索引...","permalink":"/post/面试题/1.尚方能源一面","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"2.交易所一面","uid":"a27f8cb4a0e9f55c9e8d2da96f3e5630","slug":"面试题/2.交易所一面","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/2.交易所一面.json","keywords":null,"cover":null,"text":" Vue3和vue2有啥区别 12345678910111213141516171819202122232425262728293031323334353637...","permalink":"/post/面试题/2.交易所一面","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}