{"title":"去哪儿一面","uid":"b511e00209290f3ef9e54ae62e00d2ab","slug":"面试题/去哪儿一面","date":"2024-05-06T03:42:32.000Z","updated":"2024-05-06T12:34:39.705Z","comments":true,"path":"api/articles/面试题/去哪儿一面.json","keywords":null,"cover":[],"content":"<h1 id=\"谈谈你对mvvm的理解\"><a href=\"#谈谈你对mvvm的理解\" class=\"headerlink\" title=\"谈谈你对mvvm的理解\"></a>谈谈你对mvvm的理解</h1><p>MVVM分为三个部分：分别是M（Model，模型层 ），V（View，视图层），VM（ViewModel，V与M连接的桥梁，也可以看作为控制器）</p>\n<p>1、 M：模型层，主要负责业务数据相关；</p>\n<p>2、 V：视图层，顾名思义，负视图相关，细分下来就是html+css层；</p>\n<p>3、 VM：V与M沟通的桥梁，负责监听M或者V的修改，是实现MVVM双向绑定的要点；</p>\n<p>MVVM支持双向绑定，意思就是当M层数据进行修改时，VM层会监测到变化，并且通知V层进行相应的修改，反之修改V层则会通知M层数据进行修改，以此也实现了视图与模型层的相互解耦；</p>\n<p><img src=\"https://img.php.cn/upload/image/754/331/990/1647590664307648.png\" alt=\"13.png\"></p>\n<p>要实现一个mvvm的库，我们首先要理解清楚其实现的整体思路。先看看下图的流程：</p>\n<p><img src=\"https://img.php.cn/upload/image/248/589/234/1647590672625585.png\" alt=\"14.png\"></p>\n<p>1.实现compile,进行模板的编译，包括编译元素（指令）、编译文本等，达到初始化视图的目的，并且还需要绑定好更新函数；</p>\n<p>2.实现Observe,监听所有的数据，并对变化数据发布通知；</p>\n<p>3.实现watcher,作为一个中枢，接收到observe发来的通知，并执行compile中相应的更新方法。</p>\n<p>4.结合上述方法，向外暴露mvvm方法 </p>\n<h1 id=\"谈一谈对单页面应用的理解\"><a href=\"#谈一谈对单页面应用的理解\" class=\"headerlink\" title=\"谈一谈对单页面应用的理解\"></a>谈一谈对单页面应用的理解</h1><p><strong>一、定义</strong><br>单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。</p>\n<p><strong>二、优缺点</strong></p>\n<p>单页Web程序的出现是富客户端发展的必然结果，但是该技术也是有些局限性，所以采用之前需要了解清楚它的优缺点。</p>\n<p>1、优点：</p>\n<p>1).良好的交互体验</p>\n<p>用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅。</p>\n<p>2).良好的前后端工作分离模式</p>\n<p>单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。</p>\n<p>3).减轻服务器压力</p>\n<p>服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；</p>\n<p>4).共用一套后端程序代码<br>不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端；<br>2、缺点：</p>\n<p>1).SEO难度较高</p>\n<p>由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。</p>\n<p>2).前进、后退管理</p>\n<p>由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现。</p>\n<p>3).初次加载耗时多</p>\n<p>为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的CDN，因此带宽的消耗是必然的</p>\n<p>二、单页面应用实现的原理</p>\n<p>1、基本实现原理：利用ajax请求替代了a标签的默认跳转，然后利用html5中的API修改了url，这项技术并没有特别标准的学名，大家都称呼为Pjax，意为PushState + Ajax。这并不完全准确，因为还有Hash + Ajax等方法</p>\n<p>2、Pjax是一个优秀的解决方案，你有足够多的理由来使用它：</p>\n<ul>\n<li>可以在页面切换间平滑过渡，增加Loading动画。</li>\n<li>可以在各个页面间传递数据，不依赖URL。</li>\n<li>可以选择性的保留状态，如音乐网站，切换页面时不会停止播放歌曲。</li>\n<li>所有的标签都可以用来跳转，不仅仅是a标签。</li>\n<li>避免了公共JS的反复执行，如无需在各个页面打开时都判断是否登录过等等。</li>\n<li>减少了请求体积，节省流量，加快页面响应速度。</li>\n<li>平滑降级到低版本浏览器上，对SEO也不会有影响。</li>\n</ul>\n<p>3、深剖原理</p>\n<ol>\n<li>拦截a标签的默认跳转动作。<ol start=\"2\">\n<li>使用Ajax请求新页面。</li>\n<li>将返回的Html替换到页面中。</li>\n<li>使用HTML5的History API或者Url的Hash修改Url。</li>\n</ol>\n</li>\n</ol>\n<p>4、<strong>HTML5 History API</strong></p>\n<p><strong>history.pushState(state, title, url)</strong></p>\n<p>pushState方法会将当前的url添加到历史记录中，然后修改当前url为新url。请注意，这个方法只会修改地址栏的Url显示，但并不会发出任何请求。我们正是基于此特性来实现Pjax。它有3个参数：</p>\n<ul>\n<li>state: 可以放任意你想放的数据，它将附加到新url上，作为该页面信息的一个补充。</li>\n<li>title: 顾名思义，就是document.title。不过这个参数目前并无作用，浏览器目前会选择忽略它。</li>\n<li>url: 新url，也就是你要显示在地址栏上的url。</li>\n</ul>\n<p><strong>history.replaceState(state, title, url)</strong></p>\n<p>replaceState方法与pushState大同小异，区别只在于pushState会将当前url添加到历史记录，之后再修改url，而replaceState只是修改url，不添加历史记录。</p>\n<p><strong>window.onpopstate 事件</strong><br>一般来说，每当url变动时，popstate事件都会被触发。但若是调用pushState来修改url，该事件则不会触发，因此，我们可以把它用作浏览器的前进后退事件。该事件有一个参数，就是上文pushState方法的第一个参数state。</p>\n<h1 id=\"hash-模式和-history-模式原理\"><a href=\"#hash-模式和-history-模式原理\" class=\"headerlink\" title=\"hash 模式和 history 模式原理\"></a>hash 模式和 history 模式原理</h1><p><a href=\"https://blog.csdn.net/chenyajundd/article/details/136879644\">https://blog.csdn.net/chenyajundd/article/details/136879644</a></p>\n<h1 id=\"hash-模式怎么监测路由变化\"><a href=\"#hash-模式怎么监测路由变化\" class=\"headerlink\" title=\"hash 模式怎么监测路由变化\"></a>hash 模式怎么监测路由变化</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;路由发生变化，当前hash为：&#x27;</span>, <span class=\"variable language_\">window</span>.<span class=\"property\">location</span>.<span class=\"property\">hash</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 在这里可以执行更新页面状态等操作</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"vue2响应式原理\"><a href=\"#vue2响应式原理\" class=\"headerlink\" title=\"vue2响应式原理\"></a>vue2响应式原理</h1><p>Vue 2的响应式原理主要基于其内部实现的观察者（Observer）和依赖收集（Dependency Collection）机制。以下是Vue 2响应式原理的详细解释：</p>\n<ol>\n<li><p>数据劫持</p>\n<p>：</p>\n<ul>\n<li>Vue在初始化时，会遍历data中的所有属性，并使用<code>Object.defineProperty</code>将这些属性转化为getter和setter。这意味着当你访问或修改这些属性时，Vue能够知道并做出反应。</li>\n</ul>\n</li>\n<li><p>Getter</p>\n<p>：</p>\n<ul>\n<li>当某个属性被读取时，会触发getter。在getter中，Vue会收集对数据的依赖。具体来说，Vue会创建一个Watcher对象（也称为“依赖”或“观察者”），并将其与当前正在执行的组件实例关联起来。这个Watcher对象会被添加到该属性的依赖列表中。</li>\n</ul>\n</li>\n<li><p>Setter</p>\n<p>：</p>\n<ul>\n<li>当某个属性被修改时，会触发setter。在setter中，Vue会监听到属性的变化。此时，Vue会遍历该属性的依赖列表，并通知列表中的每个Watcher对象执行更新操作。这些Watcher对象会触发对应的组件实例进行重新渲染，从而更新视图。</li>\n</ul>\n</li>\n<li><p>依赖收集和触发更新</p>\n<p>：</p>\n<ul>\n<li>Watcher是Vue用来收集依赖和触发更新的核心机制。每个组件实例都会对应一个Watcher对象，用来管理该组件所依赖的属性。当组件的某个属性发生变化时，Vue会触发该属性的setter，进而触发依赖列表中所有Watcher对象的更新操作。</li>\n</ul>\n</li>\n<li><p>计算属性和侦听器</p>\n<p>：</p>\n<ul>\n<li>Vue还提供了计算属性（computed properties）和侦听器（watchers）来增强响应式系统的能力。计算属性是基于它们的依赖进行缓存的，只有当相关依赖发生改变时才会重新求值。而侦听器则用于观察和响应Vue实例上数据的变化。</li>\n</ul>\n</li>\n<li><p>深度监听</p>\n<p>：</p>\n<ul>\n<li>对于嵌套的数据结构，Vue需要递归地应用<code>Object.defineProperty</code>来进行深度监听。然而，由于JavaScript的限制，Vue无法检测到对象属性的添加或删除。为了解决这个问题，Vue提供了<code>Vue.set</code>和<code>Vue.delete</code>方法来确保在添加或删除属性时能够触发视图更新。</li>\n</ul>\n</li>\n<li><p>数组变更检测</p>\n<p>：</p>\n<ul>\n<li>由于JavaScript数组的方法（如push、pop、shift、unshift、splice、sort、reverse等）会改变数组本身，而不是返回一个新的数组，Vue对这些方法进行了封装，以便在调用这些方法时能够触发视图更新。同时，Vue还提供了<code>Vue.observable</code>方法来创建可响应的数组或对象。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，Vue 2的响应式原理是通过数据劫持和依赖收集机制来实现的。这种机制使得当数据发生变化时，视图能够自动更新，从而实现了数据驱动的视图更新方式。</p>\n<h1 id=\"Vue-set-原理\"><a href=\"#Vue-set-原理\" class=\"headerlink\" title=\"Vue.set 原理\"></a>Vue.set 原理</h1><p>在初始化阶段，Vue 只会对已经存在的对象属性执行响应式处理。如果直接在已声明为响应式的对象上通过字面量方式添加新的属性（如 this.someObject.newProperty &#x3D; ‘newValue’），新属性不会触发 getter 和 setter，因此不会被添加到响应系统中。</p>\n<p>Vue.set 方法就是用来解决这个问题的。<code>它会在目标对象上创建一个新的属性，并确保这个属性同样经过了响应式处理，</code>即调用了 defineProperty 来设置 getter 和 setter。</p>\n<h6 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h6><p>Vue.set(target, key, value) 的执行流程是这样的：</p>\n<p>首先，检查目标对象是否是 Vue 能够进行响应式处理的对象。<br>然后，在目标对象上定义一个新的属性 key，并使用 defineProperty 技术来确保它是可响应的，包括对它的读取和修改都能触发相关依赖的更新。<br>最后，将给定的 value 赋予新属性，并通知所有依赖于此对象的 Watcher 进行视图更新。</p>\n<p>对于数组，Vue 提供了一系列变异方法（如 push、pop、shift、unshift、splice 等），这些方法可以自动触发视图更新。然而，当你需要直接修改数组的索引时（比如新增一个不存在的索引），也需要使用 Vue.set 或 vm.$set 来确保相应变化能够触发视图刷新。<br>Vue.set 方法的主要作用是向响应式对象中添加一个新属性，并确保新属性同样是响应式的。这个方法的实现原理依赖于 Vue 的数据响应式系统，通过 Object.defineProperty 方法将新属性添加到对象上，并设置 getter 和 setter。在使用 Vue.set 时，需要注意其适用范围和注意事项，以确保正确地使用。</p>\n<h1 id=\"简述vue-diff-算法-流程\"><a href=\"#简述vue-diff-算法-流程\" class=\"headerlink\" title=\"简述vue diff 算法 流程\"></a>简述vue diff 算法 流程</h1><p>Vue.js 的 diff 算法（也称为“虚拟 DOM diffing”）是其性能优化的关键部分。当你更改数据并导致 Vue 组件重新渲染时，Vue 实际上不会直接操作真实的 DOM，而是先更新一个虚拟 DOM（Virtual DOM）的副本，然后比较新旧虚拟 DOM 树，找出需要变更的最小部分，并将这些变更应用到真实的 DOM 上。</p>\n<p>以下是 Vue diff 算法的大致比对过程：</p>\n<ol>\n<li><strong>同级比较</strong>：<br>Vue 只对同级的虚拟节点进行比较。如果旧节点和新节点不在同一层级，Vue 会直接销毁旧节点及其所有子节点，然后创建并插入新节点及其所有子节点。</li>\n<li><strong>节点标识</strong>：<br>每个虚拟节点都有一个唯一的 key 属性作为标识。当新旧节点具有相同的 key 时，Vue 会认为它们是同一个节点，并尝试复用该节点。如果没有提供 key，Vue 会使用一种启发式方法来尝试就地复用节点，但这可能会导致不期望的副作用。</li>\n<li><strong>节点类型</strong>：<br>在比较两个节点时，Vue 首先检查它们的节点类型是否相同（例如，都是元素节点、文本节点或注释节点）。如果节点类型不同，Vue 会认为这两个节点是不同的，并创建新的节点。</li>\n<li><strong>属性更新</strong>：<br>如果两个节点的类型相同，Vue 会比较它们的属性，并更新需要变更的属性。这包括元素的类名、样式、事件监听器等。</li>\n<li><strong>子节点比较</strong>：<br>对于元素节点，Vue 还需要比较其子节点。Vue 提供了两种策略来处理子节点的比较：<ul>\n<li><strong>双端比较</strong>：从新旧节点的两端开始比较，直到找到第一个不匹配的节点。然后，Vue 会将新节点中剩余的部分作为插入操作，将旧节点中剩余的部分作为删除操作。</li>\n<li><strong>最长递增子序列</strong>：这是一种更复杂的策略，用于在子节点发生大量移动或重新排序时减少不必要的操作。Vue 会计算新旧节点列表的最长递增子序列（Longest Increasing Subsequence, LIS），并根据这个序列来移动和复用节点。</li>\n</ul>\n</li>\n<li><strong>更新 DOM</strong>：<br>在确定了需要变更的节点后，Vue 会将这些变更应用到真实的 DOM 上。由于 Vue 只操作了需要变更的节点，因此这个过程通常比直接操作整个 DOM 树要快得多。</li>\n</ol>\n<p>需要注意的是，虽然 Vue 的 diff 算法非常高效，但它仍然是一个相对昂贵的操作。因此，在开发 Vue 应用时，我们应该尽量避免不必要的重新渲染，并尽量使用 v-show 而不是 v-if 来切换元素的显示状态（因为 v-show 只是切换 CSS 的 display 属性，而 v-if 会导致节点被销毁和重新创建）。</p>\n<h1 id=\"vue-data-为什么必须是一个函数\"><a href=\"#vue-data-为什么必须是一个函数\" class=\"headerlink\" title=\"vue data 为什么必须是一个函数\"></a>vue data 为什么必须是一个函数</h1><p>我们知道，Vue组件其实就是一个Vue实例。</p>\n<p>JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。</p>\n<p>Vue的data数据其实是Vue原型上的属性，数据存在于内存当中。Vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。</p>\n<p>因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</p>\n<p>使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。</p>\n<p>而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>\n<h1 id=\"性能方面做过哪些优化\"><a href=\"#性能方面做过哪些优化\" class=\"headerlink\" title=\"性能方面做过哪些优化\"></a>性能方面做过哪些优化</h1><p>编码阶段</p>\n<p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher<br>v-if和v-for不能连用<br>如果需要使用v-for给每项元素绑定事件时使用事件代理<br>SPA 页面采用keep-alive缓存组件<br>在更多的情况下，使用v-if替代v-show<br>key保证唯一<br>使用路由懒加载、异步组件<br>防抖、节流<br>第三方模块按需导入<br>长列表滚动到可视区域动态加载<br>图片懒加载<br>SEO优化</p>\n<p>服务端渲染SSR<br>预渲染<br>打包优化</p>\n<p>压缩代码<br>Tree Shaking&#x2F;Scope Hoisting<br>使用cdn加载第三方模块<br>多线程打包happypack<br>splitChunks抽离公共文件<br>sourceMap优化</p>\n<h1 id=\"前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制\"><a href=\"#前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制\" class=\"headerlink\" title=\"前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制\"></a>前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制</h1><p><a href=\"https://blog.csdn.net/qq_33490514/article/details/115066232\">https://blog.csdn.net/qq_33490514/article/details/115066232</a></p>\n","feature":true,"text":"谈谈你对mvvm的理解MVVM分为三个部分：分别是M（Model，模型层 ），V（View，视图层），VM（ViewModel，V与M连接的桥梁，也可以看作为控...","permalink":"/post/面试题/去哪儿一面","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9mvvm%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">谈谈你对mvvm的理解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">谈一谈对单页面应用的理解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#hash-%E6%A8%A1%E5%BC%8F%E5%92%8C-history-%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">hash 模式和 history 模式原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#hash-%E6%A8%A1%E5%BC%8F%E6%80%8E%E4%B9%88%E7%9B%91%E6%B5%8B%E8%B7%AF%E7%94%B1%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">hash 模式怎么监测路由变化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">vue2响应式原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Vue-set-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Vue.set 原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">执行流程</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%80%E8%BF%B0vue-diff-%E7%AE%97%E6%B3%95-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">简述vue diff 算法 流程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#vue-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">vue data 为什么必须是一个函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%96%B9%E9%9D%A2%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">性能方面做过哪些优化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%97%B6%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%8C%E6%97%B6%E6%9C%80%E5%A4%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%99%90%E5%88%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%BF%99%E7%A7%8D%E9%99%90%E5%88%B6\"><span class=\"toc-text\">前端发送网络请求时是否有同时最多连接数限制，为什么会有这种限制</span></a></li></ol>","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"同程旅讯一面","uid":"81d711ca5238a4221806a62a7e360639","slug":"面试题/同程旅行一面","date":"2024-05-06T11:59:32.000Z","updated":"2024-05-06T12:26:23.684Z","comments":true,"path":"api/articles/面试题/同程旅行一面.json","keywords":null,"cover":null,"text":"前端做过哪些性能优化想要监听所有的图片加载失败方法并且上报怎么做是否做过前端性能监控微信小程序性能优化和web性能优化有什么区别微信小程序的性能优化可以从多个方...","permalink":"/post/面试题/同程旅行一面","photos":[],"count_time":{"symbolsCount":507,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"2. 两数相加","uid":"4ec631ba9c8264548f541e9cb0021e69","slug":"leetcode/2. 两数相加","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/leetcode/2. 两数相加.json","keywords":null,"cover":null,"text":"问题描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两...","permalink":"/post/leetcode/2. 两数相加","photos":[],"count_time":{"symbolsCount":945,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","count":2,"path":"api/tags/leetcode.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}