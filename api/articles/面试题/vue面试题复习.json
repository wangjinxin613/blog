{"title":"vue面试题复习","uid":"c6acbc48be12d4651df481a8d172d54a","slug":"面试题/vue面试题复习","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/vue面试题复习.json","keywords":null,"cover":null,"content":"<ol>\n<li>Vue模版引擎</li>\n</ol>\n<p>Vue会根据其规定的模板语法规则，将其解析成AST语法树（其实就是用一个树状的大对象来描述我们所谓的“HTML”）；然后会对这个大对象进行一些初步处理，比如标记没有动态绑定值的节点；最后，会把这个大对象编译成render函数，并将它绑定在组件的实例上。这样，我们所认为的“HTML”就变成了JavaScript代码，可以基于JavaScript模块规则进行导入导出，在需要渲染组件的地方，就调用render函数，根据组件当前的状态生成虚拟dom，然后就可以根据这个虚拟dom去更新视图了。<br>————————————————<br>版权声明：本文为CSDN博主「Yaalon Cui」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_42482733/article/details/111502669\">https://blog.csdn.net/weixin_42482733/article/details/111502669</a></p>\n<ol start=\"2\">\n<li>Axios如何中断请求</li>\n</ol>\n<p>XMLHttpRequest.abort()   方法用于终止 <code>XMLHttpRequest</code> 对象的请求，该方法没有参数，也没有返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// axios 0.22.0版本之前</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个CancelToken对象： </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = axios.<span class=\"property\">CancelToken</span>.<span class=\"title function_\">source</span>();</span><br><span class=\"line\"><span class=\"comment\">// 将CancelToken对象传递给请求的config中：</span></span><br><span class=\"line\">axios.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">cancelToken</span>: source.<span class=\"property\">token</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (axios.<span class=\"title function_\">isCancel</span>(error)) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;请求已被取消：&#x27;</span>, error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;请求出错：&#x27;</span>, error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 在需要中断请求的地方，调用cancel方法：</span></span><br><span class=\"line\">source.<span class=\"title function_\">cancel</span>(<span class=\"string\">&#x27;请求被用户取消&#x27;</span>);</span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为<span class=\"variable constant_\">CSDN</span>博主「<span class=\"title class_\">ATalk</span>机器人」的原创文章，遵循<span class=\"variable constant_\">CC</span> <span class=\"number\">4.0</span> <span class=\"variable constant_\">BY</span>-<span class=\"variable constant_\">SA</span>版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：<span class=\"attr\">https</span>:<span class=\"comment\">//blog.csdn.net/liyananweb/article/details/130334371</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 0.22之后的版本</span><br><span class=\"line\">// 创建请求控制器 </span><br><span class=\"line\">this.controller = new AbortController();</span><br><span class=\"line\">console.log(&quot;初始声明的请求控制器------&quot;, this.controller);</span><br><span class=\"line\"></span><br><span class=\"line\">// 第一种方法：绑定事件处理程序</span><br><span class=\"line\">this.controller.signal.addEventListener(&quot;abort&quot;, () =&gt; &#123;</span><br><span class=\"line\">   console.log(&quot;请求已终止，触发了onabort事件&quot;);</span><br><span class=\"line\">   // 进行后续处理</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 第二种方法：try...catch</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    // 发送文件上传请求</span><br><span class=\"line\">    const res = await this.$axios.post(api.Upload, uploadData, &#123;</span><br><span class=\"line\">     timeout: 0, // 设置超时时间为 0/null 表示永不超时</span><br><span class=\"line\">     signal: this.controller.signal, // 绑定取消请求的信号量</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125; catch (error) &#123;</span><br><span class=\"line\">    console.log(&quot;终止请求时catch的error---&quot;, error);</span><br><span class=\"line\">    // 判断是否为取消上传</span><br><span class=\"line\">    if (error.message == &quot;canceled&quot;)&#123;</span><br><span class=\"line\">        // 进行后续处理</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 终止请求</span><br><span class=\"line\">this.controller.abort();</span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为CSDN博主「努力的小朱同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：https://blog.csdn.net/weixin_45092437/article/details/131211952</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>vue组件的设计原则</li>\n</ol>\n<p>单一职责原则、扩展性、通用性、可配置性、可测试的单元、幂等性</p>\n<ol start=\"4\">\n<li>Vue中data和methods的方法名可以重复吗？</li>\n</ol>\n<p>可以重复，但是重名的话只会执行data里的，不会执行methods的</p>\n<ol start=\"5\">\n<li>slot是什么，有哪些类型</li>\n</ol>\n<p>插槽、默认插槽、具名插槽、作用域插槽</p>\n<ol start=\"6\">\n<li>vue如何检测路由改变</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 组件内watch监听$router</span><br><span class=\"line\">2. router.beforeEach((to, from, next) =&gt; &#123;&#125;) 全局路由守卫</span><br><span class=\"line\">3. 路由独享的守卫 </span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &#x27;/foo&#x27;,</span><br><span class=\"line\">      component: Foo,</span><br><span class=\"line\">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">4. 组件内的守卫(组件内钩子)</span><br><span class=\"line\"> beforeRouteEnter (to, from, next) &#123;</span><br><span class=\"line\">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class=\"line\">    // 不！能！获取组件实例 `this`</span><br><span class=\"line\">    // 因为当钩子执行前，组件实例还没被创建</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class=\"line\">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class=\"line\">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class=\"line\">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class=\"line\">    // 可以访问组件实例 `this`</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  beforeRouteLeave (to, from, next) &#123;</span><br><span class=\"line\">    // 导航离开该组件的对应路由时调用</span><br><span class=\"line\">    // 可以访问组件实例 `this`</span><br><span class=\"line\"> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为CSDN博主「笑魇轻轻」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：https://blog.csdn.net/weixin_45259626/article/details/106076863</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Vue-loader是什么</li>\n</ol>\n<p>  简单的说，他就是基于webpack的一个的loader，解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理，核心的作用，就是提取，划重点。</p>\n","text":" Vue模版引擎 Vue会根据其规定的模板语法规则，将其解析成AST语法树（其实就是用一个树状的大对象来描述我们所谓的“HTML”）；然后会对这个大对象进行一些...","permalink":"/post/面试题/vue面试题复习","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":14,"path":"api/tags/面试题.json"}],"toc":"","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"7.汉迪移动","uid":"1b126a749ab446fe1b61b88b411b0563","slug":"面试题/7.汉迪移动","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/7.汉迪移动.json","keywords":null,"cover":null,"text":" vue和react有什么区别 ","permalink":"/post/面试题/7.汉迪移动","photos":[],"count_time":{"symbolsCount":19,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":14,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"react面试题","uid":"125d4282561b985e7f89533fd43b5b20","slug":"面试题/react面试题","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/react面试题.json","keywords":null,"cover":[],"text":" Fiber的理解 Fiber 是一种数据结构，支撑 Fiber 构建任务的运转。 当某一个 Fiber 任务执行完成后，怎样去找下一个要执行的 Fiber 任...","permalink":"/post/面试题/react面试题","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":14,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}