{"title":"1.尚方能源一面","uid":"4ec3ab85b3f89beb24c14eb859217c27","slug":"面试题/1.尚方能源一面","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/1.尚方能源一面.json","keywords":null,"cover":[],"content":"<ol>\n<li>字符串截取方法有哪些</li>\n</ol>\n<p>str.slice(start,end) &#x2F;&#x2F;从索引start开始到索引end结束不包括end。</p>\n<p>start为起始索引，end为结束索引。start(end)如果为负，则值为 str.length+start（end）。</p>\n<p>如为负则代表从尾部开始截取</p>\n<p>str.substring(start,end)。 &#x2F;&#x2F;从索引start开始到索引end结束不包括end。</p>\n<p>str.substr(start,sum) &#x2F;&#x2F;从索引start开始到sum个结束包括sum。</p>\n<p>start为起始索引，sum为截取个数。start如果为负值，则为str.length+start,sum为负值默认为0。</p>\n<ol start=\"2\">\n<li>数组追加元素有哪些方法</li>\n</ol>\n<ul>\n<li><a href=\"https://www.cnblogs.com/willingtolove/p/10957669.html#_label0\">1、push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</a></li>\n<li><a href=\"https://www.cnblogs.com/willingtolove/p/10957669.html#_label1\">2、unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</a></li>\n<li><a href=\"https://www.cnblogs.com/willingtolove/p/10957669.html#_label2\">3、splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。</a></li>\n</ul>\n<ol start=\"3\">\n<li>数组push方法返回值是啥</li>\n</ol>\n<p>数组长度</p>\n<ol start=\"4\">\n<li>vue的自定义指令</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自动获取焦点 vue2</span><br><span class=\"line\">Vue.directive(&#x27;focus&#x27;, &#123;</span><br><span class=\"line\">  inserted: function (el) &#123;</span><br><span class=\"line\">    el.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">有以下五个钩子函数：</span><br><span class=\"line\"></span><br><span class=\"line\">bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class=\"line\">inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class=\"line\">update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</span><br><span class=\"line\">componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class=\"line\">unbind：只调用一次，指令与元素解绑时调用。</span><br><span class=\"line\">每个钩子函数有以下参数：</span><br><span class=\"line\"></span><br><span class=\"line\">el：指令所绑定的元素，可以用来直接操作 DOM。</span><br><span class=\"line\">binding：一个对象，包含以下 property：</span><br><span class=\"line\">name：指令名，不包括 v- 前缀。</span><br><span class=\"line\">value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。</span><br><span class=\"line\">oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</span><br><span class=\"line\">expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。</span><br><span class=\"line\">arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。</span><br><span class=\"line\">modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。</span><br><span class=\"line\">vnode：Vue 编译生成的虚拟节点。</span><br><span class=\"line\">oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用</span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为CSDN博主「思考的行者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：https://blog.csdn.net/xiaonankeji/article/details/128223177</span><br><span class=\"line\"></span><br><span class=\"line\">vue3</span><br><span class=\"line\">指令的钩子会传递以下几种参数：</span><br><span class=\"line\"></span><br><span class=\"line\">el：指令绑定到的元素。这可以用于直接操作 DOM。</span><br><span class=\"line\">binding：一个对象，包含以下属性。</span><br><span class=\"line\">value：传递给指令的值。例如在 v-my-directive=“1 + 1” 中，值是 2。</span><br><span class=\"line\">oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</span><br><span class=\"line\">arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 “foo”。</span><br><span class=\"line\">modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 &#123; foo: true, bar: true &#125;。</span><br><span class=\"line\">instance：使用该指令的组件实例。</span><br><span class=\"line\">dir：指令的定义对象。</span><br><span class=\"line\">vnode：代表绑定元素的底层 VNode。</span><br><span class=\"line\">prevNode：之前的渲染中代表指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。</span><br><span class=\"line\">————————————————</span><br><span class=\"line\">版权声明：本文为CSDN博主「北海屿鹿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class=\"line\">原文链接：https://blog.csdn.net/zz130428/article/details/128426017</span><br><span class=\"line\"></span><br><span class=\"line\">vue3的钩子函数</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">// 自定义指令所在组件, 创建后</span><br><span class=\"line\">  created(el, binding, vnode, prevVnode) &#123;</span><br><span class=\"line\">    // 下面会介绍各个参数的细节</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // (相当于vue2的bind)自定义指令绑定到 DOM 后调用. 只调用一次, 注意: 只是加入进了DOM, 但是渲染没有完成，</span><br><span class=\"line\">  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">  //就是Vue2.x中的 inserted, 自定义指令所在DOM, 插入到父 DOM 后调用, 渲染已完成(最最重要)</span><br><span class=\"line\">  mounted(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 自定义指令所在 DOM, 更新之前调用</span><br><span class=\"line\">  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  // 就是Vue2.x中的 componentUpdated</span><br><span class=\"line\">  updated(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  //销毁前</span><br><span class=\"line\">  beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 销毁后</span><br><span class=\"line\">  unmounted(el, binding, vnode, prevVnode) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>浏览器的事件循环机制</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 js 中任务会分为同步任务和异步任务。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果是同步任务，则会在主线程（也就是 js 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（js 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在 js 中，任务队列中的任务又可以被分为 2 种类型：宏任务（macrotask）与微任务（microtask）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">但这两种分类已经无法满足现如今复杂的浏览器环境了，所以后续舍弃了宏任务，用一种更加灵活的方式取代了它。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">根据W3C的官方解释，每个任务都有不同的类型，同类型的任务必须在一个队列，不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列任务的优先级仅次于主线程，必须先调度执行，其次是延时队列（主要用来处理延时器setTimeOut），最后是交互队列（处理与用户的交互，如点击事件等）。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">所以任务的优先级为：微队列 &gt; 延时队列 &gt; 交互队列</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>看代码的执行顺序</li>\n<li>看一下代码的执行结果</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;this&#x27;</span>, <span class=\"variable language_\">this</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\">obj.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>执行结果是：</p>\n<p>4</p>\n<p>this Foo{ a: () {} }</p>\n<p>3</p>\n<p>1</p>\n<ol start=\"8\">\n<li>nextTick原理</li>\n</ol>\n<ul>\n<li><code>nextTick</code> 是 <code>Vue</code> 提供的一个全局的<code>API</code> ，由于<code>Vue</code>的异步更新策略导致我们对数据的修改不会立马体现到变化上，此时如果想要立即获取更新后的<code>dom</code>的状态，就需要使用这个方法。</li>\n<li><code>Vue</code>在更新<code>dom</code>时是异步执行的。只要监听到数据变化，<code>Vue</code>将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中一次。这种在缓存时去重对于避免不必要的计算和dom操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。 用一张图可以很好的描述下这个过程。</li>\n</ul>\n<p><img src=\"https://pic4.zhimg.com/80/v2-a6a8db0d162ee254e05f2f28abce9a7b_1440w.webp\"></p>\n","text":" 字符串截取方法有哪些 str.slice(start,end) //从索引start开始到索引end结束不包括end。 start为起始索引，end为结束索引...","permalink":"/post/面试题/1.尚方能源一面","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"toc":"","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"认识mongodb","uid":"7b1d9f1b53c09e4a6b55593ac7c3e160","slug":"数据库/认识mongodb","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/数据库/认识mongodb.json","keywords":null,"cover":[],"text":"认识mongodbMongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 Mo...","permalink":"/post/数据库/认识mongodb","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"10.鲁大师一面","uid":"9570406cfe6951000c21d8d5155a0b25","slug":"面试题/10.鲁大师一面","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/面试题/10.鲁大师一面.json","keywords":null,"cover":null,"text":" Webpack的构建流程 Type和interface的区别 js垃圾回收机制 说说对范型的理解 Sync的原理 ","permalink":"/post/面试题/10.鲁大师一面","photos":[],"count_time":{"symbolsCount":64,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":16,"path":"api/tags/面试题.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}