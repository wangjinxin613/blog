{"title":"child_process子进程","uid":"c63dc365896e48a2d4572cf568e9ebd6","slug":"nodejs/child_process子进程","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/nodejs/child_process子进程.json","keywords":null,"cover":null,"content":"<h1 id=\"child-process-子进程\"><a href=\"#child-process-子进程\" class=\"headerlink\" title=\"child_process 子进程\"></a>child_process 子进程</h1><p>在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。熟悉shell脚本的同学，可以用它来完成很多有意思的事情，比如文件压缩、增量部署等，nodejs创建子进程有四种方法,分别是spawn、fork、exec、execFile。</p>\n<h3 id=\"区别-：\"><a href=\"#区别-：\" class=\"headerlink\" title=\"区别 ：\"></a>区别 ：</h3><ol>\n<li><strong>格式</strong> : spawn和execFile的格式都是(command,[args])；fork的参数直接(文件名);exec的command相当于spawn的command+args；</li>\n<li><strong>回调</strong> : spawn和fork没有直接的回调。spawn通过事件监听处理; fork相当于直接执行一个node程序;其余两个有回调,回调的参数为error,stdout,stderr;</li>\n<li><strong>作用</strong> : [这里我也不是很明白,引用网上的],fork用于启动一个node进程,可以进程进程之间通信;execFile用于执行一个外部应用;spawn方法会在新的进程执行外部应用;exec这个方法将会生成一个子shell，能够在shell中执行命令。</li>\n</ol>\n<h3 id=\"child-process-exec-command-options-callback\"><a href=\"#child-process-exec-command-options-callback\" class=\"headerlink\" title=\"child_process.exec(command[, options][, callback])\"></a>child_process.exec(command[, options][, callback])</h3><p>创建一个shell，然后在shell里执行命令。执行完成后，将stdout、stderr作为参数传入回调方法。                                     </p>\n<p>例子如下：</p>\n<ol>\n<li>执行成功，<code>error</code>为<code>null</code>；执行失败，<code>error</code>为<code>Error</code>实例。<code>error.code</code>为错误码，</li>\n<li><code>stdout</code>、<code>stderr</code>为标准输出、标准错误。默认是字符串，除非<code>options.encoding</code>为<code>buffer</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>).<span class=\"property\">exec</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功的例子  执行了命令ls -al</span></span><br><span class=\"line\"><span class=\"title function_\">exec</span>(<span class=\"string\">&#x27;ls -al&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">error, stdout, stderr</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;error: &#x27;</span> + error);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;stdout: &#x27;</span> + stdout);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;stderr: &#x27;</span> + <span class=\"keyword\">typeof</span> stderr);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 失败的例子</span></span><br><span class=\"line\"><span class=\"title function_\">exec</span>(<span class=\"string\">&#x27;ls hello.txt&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">error, stdout, stderr</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(error) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;error: &#x27;</span> + error);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;stdout: &#x27;</span> + stdout);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;stderr: &#x27;</span> + stderr);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数说明：\"><a href=\"#参数说明：\" class=\"headerlink\" title=\"参数说明：\"></a>参数说明：</h4><ul>\n<li><code>cwd</code>：当前工作路径。</li>\n<li><code>env</code>：环境变量。</li>\n<li><code>encoding</code>：编码，默认是<code>utf8</code>。</li>\n<li><code>shell</code>：用来执行命令的shell，unix上默认是<code>/bin/sh</code>，windows上默认是<code>cmd.exe</code>。</li>\n<li><code>timeout</code>：默认是0。</li>\n<li><code>killSignal</code>：默认是<code>SIGTERM</code>。</li>\n<li><code>uid</code>：执行进程的uid。</li>\n<li><code>gid</code>：执行进程的gid。</li>\n<li><code>maxBuffer</code>： 标准输出、错误输出最大允许的数据量（单位为字节），如果超出的话，子进程就会被杀死。默认是200*1024（就是200k啦）</li>\n</ul>\n<p>备注：</p>\n<ol>\n<li>如果<code>timeout</code>大于0，那么，当子进程运行超过<code>timeout</code>毫秒，那么，就会给进程发送<code>killSignal</code>指定的信号（比如<code>SIGTERM</code>）。</li>\n<li>如果运行没有出错，那么<code>error</code>为<code>null</code>。如果运行出错，那么，<code>error.code</code>就是退出代码（exist code），<code>error.signal</code>会被设置成终止进程的信号。（比如<code>CTRL+C</code>时发送的<code>SIGINT</code>）</li>\n</ol>\n<h3 id=\"child-process-execFile-file-args-options-callback\"><a href=\"#child-process-execFile-file-args-options-callback\" class=\"headerlink\" title=\"child_process.execFile(file[, args][, options][, callback])\"></a>child_process.execFile(file[, args][, options][, callback])</h3><p>跟<code>.exec()</code>类似，不同点在于，没有创建一个新的shell。至少有两点影响</p>\n<ol>\n<li>比<code>child_process.exec()</code>效率高一些。（实际待测试）</li>\n<li>一些操作，比如I&#x2F;O重定向，文件glob等不支持。</li>\n</ol>\n<h3 id=\"child-process-fork-modulePath-args-options\"><a href=\"#child-process-fork-modulePath-args-options\" class=\"headerlink\" title=\"child_process.fork(modulePath[, args][, options])\"></a>child_process.fork(modulePath[, args][, options])</h3><p><code>modulePath</code>：子进程运行的模块。</p>\n<p>参数说明：（重复的参数说明就不在这里列举）</p>\n<ul>\n<li><code>execPath</code>： 用来创建子进程的可执行文件，默认是<code>/usr/local/bin/node</code>。也就是说，你可通过<code>execPath</code>来指定具体的node可执行文件路径。（比如多个node版本）</li>\n<li><code>execArgv</code>： 传给可执行文件的字符串参数列表。默认是<code>process.execArgv</code>，跟父进程保持一致。</li>\n<li><code>silent</code>： 默认是<code>false</code>，即子进程的<code>stdio</code>从父进程继承。如果是<code>true</code>，则直接<code>pipe</code>向子进程的<code>child.stdin</code>、<code>child.stdout</code>等。</li>\n<li><code>stdio</code>： 如果声明了<code>stdio</code>，则会覆盖<code>silent</code>选项的设置。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> child_process = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;child_process&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> child = child_process.<span class=\"title function_\">fork</span>(<span class=\"string\">&#x27;./child.js&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">silent</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">execArgv</span>: process.<span class=\"property\">execArgv</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">child.<span class=\"property\">stdout</span>.<span class=\"title function_\">setEncoding</span>(<span class=\"string\">&#x27;utf8&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">child.<span class=\"property\">stdout</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">data</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>child.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;output from another silent child&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"exec-与execFile-之间的区别\"><a href=\"#exec-与execFile-之间的区别\" class=\"headerlink\" title=\"exec()与execFile()之间的区别\"></a>exec()与execFile()之间的区别</h2><p>首先，exec() 内部调用 execFile() 来实现，而 execFile() 内部调用 spawn() 来实现。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>exec() -&gt; execFile() -&gt; spawn()</p></blockquote>\n<p>其次，execFile() 内部默认将 options.shell 设置为false，exec() 默认不是false。</p>\n<h3 id=\"各种事件\"><a href=\"#各种事件\" class=\"headerlink\" title=\"各种事件\"></a>各种事件</h3><h3 id=\"close\"><a href=\"#close\" class=\"headerlink\" title=\"close\"></a>close</h3><p>当stdio流关闭时触发。这个事件跟<code>exit</code>不同，因为多个进程可以共享同个stdio流。<br>参数：code（退出码，如果子进程是自己退出的话），signal（结束子进程的信号）<br>问题：code一定是有的吗？（从对code的注解来看好像不是）比如用<code>kill</code>杀死子进程，那么，code是？</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p>参数：code、signal，如果子进程是自己退出的，那么<code>code</code>就是退出码，否则为null；如果子进程是通过信号结束的，那么，<code>signal</code>就是结束进程的信号，否则为null。这两者中，一者肯定不为null。<br>注意事项：<code>exit</code>事件触发时，子进程的stdio stream可能还打开着。（场景？）此外，nodejs监听了SIGINT和SIGTERM信号，也就是说，nodejs收到这两个信号时，不会立刻退出，而是先做一些清理的工作，然后重新抛出这两个信号。（目测此时js可以做清理工作了，比如关闭数据库等。）</p>\n<p>SIGINT：interrupt，程序终止信号，通常在用户按下CTRL+C时发出，用来通知前台进程终止进程。<br>SIGTERM：terminate，程序结束信号，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。shell命令kill缺省产生这个信号。如果信号终止不了，我们才会尝试SIGKILL（强制终止）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Also, note that Node.js establishes signal handlers for SIGINT and SIGTERM and Node.js processes will not terminate immediately due to receipt of those signals. Rather, Node.js will perform a sequence of cleanup actions and then will re-raise the handled signal.</p></blockquote>\n<h3 id=\"error\"><a href=\"#error\" class=\"headerlink\" title=\"error\"></a>error</h3><p>当发生下列事情时，error就会被触发。当error触发时，exit可能触发，也可能不触发。（内心是崩溃的）</p>\n<ul>\n<li>无法创建子进程。</li>\n<li>进程无法kill。（TODO 举例子）</li>\n<li>向子进程发送消息失败。（TODO 举例子）</li>\n</ul>\n<h3 id=\"message\"><a href=\"#message\" class=\"headerlink\" title=\"message\"></a>message</h3><p>当采用<code>process.send()</code>来发送消息时触发。<br>参数：<code>message</code>，为json对象，或者primitive value；<code>sendHandle</code>，net.Socket对象，或者net.Server对象（熟悉cluster的同学应该对这个不陌生）</p>\n<p><strong>.connected</strong>：当调用<code>.disconnected()</code>时，设为false。代表是否能够从子进程接收消息，或者对子进程发送消息。</p>\n<p>**.disconnect()**：关闭父进程、子进程之间的IPC通道。当这个方法被调用时，<code>disconnect</code>事件就会触发。如果子进程是node实例（通过child_process.fork()创建），那么在子进程内部也可以主动调用<code>process.disconnect()</code>来终止IPC通道。参考<a href=\"https://nodejs.org/api/process.html#process_process_disconnect\">process.disconnect</a>。</p>\n<p>请注意，<code>exec</code>方法默认的最大允许输出到stdout和stderr的数据量不超过200K，如果超过了，子进程就会被杀死</p>\n","feature":true,"text":"child_process 子进程在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。熟悉shell脚本...","permalink":"/post/nodejs/child_process子进程","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#child-process-%E5%AD%90%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">child_process 子进程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB-%EF%BC%9A\"><span class=\"toc-text\">区别 ：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#child-process-exec-command-options-callback\"><span class=\"toc-text\">child_process.exec(command[, options][, callback])</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%9A\"><span class=\"toc-text\">参数说明：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#child-process-execFile-file-args-options-callback\"><span class=\"toc-text\">child_process.execFile(file[, args][, options][, callback])</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#child-process-fork-modulePath-args-options\"><span class=\"toc-text\">child_process.fork(modulePath[, args][, options])</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#exec-%E4%B8%8EexecFile-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">exec()与execFile()之间的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">各种事件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#close\"><span class=\"toc-text\">close</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#exit\"><span class=\"toc-text\">exit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#error\"><span class=\"toc-text\">error</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#message\"><span class=\"toc-text\">message</span></a></li></ol></li></ol></li></ol>","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"组件","uid":"c4dc6ced9f0994e1a0ee8eb12763c343","slug":"flutter/组件","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/flutter/组件.json","keywords":null,"cover":null,"text":"TextText用于显示简单的文本 1Text('这是一段文本') 参数 释义 参数类型 备注 textAlign 对齐方式 TextAlign TextAli...","permalink":"/post/flutter/组件","photos":[],"count_time":{"symbolsCount":268,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"flutter","slug":"flutter","count":1,"path":"api/tags/flutter.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}