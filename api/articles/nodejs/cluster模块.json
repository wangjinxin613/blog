{"title":"cluster模块","uid":"82f36b6cdf1b51332fd89a2d40fab706","slug":"nodejs/cluster模块","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/nodejs/cluster模块.json","keywords":null,"cover":null,"content":"<h1 id=\"cluster模块\"><a href=\"#cluster模块\" class=\"headerlink\" title=\"cluster模块\"></a>cluster模块</h1><p><code>Node.js</code>默认单进程运行，对于<code>32</code>位系统最高可以使用512MB内存，对于<code>64</code>位最高可以使用1GB内存。**<code>对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置</code>**。<code>cluster模块</code>就是为了解决这个问题而提出的。</p>\n<ul>\n<li><code>cluster模块</code>允许设立一个主进程和若干个worker进程，由主进程监控和协调<code>worker</code>进程的运行。</li>\n<li><code>worker</code>之间采用进程间通信交换消息，<code>cluster模块</code>内置一个负载均衡器，采用<code>Round-robin</code>算法协调各个worker进程之间的负载。</li>\n<li>运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (cluster.<span class=\"property\">isMaster</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, n = os.<span class=\"title function_\">cpus</span>().<span class=\"property\">length</span>; i &lt; n; i += <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    cluster.<span class=\"title function_\">fork</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  http.<span class=\"title function_\">createServer</span>(<span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\">    res.<span class=\"title function_\">end</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\">  &#125;).<span class=\"title function_\">listen</span>(<span class=\"number\">8000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码先判断当前进程是否为<code>主进程（cluster.isMaster）</code>，如果是的，就按照<code>CPU的核数</code>，新建若干个<code>worker进程</code>；如果不是，说明当前进程是<code>worker进程</code>，则在该进程启动一个服务器程序。<br>上面这段代码有一个缺点，就是一旦work进程挂了，主进程无法知道。<br>为了解决这个问题，可以在主进程部署<code>online事件</code>和<code>exit事件</code>的<code>监听函数</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cluster = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cluster&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(cluster.<span class=\"property\">isMaster</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> numWorkers = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;os&#x27;</span>).<span class=\"title function_\">cpus</span>().<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Master cluster setting up &#x27;</span> + numWorkers + <span class=\"string\">&#x27; workers...&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; numWorkers; i++) &#123;</span><br><span class=\"line\">    cluster.<span class=\"title function_\">fork</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> cluster.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;online&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">worker</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Worker &#x27;</span> + worker.<span class=\"property\">process</span>.<span class=\"property\">pid</span> + <span class=\"string\">&#x27; is online&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">cluster.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">worker, code, signal</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Worker &#x27;</span> + worker.<span class=\"property\">process</span>.<span class=\"property\">pid</span> + <span class=\"string\">&#x27; died with code: &#x27;</span> + code + <span class=\"string\">&#x27;, and signal: &#x27;</span> + signal);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Starting a new worker&#x27;</span>);</span><br><span class=\"line\">    cluster.<span class=\"title function_\">fork</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，主进程一旦监听到<code>worker</code>进程的<code>exit</code>事件，就会重启一个<code>worker</code>进程。worker进程一旦启动成功，可以正常运行了，就会发出<code>online</code>事件。</p>\n<h2 id=\"cluster模块的属性与方法\"><a href=\"#cluster模块的属性与方法\" class=\"headerlink\" title=\"cluster模块的属性与方法\"></a>cluster模块的属性与方法</h2><h4 id=\"isMaster，isWorker\"><a href=\"#isMaster，isWorker\" class=\"headerlink\" title=\"isMaster，isWorker\"></a>isMaster，isWorker</h4><p><code>isMaster</code>属性返回一个<code>布尔值</code>，表示当前进程<code>是否为主进程</code>。这个属性由<code>process.env.NODE_UNIQUE_ID</code>决定，如果process.env.NODE_UNIQUE_ID为未定义，就表示该进程是主进程。<br><code>isWorker</code>属性返回一个<code>布尔值</code>，表示当前进程<code>是否为work进程</code>。它<code>与isMaster属性的值正好相反</code>。</p>\n<h4 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork()\"></a>fork()</h4><p><code>fork方法</code>用于<code>新建</code>一个<code>worker进程</code>，上下文都复制主进程。只有主进程才能调用这个方法。<br>该方法返回一个<code>worker</code>对象。</p>\n<h4 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill()\"></a>kill()</h4><p><code>kill方法</code>用于<code>终止worker进程</code>。它可以接受一个参数，表示系统信号。</p>\n<ul>\n<li>如果当前是主进程，就会终止与<code>worker.process</code>的联络，然后将系统信号法发向worker进程。</li>\n<li>如果当前是<code>worker进程</code>，就会终止与主进程的通信，然后退出，返回0。</li>\n<li>在以前的版本中，该方法也叫做 <code>worker.destroy()</code> 。</li>\n</ul>\n<h3 id=\"listening事件\"><a href=\"#listening事件\" class=\"headerlink\" title=\"listening事件\"></a>listening事件</h3><p><code>worker</code>进程调用<code>listen</code>方法以后，<code>“listening”</code>就传向该进程的服务器，然后传向主进程。<br>该事件的回调函数接受两个参数，一个是当前<code>worker对象</code>，另一个是<code>地址对象</code>，包含网址、端口、地址类型（IPv4、IPv6、Unix socket、UDP）等信息。这对于那些服务多个网址的Node应用程序非常有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;listening&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">worker, address</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;A worker is now connected to &quot;</span> + address.<span class=\"property\">address</span> + <span class=\"string\">&quot;:&quot;</span> + address.<span class=\"property\">port</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"worker对象\"><a href=\"#worker对象\" class=\"headerlink\" title=\"worker对象\"></a>worker对象</h2><p><code>worker对象</code>是<code>cluster.fork()</code>的返回值，代表一个<code>worker进程</code>。<br>它的属性和方法如下</p>\n<h3 id=\"worker-id\"><a href=\"#worker-id\" class=\"headerlink\" title=\"worker.id\"></a>worker.id</h3><p><code>work.id</code>返回当前<code>worker</code>的独一无二的进程编号。这个编号也是<code>cluster.workers</code>中指向当前进程的索引值。</p>\n<h3 id=\"worker-process\"><a href=\"#worker-process\" class=\"headerlink\" title=\"worker.process\"></a>worker.process</h3><p>所有的<code>worker</code>进程都是用<code>child_process.fork()</code>生成的。<code>child_process.fork()</code>返回的对象，就被保存在<code>worker.process</code>之中。<br>通过这个属性，可以获取<code>worker</code>所在的进程对象。</p>\n<h3 id=\"worker-send\"><a href=\"#worker-send\" class=\"headerlink\" title=\"worker.send()\"></a>worker.send()</h3><p>该方法用于在主进程中，向子进程发送信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (cluster.<span class=\"property\">isMaster</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> worker = cluster.<span class=\"title function_\">fork</span>();</span><br><span class=\"line\">  worker.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;hi there&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cluster.<span class=\"property\">isWorker</span>) &#123;</span><br><span class=\"line\">  process.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) &#123;</span><br><span class=\"line\">    process.<span class=\"title function_\">send</span>(msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的作用是，worker进程对主进程发出的每个消息，都做回声。<br>在worker进程中，要向主进程发送消息，使用<code>process.send(message)</code>；要监听主进程发出的消息，使用下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>发出的消息可以字符串，也可以是JSON对象。下面是一个发送JSON对象的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker.<span class=\"title function_\">send</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;task 1&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">from</span>: <span class=\"string\">&#x27;master&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the data that you want to transfer</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"cluster-workers对象\"><a href=\"#cluster-workers对象\" class=\"headerlink\" title=\"cluster.workers对象\"></a>cluster.workers对象</h2><p>该对象<code>只有主进程</code>才有，包含了所有<code>worker进程</code>。每个成员的键值就是一个<code>worker进程对象</code>，键名就是该<code>worker进程的worker.id属性</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">eachWorker</span>(<span class=\"params\">callback</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> cluster.<span class=\"property\">workers</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">callback</span>(cluster.<span class=\"property\">workers</span>[id]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">eachWorker</span>(<span class=\"keyword\">function</span>(<span class=\"params\">worker</span>) &#123;</span><br><span class=\"line\">  worker.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;big announcement to all workers&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码用来遍历所有<code>worker</code>进程。<br>当前<code>socket</code>的<code>data</code>事件，也可以用<code>id</code>属性识别<code>worker</code>进程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socket.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">id</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> worker = cluster.<span class=\"property\">workers</span>[id];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PM2模块\"><a href=\"#PM2模块\" class=\"headerlink\" title=\"PM2模块\"></a>PM2模块</h2><p><code>PM2</code>模块是<code>cluster</code>模块的一个包装层。它的作用是尽量将<code>cluster</code>模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\">http.<span class=\"title function_\">createServer</span>(<span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">end</span>(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">listen</span>(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码是标准的Node架设Web服务器的方式，然后用<code>PM2</code>从命令行启动这段代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 start app.js -i 4</span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>i</code>参数告诉<code>PM2</code>，这段代码应该在<code>cluster_mode</code>启动，且新建<code>worker</code>进程的数量是4个。<br>如果<code>i</code>参数的值是0，那么当前机器有几个CPU内核，PM2就会启动几个worker进程。<br>如果一个<code>worker</code>进程由于某种原因挂掉了，会立刻重启该worker进程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 重启所有worker进程</span><br><span class=\"line\">$ pm2 reload all</span><br></pre></td></tr></table></figure>\n\n<p>每个worker进程都有一个id，可以用下面的命令查看单个worker进程的详情。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 show &lt;worker id&gt;</span><br></pre></td></tr></table></figure>\n\n<p>正确情况下，PM2采用<code>fork模式</code>新建worker进程，即主进程fork自身，产生一个worker进程。<br><code>pm2 reload</code>命令则会用<code>spawn</code>方式启动，即一个接一个启动worker进程，一个新的worker启动成功，再杀死一个旧的<code>worker</code>进程。<br>采用这种方式，重新部署新版本时，服务器就不会中断服务。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pm2 reload &lt;脚本文件名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>关闭worker进程的时候，可以部署下面的代码，让worker进程监听<code>shutdown</code>消息。一旦收到这个消息，进行完毕收尾清理工作再关闭。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (msg === <span class=\"string\">&#x27;shutdown&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">close_all_connections</span>();</span><br><span class=\"line\">    <span class=\"title function_\">delete_logs</span>();</span><br><span class=\"line\">    server.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    process.<span class=\"title function_\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>cluster的内部实现原理是封装了一层child_process–fork，而child_process–fork 则是封装了unix 系统的fork 方法</strong></p>\n<p><a href=\"./child_process%E5%AD%90%E8%BF%9B%E7%A8%8B.md\">child_process</a>  是 nodejs的子进程</p>\n","text":"cluster模块Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。**对于多核CPU的计算机来说，这样...","permalink":"/post/nodejs/cluster模块","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#cluster%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">cluster模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cluster%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">cluster模块的属性与方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#isMaster%EF%BC%8CisWorker\"><span class=\"toc-text\">isMaster，isWorker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#fork\"><span class=\"toc-text\">fork()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#kill\"><span class=\"toc-text\">kill()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#listening%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">listening事件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#worker%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">worker对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#worker-id\"><span class=\"toc-text\">worker.id</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#worker-process\"><span class=\"toc-text\">worker.process</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#worker-send\"><span class=\"toc-text\">worker.send()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cluster-workers%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">cluster.workers对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PM2%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">PM2模块</span></a></li></ol></li></ol>","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"child_process子进程","uid":"c63dc365896e48a2d4572cf568e9ebd6","slug":"nodejs/child_process子进程","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/nodejs/child_process子进程.json","keywords":null,"cover":null,"text":"child_process 子进程在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。熟悉shell脚本...","permalink":"/post/nodejs/child_process子进程","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"es6 扩展运算符 三个点（...）","uid":"de492e5254c0d9727d90a25b8c994938","slug":"javascript/es6 扩展运算符 三个点（...）","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.993Z","comments":true,"path":"api/articles/javascript/es6 扩展运算符 三个点（...）.json","keywords":null,"cover":null,"text":"es6之扩展运算符 三个点（…）对象的扩展运算符理解对象的扩展运算符其实很简单，只要记住一句话就可以： 对象中的扩展运算符(...)用于取出参数对象中的所有可遍...","permalink":"/post/javascript/es6 扩展运算符 三个点（...）","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"javascript","slug":"javascript","count":3,"path":"api/tags/javascript.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}