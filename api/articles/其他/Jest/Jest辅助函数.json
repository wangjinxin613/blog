{"title":"Jest辅助函数","uid":"4dc2cf4ec571e0ddd37f9a1c0c0fec2d","slug":"其他/Jest/Jest辅助函数","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.999Z","comments":true,"path":"api/articles/其他/Jest/Jest辅助函数.json","keywords":null,"cover":null,"content":"<h1 id=\"Setup-and-Teardown\"><a href=\"#Setup-and-Teardown\" class=\"headerlink\" title=\"Setup and Teardown\"></a>Setup and Teardown</h1><p>写测试的时候你经常需要在运行测试前做一些准备工作，和在运行测试后进行一些整理工作。 Jest 提供辅助函数来处理这个问题。</p>\n<h2 id=\"为多次测试重复设置\"><a href=\"#为多次测试重复设置\" class=\"headerlink\" title=\"为多次测试重复设置\"></a>为多次测试重复设置</h2><p>如果你有一些要为多次测试重复设置的工作，你可以使用 <code>beforeEach</code> 和 <code>afterEach</code>。</p>\n<p>例如，我们考虑一些与城市信息数据库进行交互的测试。 你必须在每个测试之前调用方法 <code>initializeCityDatabase()</code> ，同时必须在每个测试后，调用方法 <code>clearCityDatabase()</code>。 你可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">beforeEach</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">initializeCityDatabase</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">afterEach</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clearCityDatabase</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;city database has Vienna&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(<span class=\"title function_\">isCity</span>(<span class=\"string\">&#x27;Vienna&#x27;</span>)).<span class=\"title function_\">toBeTruthy</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;city database has San Juan&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">expect</span>(<span class=\"title function_\">isCity</span>(<span class=\"string\">&#x27;San Juan&#x27;</span>)).<span class=\"title function_\">toBeTruthy</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>beforeEach</code> 和 <code>afterEach</code> 能够通过与<a href=\"https://jestjs.io/docs/zh-Hans/asynchronous\"> 异步代码测试</a> 相同的方式处理异步代码 — — 他们可以采取 <code>done</code> 参数或返回一个 promise。 例如，如果 <code>initializeCityDatabase()</code> 返回解决数据库初始化时的 promise ，我们会想返回这一 promise︰</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">beforeEach</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">initializeCityDatabase</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>beforeEach</code> 会根据test测试用例的数量遍历循环，如果只想执行一次的话，可以用<code>beforeAll</code> 和 <code>afterAll</code> 处理这种情况</p>\n","text":"Setup and Teardown写测试的时候你经常需要在运行测试前做一些准备工作，和在运行测试后进行一些整理工作。 Jest 提供辅助函数来处理这个问题。 ...","permalink":"/post/其他/Jest/Jest辅助函数","photos":[],"count_time":{"symbolsCount":923,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Jest","slug":"Jest","count":3,"path":"api/tags/Jest.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Setup-and-Teardown\"><span class=\"toc-text\">Setup and Teardown</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E5%A4%9A%E6%AC%A1%E6%B5%8B%E8%AF%95%E9%87%8D%E5%A4%8D%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">为多次测试重复设置</span></a></li></ol></li></ol>","author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"部署","uid":"9c08a0d97df6bc70228237d5ac86d1b4","slug":"其他/apollo/部署","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:33.999Z","comments":true,"path":"api/articles/其他/apollo/部署.json","keywords":null,"cover":null,"text":" 数据库 docker部署 Apollo Config Service 获取镜像1docker pull apolloconfig/apollo-configs...","permalink":"/post/其他/apollo/部署","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"apollo","slug":"apollo","count":1,"path":"api/tags/apollo.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"微前端概念","uid":"2e55a78a98794587d49e3a89fa8798ef","slug":"其他/微前端/微前端概念","date":"2024-05-05T06:52:32.000Z","updated":"2024-05-05T06:52:34.000Z","comments":true,"path":"api/articles/其他/微前端/微前端概念.json","keywords":null,"cover":[],"text":"微前端概述 微前端概念是ThoughtWorks在2016年提出来的，它将微服务理念扩展到前端开发，解决中台微服务化后，前端由于仍为单体而存在的逻辑繁杂和臃肿的...","permalink":"/post/其他/微前端/微前端概念","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"微前端","slug":"微前端","count":1,"path":"api/tags/微前端.json"}],"author":{"name":"MessageWall","slug":"blog-author","avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F0bcda423-149d-411d-a505-d29abc1ab6de%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1717404600&t=829a21da2f1f1a8181b572805d48b476","link":"/","description":"欢迎来到小王的博客～ <br/> 博客不定时更新，欢迎收藏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}