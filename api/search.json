[{"id":"3daae7bf1645644d4a8fb78b0a30edb6","title":"7.整数反转","content":"问题描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n输入: 123输出: 321 示例 2:\n输入: -123输出: -321示例 3:\n输入: 120输出: 21注意:\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n我的解答12345678910111213141516171819202122232425262728293031function reverse(x: number): number &#123;  var result = [...x.toString()].reverse();  // 如果开头有零则去掉零  var notZero = false;  var zeroIndex = 0;  for(let i in result) &#123;    if(result[i] !== &#x27;0&#x27;) &#123;      notZero = true;    &#125;    if(result[i] === &#x27;0&#x27; &amp;&amp; !notZero) &#123;      zeroIndex = Number(i);    &#125;  &#125;   result.splice(0, zeroIndex);  // 如果是负数  if(x &lt; 0) &#123;    result.pop();    result.unshift(&#x27;-&#x27;);  &#125;  let num = 0;  num = Number(result.join(&#x27;&#x27;));    // 只能存储三十二位数字  if(num &lt; Math.pow(-2,31) || num &gt; Math.pow(2, 31)) &#123;    num = 0;  &#125;  return num;&#125;;\n\n优秀答案12345678var reverse = function(x) &#123;    let result = 0;    while(x !== 0) &#123;        result = result * 10 + x % 10;        x = (x / 10) | 0;    &#125;    return (result | 0) === result ? result : 0;&#125;;\n\n","slug":"leetcode/7.整数反转","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"leetcode","author_index":"MessageWall"},{"id":"4ec631ba9c8264548f541e9cb0021e69","title":"2. 两数相加","content":"问题描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 &#x3D; 807\n解答123456789101112131415161718/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null &#123;  let s1 = JSON.stringify(l1).match(/\\d/g)!.reverse().join(&#x27;&#x27;),      s2 = JSON.stringify(l2).match(/\\d/g)!.reverse().join(&#x27;&#x27;);  let sum = BigInt(s1) + BigInt(s2);  return [...sum.toString()].reduce((acc:any,v)=&gt;&#123;return &#123;val: v, next: acc&#125;&#125;, null)&#125;;\n\n","slug":"leetcode/2. 两数相加","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"leetcode","author_index":"MessageWall"},{"id":"c4dc6ced9f0994e1a0ee8eb12763c343","title":"组件","content":"TextText用于显示简单的文本\n1Text(&#x27;这是一段文本&#x27;)\n\n\n\n\n参数\n释义\n参数类型\n备注\n\n\n\ntextAlign\n对齐方式\nTextAlign\nTextAlign.left\n\n\nmaxLines\n占用最大行数\nInt\n\n\n\ntextScaleFactor\n字体放大倍数\nDouble\n\n\n\nstyle\n样式\nTextStyle\n\n\n\ntextDirection\n文字方向\nTextDirection\n\n\n\nsoftWrap\n表示文本是否应在软换行符（例如句点或逗号）之间断开\nBoolearn\n\n\n\n","slug":"flutter/组件","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"flutter","author_index":"MessageWall"},{"id":"c63dc365896e48a2d4572cf568e9ebd6","title":"child_process子进程","content":"child_process 子进程在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。熟悉shell脚本的同学，可以用它来完成很多有意思的事情，比如文件压缩、增量部署等，nodejs创建子进程有四种方法,分别是spawn、fork、exec、execFile。\n区别 ：\n格式 : spawn和execFile的格式都是(command,[args])；fork的参数直接(文件名);exec的command相当于spawn的command+args；\n回调 : spawn和fork没有直接的回调。spawn通过事件监听处理; fork相当于直接执行一个node程序;其余两个有回调,回调的参数为error,stdout,stderr;\n作用 : [这里我也不是很明白,引用网上的],fork用于启动一个node进程,可以进程进程之间通信;execFile用于执行一个外部应用;spawn方法会在新的进程执行外部应用;exec这个方法将会生成一个子shell，能够在shell中执行命令。\n\nchild_process.exec(command[, options][, callback])创建一个shell，然后在shell里执行命令。执行完成后，将stdout、stderr作为参数传入回调方法。                                     \n例子如下：\n\n执行成功，error为null；执行失败，error为Error实例。error.code为错误码，\nstdout、stderr为标准输出、标准错误。默认是字符串，除非options.encoding为buffer\n\n123456789101112131415161718192021var exec = require(&#x27;child_process&#x27;).exec;// 成功的例子  执行了命令ls -alexec(&#x27;ls -al&#x27;, function(error, stdout, stderr)&#123;    if(error) &#123;        console.error(&#x27;error: &#x27; + error);        return;    &#125;    console.log(&#x27;stdout: &#x27; + stdout);    console.log(&#x27;stderr: &#x27; + typeof stderr);&#125;);// 失败的例子exec(&#x27;ls hello.txt&#x27;, function(error, stdout, stderr)&#123;    if(error) &#123;        console.error(&#x27;error: &#x27; + error);        return;    &#125;    console.log(&#x27;stdout: &#x27; + stdout);    console.log(&#x27;stderr: &#x27; + stderr);&#125;);\n\n参数说明：\ncwd：当前工作路径。\nenv：环境变量。\nencoding：编码，默认是utf8。\nshell：用来执行命令的shell，unix上默认是/bin/sh，windows上默认是cmd.exe。\ntimeout：默认是0。\nkillSignal：默认是SIGTERM。\nuid：执行进程的uid。\ngid：执行进程的gid。\nmaxBuffer： 标准输出、错误输出最大允许的数据量（单位为字节），如果超出的话，子进程就会被杀死。默认是200*1024（就是200k啦）\n\n备注：\n\n如果timeout大于0，那么，当子进程运行超过timeout毫秒，那么，就会给进程发送killSignal指定的信号（比如SIGTERM）。\n如果运行没有出错，那么error为null。如果运行出错，那么，error.code就是退出代码（exist code），error.signal会被设置成终止进程的信号。（比如CTRL+C时发送的SIGINT）\n\nchild_process.execFile(file[, args][, options][, callback])跟.exec()类似，不同点在于，没有创建一个新的shell。至少有两点影响\n\n比child_process.exec()效率高一些。（实际待测试）\n一些操作，比如I&#x2F;O重定向，文件glob等不支持。\n\nchild_process.fork(modulePath[, args][, options])modulePath：子进程运行的模块。\n参数说明：（重复的参数说明就不在这里列举）\n\nexecPath： 用来创建子进程的可执行文件，默认是/usr/local/bin/node。也就是说，你可通过execPath来指定具体的node可执行文件路径。（比如多个node版本）\nexecArgv： 传给可执行文件的字符串参数列表。默认是process.execArgv，跟父进程保持一致。\nsilent： 默认是false，即子进程的stdio从父进程继承。如果是true，则直接pipe向子进程的child.stdin、child.stdout等。\nstdio： 如果声明了stdio，则会覆盖silent选项的设置。\n\n123456789101112var child_process = require(&#x27;child_process&#x27;);var child = child_process.fork(&#x27;./child.js&#x27;, &#123;  silent: true,  execArgv: process.execArgv&#125;);child.stdout.setEncoding(&#x27;utf8&#x27;);child.stdout.on(&#x27;data&#x27;, function(data)&#123;    console.log(data);&#125;);\n\nchild.js\n1console.log(&#x27;output from another silent child&#x27;);\n\nexec()与execFile()之间的区别首先，exec() 内部调用 execFile() 来实现，而 execFile() 内部调用 spawn() 来实现。\n\n\n\n\n\n\n\n\n\nexec() -&gt; execFile() -&gt; spawn()\n其次，execFile() 内部默认将 options.shell 设置为false，exec() 默认不是false。\n各种事件close当stdio流关闭时触发。这个事件跟exit不同，因为多个进程可以共享同个stdio流。参数：code（退出码，如果子进程是自己退出的话），signal（结束子进程的信号）问题：code一定是有的吗？（从对code的注解来看好像不是）比如用kill杀死子进程，那么，code是？\nexit参数：code、signal，如果子进程是自己退出的，那么code就是退出码，否则为null；如果子进程是通过信号结束的，那么，signal就是结束进程的信号，否则为null。这两者中，一者肯定不为null。注意事项：exit事件触发时，子进程的stdio stream可能还打开着。（场景？）此外，nodejs监听了SIGINT和SIGTERM信号，也就是说，nodejs收到这两个信号时，不会立刻退出，而是先做一些清理的工作，然后重新抛出这两个信号。（目测此时js可以做清理工作了，比如关闭数据库等。）\nSIGINT：interrupt，程序终止信号，通常在用户按下CTRL+C时发出，用来通知前台进程终止进程。SIGTERM：terminate，程序结束信号，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。shell命令kill缺省产生这个信号。如果信号终止不了，我们才会尝试SIGKILL（强制终止）。\n\n\n\n\n\n\n\n\n\nAlso, note that Node.js establishes signal handlers for SIGINT and SIGTERM and Node.js processes will not terminate immediately due to receipt of those signals. Rather, Node.js will perform a sequence of cleanup actions and then will re-raise the handled signal.\nerror当发生下列事情时，error就会被触发。当error触发时，exit可能触发，也可能不触发。（内心是崩溃的）\n\n无法创建子进程。\n进程无法kill。（TODO 举例子）\n向子进程发送消息失败。（TODO 举例子）\n\nmessage当采用process.send()来发送消息时触发。参数：message，为json对象，或者primitive value；sendHandle，net.Socket对象，或者net.Server对象（熟悉cluster的同学应该对这个不陌生）\n.connected：当调用.disconnected()时，设为false。代表是否能够从子进程接收消息，或者对子进程发送消息。\n**.disconnect()**：关闭父进程、子进程之间的IPC通道。当这个方法被调用时，disconnect事件就会触发。如果子进程是node实例（通过child_process.fork()创建），那么在子进程内部也可以主动调用process.disconnect()来终止IPC通道。参考process.disconnect。\n请注意，exec方法默认的最大允许输出到stdout和stderr的数据量不超过200K，如果超过了，子进程就会被杀死\n","slug":"nodejs/child_process子进程","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"nodejs","author_index":"MessageWall"},{"id":"82f36b6cdf1b51332fd89a2d40fab706","title":"cluster模块","content":"cluster模块Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。**对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置**。cluster模块就是为了解决这个问题而提出的。\n\ncluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。\nworker之间采用进程间通信交换消息，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个worker进程之间的负载。\n运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。\n\n12345678910111213var cluster = require(&#x27;cluster&#x27;);var os = require(&#x27;os&#x27;);if (cluster.isMaster)&#123;  for (var i = 0, n = os.cpus().length; i &lt; n; i += 1)&#123;    cluster.fork();  &#125;&#125; else &#123;  http.createServer(function(req, res) &#123;    res.writeHead(200);    res.end(&quot;hello world\\n&quot;);  &#125;).listen(8000);&#125;\n\n上面代码先判断当前进程是否为主进程（cluster.isMaster），如果是的，就按照CPU的核数，新建若干个worker进程；如果不是，说明当前进程是worker进程，则在该进程启动一个服务器程序。上面这段代码有一个缺点，就是一旦work进程挂了，主进程无法知道。为了解决这个问题，可以在主进程部署online事件和exit事件的监听函数。\n12345678910111213141516var cluster = require(&#x27;cluster&#x27;);if(cluster.isMaster) &#123;  var numWorkers = require(&#x27;os&#x27;).cpus().length;  console.log(&#x27;Master cluster setting up &#x27; + numWorkers + &#x27; workers...&#x27;);  for(var i = 0; i &lt; numWorkers; i++) &#123;    cluster.fork();  &#125; cluster.on(&#x27;online&#x27;, function(worker) &#123;    console.log(&#x27;Worker &#x27; + worker.process.pid + &#x27; is online&#x27;);  &#125;);cluster.on(&#x27;exit&#x27;, function(worker, code, signal) &#123;    console.log(&#x27;Worker &#x27; + worker.process.pid + &#x27; died with code: &#x27; + code + &#x27;, and signal: &#x27; + signal);    console.log(&#x27;Starting a new worker&#x27;);    cluster.fork();  &#125;);&#125;\n\n上面代码中，主进程一旦监听到worker进程的exit事件，就会重启一个worker进程。worker进程一旦启动成功，可以正常运行了，就会发出online事件。\ncluster模块的属性与方法isMaster，isWorkerisMaster属性返回一个布尔值，表示当前进程是否为主进程。这个属性由process.env.NODE_UNIQUE_ID决定，如果process.env.NODE_UNIQUE_ID为未定义，就表示该进程是主进程。isWorker属性返回一个布尔值，表示当前进程是否为work进程。它与isMaster属性的值正好相反。\nfork()fork方法用于新建一个worker进程，上下文都复制主进程。只有主进程才能调用这个方法。该方法返回一个worker对象。\nkill()kill方法用于终止worker进程。它可以接受一个参数，表示系统信号。\n\n如果当前是主进程，就会终止与worker.process的联络，然后将系统信号法发向worker进程。\n如果当前是worker进程，就会终止与主进程的通信，然后退出，返回0。\n在以前的版本中，该方法也叫做 worker.destroy() 。\n\nlistening事件worker进程调用listen方法以后，“listening”就传向该进程的服务器，然后传向主进程。该事件的回调函数接受两个参数，一个是当前worker对象，另一个是地址对象，包含网址、端口、地址类型（IPv4、IPv6、Unix socket、UDP）等信息。这对于那些服务多个网址的Node应用程序非常有用。\n123cluster.on(&#x27;listening&#x27;, function(worker, address) &#123;  console.log(&quot;A worker is now connected to &quot; + address.address + &quot;:&quot; + address.port);&#125;);\n\nworker对象worker对象是cluster.fork()的返回值，代表一个worker进程。它的属性和方法如下\nworker.idwork.id返回当前worker的独一无二的进程编号。这个编号也是cluster.workers中指向当前进程的索引值。\nworker.process所有的worker进程都是用child_process.fork()生成的。child_process.fork()返回的对象，就被保存在worker.process之中。通过这个属性，可以获取worker所在的进程对象。\nworker.send()该方法用于在主进程中，向子进程发送信息。\n12345678if (cluster.isMaster) &#123;  var worker = cluster.fork();  worker.send(&#x27;hi there&#x27;);&#125; else if (cluster.isWorker) &#123;  process.on(&#x27;message&#x27;, function(msg) &#123;    process.send(msg);  &#125;);&#125;\n\n上面代码的作用是，worker进程对主进程发出的每个消息，都做回声。在worker进程中，要向主进程发送消息，使用process.send(message)；要监听主进程发出的消息，使用下面的代码。\n123process.on(&#x27;message&#x27;, function(message) &#123;  console.log(message);&#125;);\n\n发出的消息可以字符串，也可以是JSON对象。下面是一个发送JSON对象的例子。\n1234567worker.send(&#123;  type: &#x27;task 1&#x27;,  from: &#x27;master&#x27;,  data: &#123;    // the data that you want to transfer  &#125;&#125;);\n\ncluster.workers对象该对象只有主进程才有，包含了所有worker进程。每个成员的键值就是一个worker进程对象，键名就是该worker进程的worker.id属性。\n12345678function eachWorker(callback) &#123;  for (var id in cluster.workers) &#123;    callback(cluster.workers[id]);  &#125;&#125;eachWorker(function(worker) &#123;  worker.send(&#x27;big announcement to all workers&#x27;);&#125;);\n\n上面代码用来遍历所有worker进程。当前socket的data事件，也可以用id属性识别worker进程。\n123socket.on(&#x27;data&#x27;, function(id) &#123;  var worker = cluster.workers[id];&#125;);\n\nPM2模块PM2模块是cluster模块的一个包装层。它的作用是尽量将cluster模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。\n123456// app.jsvar http = require(&#x27;http&#x27;);http.createServer(function(req, res) &#123;  res.writeHead(200);  res.end(&quot;hello world&quot;);&#125;).listen(8080);\n\n上面代码是标准的Node架设Web服务器的方式，然后用PM2从命令行启动这段代码。\n1$ pm2 start app.js -i 4\n\n上面代码的i参数告诉PM2，这段代码应该在cluster_mode启动，且新建worker进程的数量是4个。如果i参数的值是0，那么当前机器有几个CPU内核，PM2就会启动几个worker进程。如果一个worker进程由于某种原因挂掉了，会立刻重启该worker进程。\n12# 重启所有worker进程$ pm2 reload all\n\n每个worker进程都有一个id，可以用下面的命令查看单个worker进程的详情。\n1$ pm2 show &lt;worker id&gt;\n\n正确情况下，PM2采用fork模式新建worker进程，即主进程fork自身，产生一个worker进程。pm2 reload命令则会用spawn方式启动，即一个接一个启动worker进程，一个新的worker启动成功，再杀死一个旧的worker进程。采用这种方式，重新部署新版本时，服务器就不会中断服务。\n1$ pm2 reload &lt;脚本文件名&gt;\n\n关闭worker进程的时候，可以部署下面的代码，让worker进程监听shutdown消息。一旦收到这个消息，进行完毕收尾清理工作再关闭。\n12345678process.on(&#x27;message&#x27;, function(msg) &#123;  if (msg === &#x27;shutdown&#x27;) &#123;    close_all_connections();    delete_logs();    server.close();    process.exit(0);  &#125;&#125;);\n\ncluster的内部实现原理是封装了一层child_process–fork，而child_process–fork 则是封装了unix 系统的fork 方法\nchild_process  是 nodejs的子进程\n","slug":"nodejs/cluster模块","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"nodejs","author_index":"MessageWall"},{"id":"de492e5254c0d9727d90a25b8c994938","title":"es6 扩展运算符 三个点（...）","content":"es6之扩展运算符 三个点（…）对象的扩展运算符理解对象的扩展运算符其实很简单，只要记住一句话就可以：\n\n\n\n\n\n\n\n\n\n对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中\n12let bar = &#123; a: 1, b: 2 &#125;;let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;\n\n上述方法实际上等价于:\n12let bar = &#123; a: 1, b: 2 &#125;;let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n12let bar = &#123;a: 1, b: 2&#125;;let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;\n\n利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。\n这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：\n1234let obj1 = &#123; a: 1, b: 2&#125;;let obj2 = &#123; ...obj1, b: &#x27;2-edited&#x27;&#125;;console.log(obj1); // &#123;a: 1, b: 2&#125;console.log(obj2); //  &#123;a: 1, b: &quot;2-edited&quot;&#125;\n\n上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：\n12345let obj1 = &#123; a: 1, b: 2, c: &#123;nickName: &#x27;d&#x27;&#125;&#125;;let obj2 = &#123; ...obj1&#125;;obj2.c.nickName = &#x27;d-edited&#x27;;console.log(obj1); // &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;console.log(obj2); // &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;\n\n这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。\n数组的扩展运算符扩展运算符同样可以运用在对数组的操作中。\n\n可以将数组转换为参数序列\n\n123456function add(x, y) &#123;  return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42\n\n\n可以复制数组\n\n如果直接通过下列的方式进行数组复制是不可取的：\n1234const arr1 = [1, 2];const arr2 = arr1;arr2[0] = 2;arr1 // [2, 2]\n\n原因上面已经介绍过，用扩展运算符就很方便：\n12const arr1 = [1, 2];const arr2 = [...arr1];\n\n还是记住那句话：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。\n\n扩展运算符可以与解构赋值结合起来，用于生成数组\n\n123const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]\n\n需要注意的一点是：\n\n\n\n\n\n\n\n\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n12345const [...rest, last] = [1, 2, 3, 4, 5];// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];// 报错1234\n\n\n扩展运算符还可以将字符串转为真正的数组\n\n12[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]\n\n\n任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组\n\n这点说的比较官方，大家具体可以参考阮一峰老师的ECMAScript 6入门教程。\n比较常见的应用是可以将某些数据结构转为数组,比如：\n1234// arguments对象function foo() &#123;  const args = [...arguments];&#125;\n\n用于替换es5中的Array.prototype.slice.call(arguments)写法。\n总结扩展运算符的用法就说到这里，介绍的不全但都是些最常见的用法。\n","slug":"javascript/es6 扩展运算符 三个点（...）","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"javascript","author_index":"MessageWall"},{"id":"4204a67837c41d553feb07de8c336aa2","title":"几种经典的排序算法","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var arr = [1,2,4,9, 11, 18,66,9,1,55, 7, 43, 96,52];// 冒泡排序function maopao(arr) &#123;  for(let i in arr) &#123;    for(let j in arr) &#123;      if(arr[i] &lt; arr[j]) &#123;        let temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;      &#125;    &#125;  &#125;  return arr&#125;// console.log(&quot;冒泡排序的结果&quot;, maopao(arr));// 选择排序function xuanze(arr) &#123;  var minNum, temp;  for(let i in arr) &#123;    minNum = i;    for(let j = i; j &lt; arr.length; j ++) &#123;      if(arr[j] &lt; arr[i]) &#123;        minNum = j;      &#125;    &#125;    temp = arr[minNum];    arr[minNum] = arr[i];    arr[i] = temp;  &#125;  return arr;&#125;// console.log(&quot;选择排序的结果是&quot;, xuanze(arr));// 插入排序function charu(arr) &#123;  var preIndex, current;  for(let i in arr) &#123;    preIndex = i -1;    current = arr[i];    while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;      arr[preIndex + 1] = arr[preIndex]      preIndex --;    &#125;    arr[preIndex + 1] = current;  &#125;  return arr;&#125;// console.log(arr);// console.log(&quot;插入排序的结果为&quot;, charu(arr));// 快速排序function quickSort(arr, left, right) &#123;  var left = typeof left != &#x27;number&#x27; ? 0 : left;  var right = typeof right != &#x27;number&#x27; ? arr.length - 1 : right;  var partitionIndex;  if(left &lt; right) &#123;    partitionIndex = partition(arr, left, right)    quickSort(arr, left, partitionIndex - 1);    quickSort(arr, partitionIndex + 1, right);   &#125;  return arr;&#125;function partition(arr, left, right) &#123;  var pivot = left;   // 设置基准值  var index = pivot + 1;    for(let i = index; i &lt;= right; i++) &#123;    if(arr[i] &lt; arr[pivot]) &#123;      swap(arr, i, index)      // console.log(arr, i, index,  arr[pivot]);      index ++;    &#125;  &#125;  swap(arr, pivot, index - 1)  return index - 1;&#125;function swap(arr, i, j) &#123;  var temp = arr[i];  arr[i] = arr[j];  arr[j] = temp;&#125;console.log(arr);console.log(&quot;快速排序的结果为&quot;, quickSort(arr));\n\n","slug":"javascript/几种经典的排序算法","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"javascript","author_index":"MessageWall"},{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"正则表达式match() 方法match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。语法\n12stringObject.match(searchvalue)stringObject.match(regexp)\n\n\n\n\n参数\n描述\n\n\n\nsearchvalue\n必需。规定要检索的字符串值。\n\n\nregexp\n必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。\n\n\n返回值存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。\n说明match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。\n","slug":"javascript/正则表达式","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"javascript","author_index":"MessageWall"},{"id":"e755fa687ba8e5a830b46f785612d7d7","title":"typescript装饰器","content":"了解typescript装饰器\n\n\n\n\n\n\n\n\n装饰器是一种特殊类型的声明，它能够附加到类、类的函数、类属性、类函数的参数上，以达到修改类的行为\n一、装饰器的种类\n根据装饰器的位置\n\n\n类装饰器\n类函数装饰器\n类属性装饰器\n类函数参数装饰器\n\n\n根据装饰器是否有参数\n\n\n无参数装饰器（一般装饰器）\n有参数装饰器（装饰器工厂）\n\n\n\n\n\n\n\n\n\n\n装饰器是一项实验性特性，在未来的版本中可能会发生改变\n若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项：\n命令行:\n1tsc --target ES5 --experimentalDecorators\n\ntsconfig.json:\n123456&#123;    &quot;compilerOptions&quot;: &#123;        &quot;target&quot;: &quot;ES5&quot;,        &quot;experimentalDecorators&quot;: true    &#125;&#125;\n\n二、类的装饰器\n1、类装饰器的写法\n\n123456789101112131415161718function desc(target) &#123;  console.log(&#x27;---------------类的装饰器参数 start------------------&#x27;);  console.log(target); // 输出 [Function: Person]表示当前装饰的类  console.log(&#x27;---------------类的装饰器参数 end------------------&#x27;);&#125;@desc // 使用装饰器class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);\n\n\n2、使用类的装饰器扩展类的属性和方法\n\n12345678910111213141516171819202122232425262728293031323334function desc(target) &#123;  console.log(&#x27;---------------类的装饰器参数 start------------------&#x27;);  console.log(target);  console.log(&#x27;---------------类的装饰器参数 end------------------&#x27;);  return class extends target&#123; // 在react高阶组件中经常看到这种写法    gender = &#x27;男&#x27;;    say() &#123;      console.log(this.name, this.age, this.gender);    &#125;  &#125;&#125;@descclass Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say();/*---------------类的装饰器参数 start------------------[Function: Person]---------------类的装饰器参数 end------------------class_1 &#123; name: &#x27;哈哈&#x27;, age: 20, gender: &#x27;男&#x27; &#125;哈哈 20 男*/\n\n\n3、使用装饰器修改类的构造函数(构造函数的重载、方法重载)\n\n123456789101112131415161718192021222324252627function desc(target) &#123;  return class extends target&#123;    name = &#x27;我是重载后的&#x27;;    sayHell() &#123;      console.log(&#x27;我是重载后的&#x27;, this.name);    &#125;  &#125;&#125;@descclass Person &#123;  public name: string | undefined;  public age: number | 0;  constructor() &#123;    this.name = &#x27;哈哈&#x27;;    this.age = 20;  &#125;  sayHell() &#123;    console.log(&#x27;hello word&#x27;, this.name);  &#125;&#125;let p = new Person();console.log(p);p.sayHell();\n\n\n4、装饰器工厂的写法\n\n1234567891011121314151617181920function desc(params: string) &#123;  return function (targe: any) &#123;    console.log(&#x27;---------------参数说明 start------------------&#x27;);    console.log(&#x27;params&#x27;, params);    console.log(&#x27;target&#x27;, targe);    console.log(&#x27;---------------参数说明 end------------------&#x27;);    // 直接在原型上扩展一个属性    targe.prototype.apiUrl = params;  &#125;&#125;@desc(&#x27;http://www.baidu.com&#x27;)class P &#123;  say() &#123;    console.log(&#x27;说话&#x27;)  &#125;&#125;let p:any = new P();console.log(p.apiUrl);\n\n三、类函数装饰器\n\n\n\n\n\n\n\n\n它应用到方法上，可以用来监视、修改、替换该方法\n\n1、定义方式\n\n1234567function desc(target, key, descriptor) &#123;  console.log(&#x27;---------------类的装饰器参数 start------------------&#x27;);  console.log(&#x27;target&#x27;, target); // Person &#123; say: [Function] &#125; 表示类的原型  console.log(&#x27;key&#x27;, key); // 被装饰的函数名  console.log(&#x27;descriptor&#x27;, descriptor); // 被装饰的函数的对象属性  console.log(&#x27;---------------类的装饰器参数 end------------------&#x27;);&#125;\n\n\n2、使用\n\n1234567891011121314class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  @desc  say() &#123;    console.log(&#x27;说的方法&#x27;)  &#125;&#125;\n\n\n3、在装饰器中添加类的原型属性和原型方法\n\n1234567891011121314function desc(target, key, descriptor) &#123;  target.gender = &#x27;男&#x27;;  target.foo = function () &#123;    console.log(&#x27;我是原型上的方法&#x27;)  &#125;&#125;// 测试代码let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);console.log(Person.prototype);p.say();console.log(p.gender); // 使用p原型链上的属性p.foo() // 调用了p原型链上的方法\n\n\n4、使用装饰器拦截函数的调用(替换)\n\n123456789101112131415161718192021222324252627282930function desc(params: string) &#123;  return function (target: any, key: string, descriptor: &#123;[propsName: string]: any&#125;) &#123;    // 修改被装饰的函数的    let method = descriptor.value;    descriptor.value = function (...args: Array&lt;any&gt;) &#123;      args = args.map(it =&gt; String(it));      console.log(args);      // method.apply(this, args);    &#125;  &#125;&#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  @desc(&#x27;装饰器上的参数&#x27;)  say() &#123;    console.log(&#x27;说的方法&#x27;)  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say(123, 23, &#x27;你好&#x27;);\n\n\n5、使用装饰器拦截函数的调用(附加新的功能)\n\n123456789101112131415161718192021222324252627282930function desc(params: string) &#123;  return function (target: any, key: string, descriptor: &#123;[propsName: string]: any&#125;) &#123;    // 修改被装饰的函数的    let method = descriptor.value;    descriptor.value = function (...args: Array&lt;any&gt;) &#123;      args = args.map(it =&gt; String(it));      console.log(args);      method.apply(this, args);    &#125;  &#125;&#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  @desc(&#x27;装饰器上的参数&#x27;)  say(...args) &#123;    console.log(&#x27;说的方法&#x27;, args)  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say(123, 23, &#x27;你好&#x27;);\n\n四、类属性装饰器\n1、定义方式\n\n1234567891011121314151617181920212223function desc(target, name) &#123;  console.log(&#x27;---------------类属性装饰器的参数 start------------------&#x27;);  console.log(&#x27;target&#x27;, target, target.constructor); // 表示类的原型  console.log(&#x27;name&#x27;, name); // 表示被装饰属性名  console.log(&#x27;---------------类属性装饰器的参数 end------------------&#x27;);&#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  @desc  private gender: string | undefined;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);\n\n\n2、在装饰器中修改属性值\n\n12345678910111213141516171819202122232425function desc(target, name) &#123;  target[name] = &#x27;女&#x27;;&#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  @desc  public gender: string | undefined;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  say() &#123;    console.log(this.name, this.age, this.gender);  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say();\n\n五、类函数参数的装饰器\n\n\n\n\n\n\n\n\n参数装饰器表达式会在运行时候当做函数被调用，以使用参数装饰器为类的原型上附加一些元数据\n\n1、使用方式\n\n1234567891011121314151617181920212223242526function desc(params: string) &#123;  return function (target: any, key, index) &#123;    console.log(&#x27;---------------参数装饰器 start------------------&#x27;);    console.log(target); // 类的原型    console.log(key); // 被装饰的名字    console.log(index); // 序列化    console.log(&#x27;---------------参数装饰器 end------------------&#x27;);  &#125; &#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  say(@desc(&#x27;参数装饰器&#x27;) age: number) &#123;    console.log(&#x27;说的方法&#x27;)  &#125;&#125;let p = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say(20);\n\n\n2、为类的原型上添加一些东西\n\n1234567891011121314151617181920212223242526272829function desc(params: string) &#123;  return function (target: any, key, index) &#123;    console.log(&#x27;---------------参数装饰器 start------------------&#x27;);    console.log(target); // 类的原型    console.log(key); // 被装饰的名字    console.log(index); // 序列化    target.message = params;    console.log(&#x27;---------------参数装饰器 end------------------&#x27;);  &#125; &#125;class Person &#123;  public name: string | undefined;  public age: number | 0;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  say(@desc(&#x27;参数装饰器&#x27;) age: number) &#123;    console.log(&#x27;说的方法&#x27;)  &#125;&#125;let p: any = new Person(&#x27;哈哈&#x27;, 20);console.log(p);p.say(20);console.log(p.message)\n\n六、几种装饰器的执行顺序\n1、测试代码\n\n12345678910111213141516171819202122232425262728293031323334function logCls(params: string) &#123;  return function (target: any) &#123;    console.log(&#x27;4.类的装饰器&#x27;);  &#125;&#125;function logMehod(params: string) &#123;  return function (target: any, key: string, descriptor: &#123;[propsName: string]: any&#125;) &#123;    console.log(&#x27;3.类的函数装饰器&#x27;);  &#125;&#125;function logParams(params: string) &#123;  return function (target: any, name: string) &#123;    console.log(&#x27;1.类属性装饰器&#x27;);  &#125;&#125;function logQuery(params: string) &#123;  return function (target: any, key: string, index: number) &#123;    console.log(&#x27;2.函数参数装饰器&#x27;);  &#125;&#125;@logCls(&#x27;类的装饰器&#x27;)class Person&#123;  @logParams(&#x27;属性装饰器&#x27;)  public name: string | undefined;  @logMehod(&#x27;函数装饰器&#x27;)  getData(@logQuery(&#x27;函数参数装饰器&#x27;) age: number, @logQuery(&#x27;函数参数装饰器&#x27;) gender: string) &#123;    console.log(&#x27;----&#x27;);  &#125;&#125;\n\n\n2、运行结果\n\n12341.类属性装饰器2.函数参数装饰器3.类的函数装饰器4.类的装饰器","slug":"typescript/typescript装饰器","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"typescript","author_index":"MessageWall"},{"id":"f68b1b9ce9afbf4ff10bd16916415d01","title":"react的context","content":"React的contextContext 意为上下文，提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。\n具体详见：context官方API\n\nReact.createContext\nContext.Provider\nClass.contextType\nContext.Consumer\nContext.displayName\n\n创建Context  React.createContext(defaultValue)12345import React from &quot;react&quot;;export const AppContext = React.createContext(&#123;  age: 18&#125;);\n\n注意：React.createContext(defaultValue) 只有当Provider不存在时，defaultValue才会生效\n123456789101112131415161718192021222324252627import &quot;./styles.css&quot;;import React, &#123; useState &#125; from &quot;react&quot;;import Header from &quot;./components/header&quot;;import Content from &quot;./components/content&quot;;import TextContext from &quot;./components/testContext&quot;;import &#123; AppContext &#125; from &quot;./common/context&quot;;export default function App() &#123;  return (    &lt;&gt;      &lt;AppContext.Provider        value=&#123;&#123;          username: &quot;小王&quot;,          age: 1        &#125;&#125;      &gt;        &lt;div&gt;          &lt;Header&gt;&lt;/Header&gt;          &lt;Content&gt;&lt;/Content&gt;        &lt;/div&gt;      &lt;/AppContext.Provider&gt;      &lt;TextContext&gt;&lt;/TextContext&gt; &lt;!-- 这个组件的defaultValue才会生效 --&gt;    &lt;/&gt;  );&#125;\n\nContext.Provider1&lt;AppContext.Provider value=&#123;/* 某个值 */&#125;&gt;\n\n每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\nProvider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。\nClass.contextType只有在类组件中指定了contextType的值是哪个Context，才可以在类中使用this.context\nContext.Consumer12345&lt;AppContext.Consumer&gt;  &#123;(value) =&gt; &#123;    return value.sex;  &#125;&#125;&lt;/AppContext.Consumer&gt;\n\n订阅context的变更\nContext.displayNamecontext 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。\n示例，下述组件在 DevTools 中将显示为 MyDisplayName：\n1234const MyContext = React.createContext(/* some value */);MyContext.displayName = &#x27;MyDisplayName&#x27;;&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中\n\n没啥用\n","slug":"react/react的context","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"react","author_index":"MessageWall"},{"id":"62c1067b8dc3136f28f0726e0181c9fa","title":"初始化一个react项目","content":"使用 create-react-app 快速构建 React 开发环境create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。\ncreate-react-app 自动创建的项目是基于 Webpack + ES6 。\n安装\n1$ cnpm install -g create-react-app\n\n使用create-react-app创建ts项目\n1create-react-app 你的项目名 --typescript  \n\n运行\n1npm run start\n\n\n\n","slug":"react/初始化一个react项目","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"react","author_index":"MessageWall"},{"id":"d4d2f14b32186159d88bc0a11749967b","title":"1. vscode插件开发准备","content":"VSCode插件开发所有笔记均参考于 https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html\nVSCode插件开发官方文档：https://code.visualstudio.com/docs/extensions/overview\n项目结构项目结构其实很简单，主要是清单文件package.json以及extension.js这个插件入口文件：\n\npackage.json部分关键内容如下（已省略其它）\n1234567891011121314151617&#123;\t// 扩展的激活事件    &quot;activationEvents&quot;: [        &quot;onCommand:extension.sayHello&quot;    ],\t// 入口文件    &quot;main&quot;: &quot;./src/extension&quot;,\t// 贡献点，vscode插件大部分功能配置都在这里    &quot;contributes&quot;: &#123;        &quot;commands&quot;: [            &#123;                &quot;command&quot;: &quot;extension.sayHello&quot;,                &quot;title&quot;: &quot;Hello World&quot;            &#125;        ]    &#125;&#125;\n\nsrc/extension.js内容如下：\n1234567891011121314151617181920const vscode = require(&#x27;vscode&#x27;);/** * 插件被激活时触发，所有代码总入口 * @param &#123;*&#125; context 插件上下文 */exports.activate = function(context) &#123;    console.log(&#x27;恭喜，您的扩展“vscode-plugin-demo”已被激活！&#x27;);    // 注册命令    context.subscriptions.push(vscode.commands.registerCommand(&#x27;extension.sayHello&#x27;, function () &#123;        vscode.window.showInformationMessage(&#x27;Hello World!&#x27;);    &#125;));&#125;;/** * 插件被释放时触发 */exports.deactivate = function() &#123;    console.log(&#x27;您的扩展“vscode-plugin-demo”已被释放！&#x27;)&#125;;\n\n解读承如上述代码：\n\nmain定义了整个插件的主入口；\n我们在contributes.commands里面注册了一个名为extension.sayHello的命令，并在src/extension.js中去实现了它（弹出一个Hello World的提示）；\n但是仅仅这样还不够，命令虽然定义了，但是vscode还不知道啥时候去执行它，还需要在activationEvents添加上onCommand:extension.sayHello用来告诉vscode，当用户执行了这个命令操作时去执行前面我们定义的内容；\n除了onCommand之外，还有onView、onUri、onLanguage等等，具体我们后面会详细讲到。\n\n运行调试默认情况下，工程已经帮我们配置好了调试相关参数（有兴趣的可以查看.vscode/launch.json文件的写法），只需要到调试面板选中要调试的项目(仅仅是第一次需要，后续会自动记住上次调试的项目)，然后按下F5就会弹出一个新的vscode窗口：\n\n这个新窗口已经加载了我们的插件，窗口标题会注明扩展开发主机，对于只有单显示器的同学来说，很容易写着写着就忘了哪个是主窗口，哪个是新窗口，所以可以通过这个来区分。\n\n先插句话：\n\n\n\n\n\n\n\n\n\n为了描述方便，我们约定，后续把新弹出来的那个窗口叫新窗口，之前老的那个叫旧窗口。\n添加右键菜单和快捷键上面由于我们只是注册了命令，没有添加菜单或快捷键，调用不方便，所以我们现在添加一下。\n打开package.json，按照下述方式添加：\n1234567891011121314151617181920212223242526272829&#123;    &quot;contributes&quot;: &#123;        &quot;commands&quot;: [            &#123;                &quot;command&quot;: &quot;extension.sayHello&quot;,                &quot;title&quot;: &quot;Hello World&quot;            &#125;        ],\t\t// 快捷键绑定        &quot;keybindings&quot;: [            &#123;                &quot;command&quot;: &quot;extension.sayHello&quot;,                &quot;key&quot;: &quot;ctrl+f10&quot;,                &quot;mac&quot;: &quot;cmd+f10&quot;,                &quot;when&quot;: &quot;editorTextFocus&quot;            &#125;        ],\t\t// 设置菜单        &quot;menus&quot;: &#123;            &quot;editor/context&quot;: [                &#123;                    &quot;when&quot;: &quot;editorFocus&quot;,                    &quot;command&quot;: &quot;extension.sayHello&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;            ]        &#125;    &#125;&#125;\n\n然后重新运行插件，在编辑器的右键可以看到如下菜单：\n\n这里我们暂时不对配置项做过渡解读，后面会有专门篇章来介绍package.json文件的写法。\n关于重新加载如果修改了扩展代码，想重新加载的话，可以直接在新窗口上按下Ctrl+R来快速重新加载，也可以先停止，然后再按F5。\n关于开发语言vscode插件可以使用TypeScript来编写（官方推荐），也可以使用JavaScript，本文统一使用后者，不过使用哪种方式，能实现的功能都是一样的。\n脚手架的使用终于到脚手架环节了，如果你喜欢干净的项目的话，可以使用官方脚手架来生成。\n安装脚手架：\n1npm install -g yo generator-code\n\n然后cd到你的工作目录，运行yo code：\n\n根据向导一步步选择即可，没啥好说的，运行完后就生成了一个干净的可以直接F5运行的vscode插件工程了\n\nhttps://code.visualstudio.com/docs/extensionAPI/extension-points#_contributescolors)\n\n","slug":"vscode插件开发/1. vscode插件开发准备","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"44304d0d5fcde65fc4021b89b93798e6","title":"2. package.json","content":"package.json在详细介绍vscode插件开发细节之前，这里我们先详细介绍一下vscode插件的package.json写法，但是建议先只需要随便看一下，了解个大概，等后面讲到具体细节的时候再回过头来看。\n如下是package.json文件的常用配置，当然这里还不是全部：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&#123;\t// 插件的名字，应全部小写，不能有空格    &quot;name&quot;: &quot;vscode-plugin-demo&quot;,\t// 插件的友好显示名称，用于显示在应用市场，支持中文    &quot;displayName&quot;: &quot;VSCode插件demo&quot;,\t// 描述    &quot;description&quot;: &quot;VSCode插件demo集锦&quot;,\t// 关键字，用于应用市场搜索    &quot;keywords&quot;: [&quot;vscode&quot;, &quot;plugin&quot;, &quot;demo&quot;],\t// 版本号    &quot;version&quot;: &quot;1.0.0&quot;,\t// 发布者，如果要发布到应用市场的话，这个名字必须与发布者一致    &quot;publisher&quot;: &quot;sxei&quot;,\t// 表示插件最低支持的vscode版本    &quot;engines&quot;: &#123;        &quot;vscode&quot;: &quot;^1.27.0&quot;    &#125;,\t// 插件应用市场分类，可选值： [Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]    &quot;categories&quot;: [        &quot;Other&quot;    ],\t// 插件图标，至少128x128像素    &quot;icon&quot;: &quot;images/icon.png&quot;,\t// 扩展的激活事件数组，可以被哪些事件激活扩展，后文有详细介绍    &quot;activationEvents&quot;: [        &quot;onCommand:extension.sayHello&quot;    ],\t// 插件的主入口    &quot;main&quot;: &quot;./src/extension&quot;,\t// 贡献点，整个插件最重要最多的配置项    &quot;contributes&quot;: &#123;\t\t// 插件配置项\t\t&quot;configuration&quot;: &#123;            &quot;type&quot;: &quot;object&quot;,\t\t\t// 配置项标题，会显示在vscode的设置页            &quot;title&quot;: &quot;vscode-plugin-demo&quot;,            &quot;properties&quot;: &#123;\t\t\t\t// 这里我随便写了2个设置，配置你的昵称                &quot;vscodePluginDemo.yourName&quot;: &#123;                    &quot;type&quot;: &quot;string&quot;,                    &quot;default&quot;: &quot;guest&quot;,                    &quot;description&quot;: &quot;你的名字&quot;                &#125;,\t\t\t\t// 是否在启动时显示提示                &quot;vscodePluginDemo.showTip&quot;: &#123;                    &quot;type&quot;: &quot;boolean&quot;,                    &quot;default&quot;: true,                    &quot;description&quot;: &quot;是否在每次启动时显示欢迎提示！&quot;                &#125;            &#125;        &#125;,\t\t// 命令        &quot;commands&quot;: [            &#123;                &quot;command&quot;: &quot;extension.sayHello&quot;,                &quot;title&quot;: &quot;Hello World&quot;            &#125;        ],\t\t// 快捷键绑定        &quot;keybindings&quot;: [            &#123;                &quot;command&quot;: &quot;extension.sayHello&quot;,                &quot;key&quot;: &quot;ctrl+f10&quot;,                &quot;mac&quot;: &quot;cmd+f10&quot;,                &quot;when&quot;: &quot;editorTextFocus&quot;            &#125;        ],\t\t// 菜单        &quot;menus&quot;: &#123;\t\t\t// 编辑器右键菜单            &quot;editor/context&quot;: [                &#123;\t\t\t\t\t// 表示只有编辑器具有焦点时才会在菜单中出现                    &quot;when&quot;: &quot;editorFocus&quot;,                    &quot;command&quot;: &quot;extension.sayHello&quot;,\t\t\t\t\t// navigation是一个永远置顶的分组，后面的@6是人工进行组内排序                    &quot;group&quot;: &quot;navigation@6&quot;                &#125;,                &#123;                    &quot;when&quot;: &quot;editorFocus&quot;,                    &quot;command&quot;: &quot;extension.demo.getCurrentFilePath&quot;,                    &quot;group&quot;: &quot;navigation@5&quot;                &#125;,                &#123;\t\t\t\t\t// 只有编辑器具有焦点，并且打开的是JS文件才会出现                    &quot;when&quot;: &quot;editorFocus &amp;&amp; resourceLangId == javascript&quot;,                    &quot;command&quot;: &quot;extension.demo.testMenuShow&quot;,                    &quot;group&quot;: &quot;z_commands&quot;                &#125;,                &#123;                    &quot;command&quot;: &quot;extension.demo.openWebview&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;            ],\t\t\t// 编辑器右上角图标，不配置图片就显示文字            &quot;editor/title&quot;: [                &#123;                    &quot;when&quot;: &quot;editorFocus &amp;&amp; resourceLangId == javascript&quot;,                    &quot;command&quot;: &quot;extension.demo.testMenuShow&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;            ],\t\t\t// 编辑器标题右键菜单            &quot;editor/title/context&quot;: [                &#123;                    &quot;when&quot;: &quot;resourceLangId == javascript&quot;,                    &quot;command&quot;: &quot;extension.demo.testMenuShow&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;            ],\t\t\t// 资源管理器右键菜单            &quot;explorer/context&quot;: [                &#123;                    &quot;command&quot;: &quot;extension.demo.getCurrentFilePath&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;,                &#123;                    &quot;command&quot;: &quot;extension.demo.openWebview&quot;,                    &quot;group&quot;: &quot;navigation&quot;                &#125;            ]        &#125;,\t\t// 代码片段        &quot;snippets&quot;: [            &#123;                &quot;language&quot;: &quot;javascript&quot;,                &quot;path&quot;: &quot;./snippets/javascript.json&quot;            &#125;,            &#123;                &quot;language&quot;: &quot;html&quot;,                &quot;path&quot;: &quot;./snippets/html.json&quot;            &#125;        ],\t\t// 自定义新的activitybar图标，也就是左侧侧边栏大的图标        &quot;viewsContainers&quot;: &#123;            &quot;activitybar&quot;: [                &#123;                    &quot;id&quot;: &quot;beautifulGirl&quot;,                    &quot;title&quot;: &quot;美女&quot;,                    &quot;icon&quot;: &quot;images/beautifulGirl.svg&quot;                &#125;            ]        &#125;,\t\t// 自定义侧边栏内view的实现        &quot;views&quot;: &#123;\t\t\t// 和 viewsContainers 的id对应            &quot;beautifulGirl&quot;: [                &#123;                    &quot;id&quot;: &quot;beautifulGirl1&quot;,                    &quot;name&quot;: &quot;国内美女&quot;                &#125;,                &#123;                    &quot;id&quot;: &quot;beautifulGirl2&quot;,                    &quot;name&quot;: &quot;国外美女&quot;                &#125;,                &#123;                    &quot;id&quot;: &quot;beautifulGirl3&quot;,                    &quot;name&quot;: &quot;人妖&quot;                &#125;            ]        &#125;,\t\t// 图标主题        &quot;iconThemes&quot;: [            &#123;                &quot;id&quot;: &quot;testIconTheme&quot;,                &quot;label&quot;: &quot;测试图标主题&quot;,                &quot;path&quot;: &quot;./theme/icon-theme.json&quot;            &#125;        ]    &#125;,\t// 同 npm scripts    &quot;scripts&quot;: &#123;        &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;,        &quot;test&quot;: &quot;node ./node_modules/vscode/bin/test&quot;    &#125;,\t// 开发依赖    &quot;devDependencies&quot;: &#123;        &quot;typescript&quot;: &quot;^2.6.1&quot;,        &quot;vscode&quot;: &quot;^1.1.6&quot;,        &quot;eslint&quot;: &quot;^4.11.0&quot;,        &quot;@types/node&quot;: &quot;^7.0.43&quot;,        &quot;@types/mocha&quot;: &quot;^2.2.42&quot;    &#125;,\t// 后面这几个应该不用介绍了    &quot;license&quot;: &quot;SEE LICENSE IN LICENSE.txt&quot;,    &quot;bugs&quot;: &#123;        &quot;url&quot;: &quot;https://github.com/sxei/vscode-plugin-demo/issues&quot;    &#125;,    &quot;repository&quot;: &#123;        &quot;type&quot;: &quot;git&quot;,        &quot;url&quot;: &quot;https://github.com/sxei/vscode-plugin-demo&quot;    &#125;,\t// 主页    &quot;homepage&quot;: &quot;https://github.com/sxei/vscode-plugin-demo/blob/master/README.md&quot;&#125;\n\nactivationEvents插件在VS Code中默认是没有被激活的，哪什么时候才被激活呢？就是通过activationEvents来配置，目前支持一下8种配置：\n\nonLanguage:${language}\nonCommand:${command}\nonDebug\nworkspaceContains:${toplevelfilename}\nonFileSystem:${scheme}\nonView:${viewId}\nonUri\n*\n\n都比较好懂，我就不做一一介绍了，举个例子，如果我配置了onLanguage:javascript，那么只要我打开了JS类型的文件，插件就会被激活。\n重点说一下*，如果配置了*，只要一启动vscode，插件就会被激活，为了出色的用户体验，官方不推荐这么做。看到这里相信大家知道了我们前面HelloWord里面为啥要配置onCommand了吧。\ncontributes\nconfiguration：设置\ncommands：命令\nmenus：菜单\nkeybindings：快捷键绑定\nlanguages：新语言支持\ndebuggers：调试\nbreakpoints：断点\ngrammars\nthemes：主题\nsnippets：代码片段\njsonValidation：自定义JSON校验\nviews：左侧侧边栏视图\nviewsContainers：自定义activitybar\nproblemMatchers\nproblemPatterns\ntaskDefinitions\n[colors](\n\n","slug":"vscode插件开发/2. package.json","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"f92875d3c6e56f019d49915a4496952b","title":"3. 命令、菜单、快捷键","content":"命令我们在前面HelloWord章节中已经提到了命令写法，这里再重温一下。\n123context.subscriptions.push(vscode.commands.registerCommand(&#x27;extension.sayHello&#x27;, () =&gt; &#123;    vscode.window.showInformationMessage(&#x27;您执行了extension.sayHello命令！&#x27;);&#125;));\n\n然后在清单文件声明：\n123456&quot;commands&quot;: [\t&#123;\t\t&quot;command&quot;: &quot;extension.sayHello&quot;,\t\t&quot;title&quot;: &quot;Hello World&quot;\t&#125;,]\n\nvscode.commands.registerCommand是注册命令的API，执行后会返回一个Disposable对象，所有注册类的API执行后都需要将返回结果放到context.subscriptions中去。\n1.1. 回调函数参数回调函数接收一个可选参数uri：\n\n当从资源管理器中右键执行命令时会把当前选中资源路径uri作为参数传过；\n当从编辑器中右键菜单执行时则会将当前打开文件路径URI传过去；\n当直接按Ctrl+Shift+P执行命令时，这个参数为空；\n\n示例：\n123context.subscriptions.push(vscode.commands.registerCommand(&#x27;extension.demo.getCurrentFilePath&#x27;, (uri) =&gt; &#123;    vscode.window.showInformationMessage(`当前文件(夹)路径是：$&#123;uri ? uri.path : &#x27;空&#x27;&#125;`);&#125;));\n\npackage.json如下：\n12345678910111213141516&quot;menus&quot;: &#123;           &quot;editor/context&quot;: [               &#123;                   &quot;when&quot;: &quot;editorFocus&quot;,                   &quot;command&quot;: &quot;extension.demo.getCurrentFilePath&quot;,                   &quot;group&quot;: &quot;navigation&quot;               &#125;           ],           &quot;explorer/context&quot;: [               &#123;                   &quot;command&quot;: &quot;extension.demo.getCurrentFilePath&quot;,                   &quot;group&quot;: &quot;navigation&quot;               &#125;           ]       &#125;&#125;\n\n最终效果：\n\n1.2. 编辑器命令除了上面的注册普通命令之外，还有一个vscode.commands.registerTextEditorCommand命令，文本编辑器命令与普通命令不同，它们仅在有被编辑器被激活时调用才生效，此外，这个命令可以访问到当前活动编辑器textEditor：\n12345// 编辑器命令context.subscriptions.push(vscode.commands.registerTextEditorCommand(&#x27;extension.testEditorCommand&#x27;, (textEditor, edit) =&gt; &#123;    console.log(&#x27;您正在执行编辑器命令！&#x27;);    console.log(textEditor, edit);&#125;));\n\n1.3. 执行命令这里先说一下vscode api的一个习惯设计，很多命令都是返回一个类似于Promise的Thenable对象，如果发现api里面返回的是这个对象，说明这个方法不是直接返回结果的。\n使用代码执行某个命令：\n123vscode.commands.executeCommand(&#x27;命令&#x27;, &#x27;params1&#x27;, &#x27;params2&#x27;, ...).then(result =&gt; &#123;\tconsole.log(&#x27;命令结果&#x27;, result);&#125;);\n\n1.4. 获取所有命令前面说到了执行命令，那我怎么知道某些操作它的命令是什么呢？\n有2种方法，第一种通过代码，getCommands接收一个参数表示是否过滤内部命令，默认否：\n1234// 获取所有命令vscode.commands.getCommands().then(allCommands =&gt; &#123;    console.log(&#x27;所有命令：&#x27;, allCommands);&#125;);\n\n一般有上千个命令：\n\n另外一种方法是直接打开快捷键设置，这里就能看到所有命令列表，右键可以复制命令：\n\n1.5. 复杂命令vscode内部有一些复杂命令，所谓复杂命令，就是指一些需要特殊参数并且通常有返回值、执行一些诸如跳转到定义、执行代码高亮等特殊操作、这类命令有几十个，作为插件开发者，很多时候你可能正需要这类命令，复杂命令列表参阅：https://code.visualstudio.com/docs/extensionAPI/vscode-api-commands\n以下是演示如何在VS代码中打开新文件夹的示例：\n1234let uri = Uri.file(&#x27;/some/path/to/folder&#x27;);commands.executeCommand(&#x27;vscode.openFolder&#x27;, uri).then(sucess =&gt; &#123;\tconsole.log(success);&#125;);\n\n菜单一个菜单项的完整配置如下：\n12345678910&quot;contributes&quot;: &#123;    &quot;menus&quot;: &#123;        &quot;editor/title&quot;: [&#123;            &quot;when&quot;: &quot;resourceLangId == markdown&quot;,            &quot;command&quot;: &quot;markdown.showPreview&quot;,            &quot;alt&quot;: &quot;markdown.showPreviewToSide&quot;,            &quot;group&quot;: &quot;navigation&quot;        &#125;]    &#125;&#125;\n\n\neditor/title是key值，定义这个菜单出现在哪里；\nwhen控制菜单合适出现；\ncommand定义菜单被点击后要执行什么操作；\nalt定义备用命令，按住alt键打开菜单时将执行对应命令；\ngroup定义菜单分组；\n\n2.1. 出现的位置目前插件可以给以下场景配置自定义菜单：\n\n资源管理器上下文菜单 - explorer/context\n编辑器上下文菜单 - editor/context\n编辑标题菜单栏 - editor/title\n编辑器标题上下文菜单 - editor/title/context\n调试callstack视图上下文菜单 - debug/callstack/context\nSCM标题菜单 -scm/title\nSCM资源组菜单 -scm/resourceGroup/context\nSCM资源菜单 -scm/resource/context\nSCM更改标题菜单 -scm/change/title\n左侧视图标题菜单 -view/title\n视图项菜单 -view/item/context\n控制命令是否显示在命令选项板中 - commandPalette\n\n其中，最常见的应该就explorer/context和editor/context了，这2个应该不用多做介绍。\neditor/title：\n\n图标在commands里面配置，light和dark分别对应浅色和深色主题，如果不配置图标则直接显示文字：\n12345678910&quot;commands&quot;: [    &#123;        &quot;command&quot;: &quot;extension.demo.testMenuShow&quot;,        &quot;title&quot;: &quot;这个菜单仅在JS文件中出现&quot;,        &quot;icon&quot;: &#123;            &quot;light&quot;: &quot;./images/tool-light.svg&quot;,            &quot;dark&quot;: &quot;./images/tool-light.svg&quot;        &#125;    &#125;]\n\neditor/title/context：\n\n2.2. when通过可选的when语句，VS Code可以很好地控制什么时候显示菜单项，当然，when语句语法不仅仅适用于菜单项的控制。\nwhen语句语法有很多，这里列举几个常用的：\n\nresourceLangId == javascript：当编辑的文件是js文件时；\nresourceFilename == test.js：当当前打开文件名是test.js时；\nisLinux、isMac、isWindows：判断当前操作系统；\neditorFocus：编辑器具有焦点时；\neditorHasSelection：编辑器中有文本被选中时；\nview == someViewId：当当前视图ID等于someViewId时；\n等等等\n\n多个条件可以通过与或非进行组合，例如：editorFocus &amp;&amp; isWindows &amp;&amp; resourceLangId == javascript。\n有关when语句的更多完整语法请参考官方文档：https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts\n2.3. altalt很好理解，表示没有按下alt键时，点击右键菜单执行的是command对应的命令，而按下了alt键后执行的是alt对应的命令。这里不做过多解释。\n2.4. group2.4.1. 组间排序控制菜单的分组和排序。不同的菜单拥有不同的默认分组。\neditor/context中有这些默认组：\n\nnavigation- 放在这个组的永远排在最前面；\n1_modification - 更改组；\n9_cutcopypaste - 编辑组\nz_commands - 最后一个默认组，其中包含用于打开命令选项板的条目。\n\n\n除了navigation是强制放在最前面之外，其它分组都是按照0-9、a-z的顺序排列的，所以如果你想在1_modification和9_cutcopypaste插入一个新的组别的话，你可以定义一个诸如6_test：\n\nexplorer/context有这些默认组：\n\nnavigation - 放在这个组的永远排在最前面；\n2_workspace - 与工作空间操作相关的命令。\n3_compare - 与差异编辑器中的文件比较相关的命令。\n4_search - 与在搜索视图中搜索相关的命令。\n5_cutcopypaste - 与剪切，复制和粘贴文件相关的命令。\n7_modification - 与修改文件相关的命令。\n\n在编辑器选项卡上下文菜单有这些默认组：\n\n1_close - 与关闭编辑器相关的命令。\n3_preview - 与固定编辑器相关的命令。\n\n在editor/title有这些默认组：\n\n1_diff - 与使用差异编辑器相关的命令。\n3_open - 与打开编辑器相关的命令。\n5_close - 与关闭编辑器相关的命令。\n\n2.4.2. 组内排序默认同一个组的顺序取决于菜单名称，如果想自定义排序的话可以再组后面通过@&lt;number&gt;的方式来自定义顺序，例如：\n1234567891011121314&quot;editor/context&quot;: [    &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;extension.sayHello&quot;,\t\t// 强制放在navigation组的第2个        &quot;group&quot;: &quot;navigation@2&quot;    &#125;,    &#123;        &quot;when&quot;: &quot;editorFocus&quot;,        &quot;command&quot;: &quot;extension.demo.getCurrentFilePath&quot;,\t\t// 强制放在navigation组的第1个        &quot;group&quot;: &quot;navigation@1&quot;    &#125;]\n\n如上，默认情况下，按照菜单名排序，sayHello在getCurrentFilePath的前面，但是通过自定义顺序，把后者放到了前面。\n快捷键快捷键设置的写法比较简单，如下所示：\n123456789101112&quot;contributes&quot;: &#123;    &quot;keybindings&quot;: [&#123;\t\t// 指定快捷键执行的操作        &quot;command&quot;: &quot;extension.sayHello&quot;,\t\t// windows下快捷键        &quot;key&quot;: &quot;ctrl+f10&quot;,\t\t// mac下快捷键        &quot;mac&quot;: &quot;cmd+f10&quot;,\t\t// 快捷键何时生效        &quot;when&quot;: &quot;editorTextFocus&quot;    &#125;]&#125;\n\n这个快捷键最终会出现在整个vscode快捷键设置界面：\n\n如果您想了解更多有关快捷键绑定的详细细节可以继续阅读官方文档：https://code.visualstudio.com/docs/getstarted/keybindings\n","slug":"vscode插件开发/3. 命令、菜单、快捷键","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"c4ba207ec39c78e8fb0cded88eb2b98c","title":"4. WebView","content":"什么是Webview大家都知道，整个VSCode编辑器就是一张大的网页，其实，我们还可以在Visual Studio Code中创建完全自定义的、可以间接和nodejs通信的特殊网页（通过一个acquireVsCodeApi特殊方法），这个网页就叫WebView。内置的Markdown的预览就是使用WebView实现的。使用Webview可以构建复杂的、支持本地文件操作的用户界面。\nVSCode插件的WebView类似于iframe的实现，但并不是真正的iframe（我猜底层应该还是基于iframe实现的，只不过上层包装了一层），通过开发者工具可以看到：\n\n1.1. demo在我们的vscode-plugin-demo中，我写了一个非常简单、没啥实际意义的Webview示例仅供参考，在任意编辑器右键可以看到打开Webview的菜单：\n\n什么时候适合使用WebView虽然Webview令人很振奋，因为基于它我们可以随意发挥不受限制，但必须注意还是要慎用，毕竟VSCode是很注重性能的，不能因为你一个插件拖累了整个IDE，一般仅在原有API和功能以及交互方式无法满足你时才需要考虑，另外，设计糟糕的Webview也很容易在VS Code中让人感觉不舒适，不能让人家一看就觉得你这是一张网页，好看的UI也很重要。\n这是官网给出的建议，在使用webview之前请考虑以下事项：\n\n这个功能真的需要放在VSCode中吗？作为单独的应用程序或网站会不会更好呢？\nwebview是实现这个功能的唯一方法吗？可以使用常规VS Code API吗？\n您的webview是否会带来足够的用户价值以证明其高资源成本？\n\n正式开始WebView之旅3.1. 创建WebView123456789101112context.subscriptions.push(vscode.commands.registerCommand(&#x27;extension.demo.openWebview&#x27;, function (uri) &#123;\t// 创建webview    const panel = vscode.window.createWebviewPanel(        &#x27;testWebview&#x27;, // viewType        &quot;WebView演示&quot;, // 视图标题        vscode.ViewColumn.One, // 显示在编辑器的哪个部位        &#123;            enableScripts: true, // 启用JS，默认禁用            retainContextWhenHidden: true, // webview被隐藏时保持状态，避免被重置        &#125;    );    panel.webview.html = `&lt;html&gt;&lt;body&gt;你好，我是Webview&lt;/body&gt;&lt;/html&gt;`\n\n几点说明：\n\n默认情况下，在Web视图中禁用JavaScript，但可以通过传入enableScripts: true选项轻松启用；\n默认情况下当webview被隐藏时资源会被销毁，通过retainContextWhenHidden: true会一直保存，但会占用较大内存开销，仅在需要时开启；\n\n3.2. 加载本地资源出于安全考虑，Webview默认无法直接访问本地资源，它在一个孤立的上下文中运行，想要加载本地图片、js、css等必须通过特殊的vscode-resource:协议，网页里面所有的静态资源都要转换成这种格式，否则无法被正常加载。\nvscode-resource:协议类似于file:协议，但它只允许访问特定的本地文件。和file:一样，vscode-resource:从磁盘加载绝对路径的资源。\n我简单封装了一个转换方法：\n12345678910/** * 获取某个扩展文件相对于webview需要的一种特殊路径格式 * 形如：vscode-resource:/Users/toonces/projects/vscode-cat-coding/media/cat.gif * @param context 上下文 * @param relativePath 扩展中某个文件相对于根目录的路径，如 images/test.jpg */getExtensionFileVscodeResource: function(context, relativePath) &#123;    const diskPath = vscode.Uri.file(path.join(context.extensionPath, relativePath));    return diskPath.with(&#123; scheme: &#x27;vscode-resource&#x27; &#125;).toString();&#125;\n\n默认情况下，vscode-resource:只能访问以下位置中的资源：\n\n扩展程序安装目录中的文件。\n用户当前活动的工作区内。\n当然，你还可以使用dataURI直接在Webview中嵌入资源，这种方式没有限制；\n\n3.3. 从文件加载HTML内容默认不支持从文件加载HTML，需要自己封装代码，我简单封装了一个供大家参考：\n123456789101112131415/** * 从某个HTML文件读取能被Webview加载的HTML内容 * @param &#123;*&#125; context 上下文 * @param &#123;*&#125; templatePath 相对于插件根目录的html文件相对路径 */function getWebViewContent(context, templatePath) &#123;    const resourcePath = path.join(context.extensionPath, templatePath);    const dirPath = path.dirname(resourcePath);    let html = fs.readFileSync(resourcePath, &#x27;utf-8&#x27;);    // vscode不支持直接加载本地资源，需要替换成其专有路径格式，这里只是简单的将样式和JS的路径替换    html = html.replace(/(&lt;link.+?href=&quot;|&lt;script.+?src=&quot;|&lt;img.+?src=&quot;)(.+?)&quot;/g, (m, $1, $2) =&gt; &#123;        return $1 + vscode.Uri.file(path.resolve(dirPath, $2)).with(&#123; scheme: &#x27;vscode-resource&#x27; &#125;).toString() + &#x27;&quot;&#x27;;    &#125;);    return html;&#125;\n\n运行这段代码之后，会自动将HTML文件中link、href、script、img的资源相对路径全部替换成正确的vscode-resource:绝对路径，例如：\n123../../lib/vue-2.5.17/vue.js变成vscode-resource:/Users/test/workspace/vscode-plugin-demo/lib/vue-2.5.17/vue.js\n\n使用方法如下：\n1panel.webview.html = getWebViewContent(context, &#x27;src/view/test-webview.html&#x27;);\n\n3.4. 消息通信重头戏来了，Webview和普通网页非常类似，不能直接调用任何VSCodeAPI，但是，它唯一特别之处就在于多了一个名叫acquireVsCodeApi的方法，执行这个方法会返回一个超级阉割版的vscode对象，这个对象里面有且仅有如下3个可以和插件通信的API：\n\n插件和Webview之间如何互相通信呢？\n插件给Webview发送消息（支持发送任意可以被JSON化的数据）：\n1panel.webview.postMessage(&#123;text: &#x27;你好，我是小茗同学！&#x27;&#125;);\n\nWebview端接收：\n1234window.addEventListener(&#x27;message&#x27;, event =&gt; &#123;    const message = event.data;\tconsole.log(&#x27;Webview接收到的消息：&#x27;, message);&#125;\n\nWebview主动发送消息给插件：\n1vscode.postMessage(&#123;text: &#x27;你好，我是Webview啊！&#x27;&#125;);\n\n插件接收：\n123panel.webview.onDidReceiveMessage(message =&gt; &#123;\tconsole.log(&#x27;插件收到的消息：&#x27;, message);&#125;, undefined, context.subscriptions);\n\n3.4.1. 简单通信封装为了双方通信方便，我把它们简单封装了一下，仅供参考，Webview端：\n12345678910111213141516171819202122232425262728293031const callbacks = &#123;&#125;; // 存放所有的回调函数/** * 调用vscode原生api * @param data 可以是类似 &#123;cmd: &#x27;xxx&#x27;, param1: &#x27;xxx&#x27;&#125;，也可以直接是 cmd 字符串 * @param cb 可选的回调函数 */function callVscode(data, cb) &#123;    if (typeof data === &#x27;string&#x27;) &#123;        data = &#123; cmd: data &#125;;    &#125;    if (cb) &#123;        // 时间戳加上5位随机数        const cbid = Date.now() + &#x27;&#x27; + Math.round(Math.random() * 100000);\t\t// 将回调函数分配一个随机cbid然后存起来，后续需要执行的时候再捞起来        callbacks[cbid] = cb;        data.cbid = cbid;    &#125;    vscode.postMessage(data);&#125;window.addEventListener(&#x27;message&#x27;, event =&gt; &#123;    const message = event.data;    switch (message.cmd) &#123;\t\t// 来自vscode的回调        case &#x27;vscodeCallback&#x27;:            console.log(message.data);            (callbacks[message.cbid] || function () &#123; &#125;)(message.data);            delete callbacks[message.cbid]; // 执行完回调删除            break;        default: break;    &#125;&#125;);\n\n插件端：\n123456789101112131415161718192021222324252627282930313233343536373839404142let global = &#123; projectPath, panel&#125;;panel.webview.onDidReceiveMessage(message =&gt; &#123;    if (messageHandler[message.cmd]) &#123;\t\t// cmd表示要执行的方法名称        messageHandler[message.cmd](global, message);    &#125; else &#123;        util.showError(`未找到名为 $&#123;message.cmd&#125; 的方法!`);    &#125;&#125;, undefined, context.subscriptions);/** * 存放所有消息回调函数，根据 message.cmd 来决定调用哪个方法， * 想调用什么方法，就在这里写一个和cmd同名的方法实现即可 */const messageHandler = &#123;    // 弹出提示    alert(global, message) &#123;        util.showInfo(message.info);    &#125;,    // 显示错误提示    error(global, message) &#123;        util.showError(message.info);    &#125;,    // 回调示例：获取工程名    getProjectName(global, message) &#123;        invokeCallback(global.panel, message, util.getProjectName(global.projectPath));    &#125;&#125;/** * 执行回调函数 * @param &#123;*&#125; panel  * @param &#123;*&#125; message  * @param &#123;*&#125; resp  */function invokeCallback(panel, message, resp) &#123;    console.log(&#x27;回调消息：&#x27;, resp);    // 错误码在400-600之间的，默认弹出错误提示    if (typeof resp == &#x27;object&#x27; &amp;&amp; resp.code &amp;&amp; resp.code &gt;= 400 &amp;&amp; resp.code &lt; 600) &#123;        util.showError(resp.message || &#x27;发生未知错误！&#x27;);    &#125;    panel.webview.postMessage(&#123;cmd: &#x27;vscodeCallback&#x27;, cbid: message.cbid, data: resp&#125;);&#125;\n\n按上述方法封装之后，例如，Webview端想要执行名为openFileInVscode命令只需要这样：\n123callVscode(&#123;cmd: &#x27;openFileInVscode&#x27;, path: `package.json`&#125;, (message) =&gt; &#123;    this.alert(message);&#125;);\n\n然后在插件端的messageHandler实现openFileInVscode方法即可，其它都不用管：\n1234567const messageHandler = &#123;\t// 省略其它方法    openFileInVscode(global, message) &#123;        util.openFileInVscode(`$&#123;global.projectPath&#125;/$&#123;message.path&#125;`);\t\tinvokeCallback(global.panel, message, &#x27;打开文件成功！&#x27;);    &#125;&#125;;\n\n以上封装的比较随便，只是给大家提供一个思路，有时间可以好好封装一下。\n3.5. 主题适配Webview可以根据VS Code的当前主题更改其外观，原理是body上面添加当前主题名称，主要有以下三种：\n\nvscode-light - 浅色主题；\nvscode-dark -深色主题；\nvscode-high-contrast - 高对比度主题;\n\n所以我们可以通过自己写样式来适配不同主题：\n123456789101112131415/* 浅色主题 */.body.vscode-light &#123;    background: white;    color: black;&#125;/* 深色主题 */body.vscode-dark &#123;    background: #252526;    color: white;&#125;/* 高对比度主题 */body.vscode-high-contrast &#123;    background: white;    color: red;&#125;\n\n深色主题效果：\n\n3.6. 生命周期webview由创建它的扩展程序所有，返回的panel对象你必须自己保存，如果你的扩展程序丢失了这个引用，那么将无法再次重新访问该webview，即使Web视图继续显示在vscode中。\n用户也可以随时关闭webview面板。当用户关闭webview面板时，webview本身将被销毁，此时不能再使用panel引用，否则将会出现异常，可以通过监听onDidDispose事件在这里面做一些销毁操作。\n可以通过panel.dispose()方法主动关闭webview。\n3.7. 状态保持当webview移动到后台又再次显示时，webview中的任何状态都将丢失。\n解决此问题的最佳方法是使你的webview无状态，通过消息传递来保存webview的状态。\n3.7.1. state在webview的js中我们可以使用vscode.getState()和vscode.setState()方法来保存和恢复JSON可序列化状态对象。当webview被隐藏时，即使webview内容本身被破坏，这些状态仍然会保存。当然了，当webview被销毁时，状态将被销毁。\n3.7.2. 序列化通过注册WebviewPanelSerializer可以实现在VScode重启后自动恢复你的webview，当然，序列化其实也是建立在getState和setState之上的。\n注册方法：vscode.window.registerWebviewPanelSerializer\n3.7.3. retainContextWhenHidden对于具有非常复杂的UI或状态且无法快速保存和恢复的webview，我们可以直接使用retainContextWhenHidden选项。设置retainContextWhenHidden: true后即使webview被隐藏到后台其状态也不会丢失。\n尽管retainContextWhenHidden很有吸引力，但它需要很高的内存开销，一般建议在实在没办法的时候才启用。getState和setState是持久化的首选方式，因为它们的性能开销要比retainContextWhenHidden低得多。\n调试注意，要调试Webview不能直接把VSCode的开发者工具打开，直接打开就会和我们最前面的截图看到的那样，你只能看到一个&lt;webview&gt;&lt;/webview&gt;标签，看不到代码，要看代码需要按下Ctrl+Shift+P然后执行打开Webview开发工具，英文版应该是Open Webview Developer Tools：\n\n审查Webview：\n\n这个时候需要特别注意错误日志出现的位置，如果是Webview的错误，一般打印在前面说的这个开发者工具，但如果是插件端的错误只会打印在整个VSCode的开发者工具里。\n","slug":"vscode插件开发/4. WebView","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"813367ef798c82e2d3b12299c59e2982","title":"5. 开发调试技巧","content":"前言在介绍完一些比较简单的内容点之后，我觉得有必要先和大家介绍一些开发中遇到的一些细节问题以及技巧，特别是后面一章节将要介绍WebView的知识，这个坑会比较多，避免大家走弯路。\n开发方式最理想的方式是准备双显示器，一个写代码，一个运行插件，实践证明这种方式开发效率会提升很多，每次修改完代码之后直接Ctrl+R重新加载即可，非常方便。\n日志查看就我目前遇到的情况来看，vscode日志主要有这5种：\n3.1. 旧窗口的调试控制台扩展里的console.log()日志一般输出在这里，但是有很大的限制，结构稍微深一点的对象在这里了就显示不了：\n\n\n\n\n\n\n\n\n\nUnable to log remote console arguments Output omitted for an object that cannot be inspected (Error: [sxei.vscode-plugin-demo]: Proposed API is only available when running out of dev or with the following command line switch: –enable-proposed-api sxei.vscode-plugin-demo)\n这里只能看成是新窗口开发者控制台日志的一种快捷显示，以下是旧窗口调试控制台显示的内容：\n\n而对应的内容在新窗口的开发者控制台显示如下：\n\n可以看到，结构较深的对象即使在控制台也无法显示，目前发现的唯一比较好的方法就是在输出的地方打一个断点，然后运行的时候会自动卡在这里，鼠标悬停就可以查看对象的内容。\n\n3.2. 新窗口的调试控制台一般没什么扩展相关日志会输出在这里。\n3.3. 旧窗口的开发者控制台快捷键Ctrl+Alt+I，这里一般显示vscode本身一些日志，和扩展相关的不会显示在这里，所以这个也不用太多关心。\n3.4. 新窗口的开发者控制台快捷键也是Ctrl+Alt+I，不记得的可以从帮助 -&gt; 切换开发人员工具找到。这个控制台很重要，有时候如果发现你的代码莫名其妙没生效，很有可能是报错了，这种报错是不会显示在旧窗口调试控制台的，如果你不知道到这里来查看日志，那么你只能一脸懵逼的到处乱试了，调试控制台只打印常规日志，语法错误并不会显示在这里。\n例如，我在跳转定义实现前人为制造一个错误：\n12345function provideDefinition(document, position, token) &#123;    console.log(aaf);    const fileName    = document.fileName;\t// 省略其它代码&#125;\n\n运行后就会发现点击跳转不生效，但是也没有什么报错提示，此时只能打开控制台查看才能发现问题：\n\n3.5. WebView控制台WebView我们会在下一章节介绍，这里先提一下。Webview的控制台比较特殊，需要特殊的命令才能打开，按下Ctrl+Shift+P然后执行打开Webview开发工具，英文版应该是Open Webview Developer Tools：\n\n开发时我们把它当成一个普通的网页来看就好了。\n调试vscode插件的调试非常简单方便，只需要在需要调试的地方打个断点，然后按F5执行即可：\n\n几个调试快捷键：\n\nF5运行\nCtrl+F2停止运行\nF6下一步跳过（类似于Chrome的F10）\nF5下一步跳入\nF8跳过\n\n如何快速找到我想找的内容刚开始只能先大概对整个vscode的api有一个大概了解，了解了之后就大概清楚一般什么功能会怎么实现，该去什么地方找，所有的vscode的api都可以在vscode.d.ts文件里面找到：\n\n不得不佩服，正规大型项目的注释写的真的不是一般的详细，官网的API文档肯定也是基于这个自动生成的，反正把这个ts文件吃透了，基本上你想实现什么功能要怎么实现都了如指掌了。\n查看插件存放目录插件安装后根据操作系统不同会放在如下目录：\n\nWindows系统：%USERPROFILE%\\.vscode\\extensions\nMac&#x2F;Linux：~/.vscode/extensions\n\n想要学习查看其它插件的代码可以找到这个目录：\n\n一些个人经验分享7.1. 调试控制台日志不可靠vscode有一个很坑爹的地方，这里特别要注意，当require一个function进来并打印输出时，虽然打印在控制台显示为null，但其实是有值的，不知道的人很容易被误导，直接就是被这个现象骗了很久，切记切记！\ntest-require-function.js：\n12345function testRequireFunction(a, b) &#123;    console.log(&#x27;进入testRequireFunction方法&#x27;);    console.log(a, b);&#125;module.exports = testRequireFunction;\n\nextension.js：\n12345exports.activate = function(context) &#123;    const testFn = require(&#x27;./test-require-function&#x27;);    console.log(testFn); // vscode的日志输出不可靠，这里竟然会打印null？！    testFn(1, 2); // 1, 2&#125;;\n\n输出结果：\n123null进入testRequireFunction方法1 2\n\n7.2. 代码为什么没生效代码没生效一般从这几个地方去查找：\n\nactivationEvents里面添加了吗？开发的时候如果老是忘记可以直接设置成*；\n代码是不是报错了？如前文所说，很多错误是不会暴露出来的，需要手动打开控制台查看；\n代码是不是忘记引入了？有时候拆分多个文件之后可能忘了引入；\n逻辑是不是写错了？最好的办法就是debug，这是找问题最快的方法；\n版本冲突\n\n这里重点说一下最后面的版本冲突，这个甚至可以说是vscode本身的一些bug，经常发现代码莫名其妙地没生效，怎么调试都不对，后来发现运行的根本就不是我们正在开发的那个版本，特别是当你的插件已经发了一版到应用市场并安装后，本地再按F5运行，理论上说debug运行的会覆盖已安装的，但有时候还是会出现异常情况，所以为了以防万一，当出现这种情况时可以先把已经安装的给卸载。\n还有一个问题就是，有时候明明安装了版本更加新的那个，结果运行的却是旧的，打开扩展目录会发现很多并存的同名不同版本插件，或者可能先是通过vsix方式安装了一个版本，然后又从应用市场安装一个，总之解决这类问题最好的方法就是：先卸载再安装，实在不行手动去插件目录删除之！\n7.3. 打开文件打开文件是vscode.window.showTextDocument而不是vscode.workspace.openTextDocument，这个根据字面意思很容易搞错，原来老外也有命名不准确的时候啊，哈哈。\n\nvscode.workspace.openTextDocument仅仅是加载文档并返回一个TextDocument对象，但是并不在vscode中打开；\nvscode.window.showTextDocument则是在vscode中打开一个文档；\n\n其实：\n12345vscode.workspace.openTextDocument(&#x27;someFilePath&#x27;).then(document =&gt; &#123;\tvscode.window.showTextDocument(document, editor =&gt; &#123;\t\t// 可以操作文档的editor对象\t&#125;);&#125;)\n\n等价于：\n123vscode.window.showTextDocument(vscode.Uri.file(&#x27;someFilePath&#x27;), editor =&gt; &#123;\t// 可以操作文档的editor对象&#125;);\n\n7.4. 工程根目录的获取被这个问题踩过很多次坑，所有重点介绍一下。\n有的人的vscode工作空间是这样的，每一个工程一个个地单独拖入：\n\n也有的人是直接用打开文件夹的方式把存放代码的父文件夹给打开：\n\n但是如果此时你点击将工作区另存为保存了工作区之后就变成这样了（请注意图标的变化）：\n\n所以，即便拿到了某个文件的完整路径也不好获取这个文件的工程路径，因为不知道工作区的这个文件夹名字是你的工程名还是存放工程的父文件夹的名字。\n已知：\n\nvscode以前有一个vscode.workspace.rootPath，由于后来vscode支持multipleRoot模式，所以这个字段已经过时作废了。\nvscode.workspace.workspaceFolders可以获取当前工作区所有根文件夹数组；\n\n之前我写了一个简单粗暴的获取工程目录方式：\n123456789101112131415161718192021222324252627282930313233343536373839/** * 获取当前所在工程根目录，有3种使用方法：&lt;br&gt; * getProjectPath(uri) uri 表示工程内某个文件的路径&lt;br&gt; * getProjectPath(document) document 表示当前被打开的文件document对象&lt;br&gt; * getProjectPath() 会自动从 activeTextEditor 拿document对象，如果没有拿到则报错 * @param &#123;*&#125; document  */getProjectPath(document) &#123;    if (!document) &#123;        document = vscode.window.activeTextEditor ? vscode.window.activeTextEditor.document : null;    &#125;    if (!document) &#123;        this.showError(&#x27;当前激活的编辑器不是文件或者没有文件被打开！&#x27;);        return &#x27;&#x27;;    &#125;    const currentFile = (document.uri ? document.uri : document).fsPath;    let projectPath = null;    let workspaceFolders = vscode.workspace.workspaceFolders.map(item =&gt; item.uri.path);    // 由于存在Multi-root工作区，暂时没有特别好的判断方法，先这样粗暴判断    // 如果发现只有一个根文件夹，读取其子文件夹作为 workspaceFolders    if (workspaceFolders.length == 1 &amp;&amp; workspaceFolders[0] === vscode.workspace.rootPath) &#123;        const rootPath = workspaceFolders[0];        var files = fs.readdirSync(rootPath);        workspaceFolders = files.filter(name =&gt; !/^\\./g.test(name)).map(name =&gt; path.resolve(rootPath, name));        // vscode.workspace.rootPath会不准确，且已过时        // return vscode.workspace.rootPath + &#x27;/&#x27; + this._getProjectName(vscode, document);    &#125;    workspaceFolders.forEach(folder =&gt; &#123;        if (currentFile.indexOf(folder) === 0) &#123;            projectPath = folder;        &#125;    &#125;)    if (!projectPath) &#123;        this.showError(&#x27;获取工程根路径异常！&#x27;);        return &#x27;&#x27;;    &#125;    return projectPath;&#125;,\n\n这种方式生效的前提是，如果是按照第一种方式存放工作空间的，工程的数目必须大于等于2，但是这种判断方式不用说肯定会不准确。\n后来换成了另外一种方式，考虑到工作接触到的项目无论是node端还是前端都会有package.json文件在根目录，所以就根据哪个文件夹有这个文件来判断，也只能是这样了。\n","slug":"vscode插件开发/5. 开发调试技巧","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"4363a1c8f18b34e52ca1d5e6f6bd7690","title":"6. 打包、发布、升级","content":"发布方式插件开发完了，如何发布出去分享给他人呢？主要有3种方法：\n\n方法一：直接把文件夹发给别人，让别人找到vscode的插件存放目录并放进去，然后重启vscode，一般不推荐；\n方法二：打包成vsix插件，然后发送给别人安装，如果你的插件涉及机密不方便发布到应用市场，可以尝试采用这种方式；\n方法三：注册开发者账号，发布到官网应用市场，这个发布和npm一样是不需要审核的。\n\n本地打包无论是本地打包还是发布到应用市场都需要借助vsce这个工具。\n安装：\n1npm i vsce -g\n\n打包成vsix文件：\n1vsce package\n\n打包的时候如果没有设置repository会有提示，所以最好设置一下。\n\n生成好的vsix文件不能直接拖入安装，只能从扩展的右上角选择Install from VSIX安装：\n\n发布应用市场Visual Studio Code的应用市场基于微软自己的Azure DevOps，插件的身份验证、托管和管理都是在这里。\n\n要发布到应用市场首先得有应用市场的publisher账号；\n而要有发布账号首先得有Azure DevOps组织；\n而创建组织之前，首先得创建Azure账号；\n创建Azure账号首先得有Microsoft账号；\n\n是不是有点晕，梳理一下：\n\n一个Microsoft账号可以创建多个Azure组织；\n一个组织可以创建多个publisher账号；\n同时一个组织可以创建多个PAT（Personal Access Token，个人访问令牌）；\n\n3.1. 注册账号首先访问 https://login.live.com/ 登录你的Microsoft账号，没有的先注册一个：\n\n然后访问： https://aka.ms/SignupAzureDevOps ，如果你从来没有使用过Azure，那么会看到如下提示：\n\n点击继续，默认会创建一个以邮箱前缀为名的组织。\n3.2. 创建令牌默认进入组织的主页后，点击右上角的Security：\n\n点击创建新的个人访问令牌，这里特别要注意Organization要选择all accessible organizations，Scopes要选择Full access，否则后面发布会失败。\n\n创建令牌成功后你需要本地记下来，因为网站是不会帮你保存的。\n3.3. 创建发布账号获得个人访问令牌后，使用vsce以下命令创建新的发布者：\n1vsce create-publisher your-publisher-name\n\nyour-publisher-name必须是字母数字下划线，这是全网唯一的账号，然后会依次要求输入昵称、邮箱、令牌：\n\n创建成功后会默认登录这个账号，接下来你可以直接发布了，当然，如果你是在其它地方创建的，可以试用vsce login your-publisher-name来登录。\n除了用命令之外，你还可以使用网页版创建发布账号：https://marketplace.visualstudio.com/manage\n3.4. 发布发布很简单：\n1vsce publish\n\n\n发布成功后大概需要过几分钟才能在应用市场搜到。过几分钟就可以访问网页版的插件主页：https://marketplace.visualstudio.com/items?itemName=sxei.vscode-plugin-demo\n\nvscode里面也能搜到了：\n\n3.4.1. 发布注意事项\nREADME.md文件默认会显示在插件主页；\nREADME.md中的资源必须全部是HTTPS的，如果是HTTP会发布失败；\nCHANGELOG.md会显示在变更选项卡；\n如果代码是放在git仓库并且设置了repository字段，发布前必须先提交git，否则会提示Git working directory not clean；\n\n另外，如前面所说，如果Organization没有选择all accessible organizations，或者Scopes没有选择Full access，发布的时候可能会报如下错误：\n123Error: Failed Request: Unauthorized(401) - https://marketplace.visualstudio.com/_apis/galleryBe sure to use a Personal Access Token which has access to **all accessible accounts**.See https://code.visualstudio.com/docs/tools/vscecli#_common-questions for more information.\n\n3.4.2. 增量发布版本号：major.minor.patch\n如果想让发布之后版本号的patch自增，例如：1.0.2 -&gt; 1.0.3，可以这样：\n1vsce publish patch\n\n执行这个命令后会自动修改package.json里面的版本号。同理，vsce publish minor也是可以的。\n3.5. 取消发布1vsce unpublish (publisher name).(extension name)\n\n3.6. 更新如果修改了插件代码想要重新发布，只需要修改版本号然后重新执行vsce publish即可。\n插件升级4.1. 发布到了应用市场如果发布到了应用市场，那么一般来说会自动检测有没有新版本，有的话会自动无感知升级，但具体什么时候会去检测我还没有研究过，已经确定的是在扩展面板搜索插件名字会自动检测，重启vscode也会检测。\n4.2. 如果是本地打包如果是打包成vsix，那么只能自己实现升级检测功能呢，通过对比服务器上某个文件的版本号，具体我就不细讲了。\n","slug":"vscode插件开发/6. 打包、发布、升级","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"7485ac3dd1b5518a73477d38ad77532d","title":"7. 常用API总结","content":"编辑器相关1.1. 修改当前激活编辑器内容替换当前编辑器全部内容：\n123456vscode.window.activeTextEditor.edit(editBuilder =&gt; &#123;    // 从开始到结束，全量替换    const end = new vscode.Position(vscode.window.activeTextEditor.document.lineCount + 1, 0);\tconst text = &#x27;新替换的内容&#x27;;    editBuilder.replace(new vscode.Range(new vscode.Position(0, 0), end), text);&#125;);\n\n1.2. 打开文件并选中某段文字12345678910const path = &#x27;/Users/somefile.txt&#x27;;const options = &#123;\t// 选中第3行第9列到第3行第17列\tselection: new vscode.Range(new vscode.Position(2, 8), new vscode.Position(2, 16));\t// 是否预览，默认true，预览的意思是下次再打开文件是否会替换当前文件\tpreview: false,\t// 显示在第二个编辑器\tviewColumn: vscode.ViewColumn.Two&#125;;vscode.window.showTextDocument(vscode.Uri.file(path), options);\n\npreview为true相当于我们在文件管理器单击文件，此时标题是斜体（如下图），为false时则相当于双击。\n\n通知和状态栏2.1. 提示12vscode.window.showInformationMessage(&#x27;我是info信息！&#x27;);vscode.window.showErrorMessage(&#x27;我是错误信息！&#x27;);\n\n自定义按钮带回调的提示：\n1234567vscode.window.showInformationMessage(&#x27;是否要打开小茗同学的博客？&#x27;, &#x27;是&#x27;, &#x27;否&#x27;, &#x27;不再提示&#x27;).then(result =&gt; &#123;\tif (result === &#x27;是&#x27;) &#123;\t\texec(`open &#x27;https://haoji.me&#x27;`);\t&#125; else if (result === &#x27;不再提示&#x27;) &#123;\t\t// 其它操作\t&#125;&#125;);\n\n2.2. 修改状态栏1vscode.window.setStatusBarMessage(&#x27;你好，前端艺术家！&#x27;);\n\n\nsetStatusBarMessage只是vscode.window.createStatusBarItem的一种快捷调用方式，如需更多自定义设置可以使用这个方法。\n参考https://code.visualstudio.com/docs/extensionAPI/vscode-api\n","slug":"vscode插件开发/7. 常用API总结","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vscode插件开发","author_index":"MessageWall"},{"id":"aaae541336ce9c9a068b009d52c1b8e0","title":"vue-property-decorator使用手册","content":"一，安装1npm i -s vue-property-decorator vue-class-component\n\n二，用法1，@Component(options:ComponentOptions &#x3D; {})\n@Component 装饰器可以接收一个对象作为参数，可以在对象中声明 components ，filters，directives等未提供装饰器的选项，也可以声明computed，watch等\n123456789101112131415import &#123; Vue, Component &#125; from &#x27;vue-property-decorator&#x27;@Component(&#123;  filters: &#123;    toFixed: (num: number, fix: number = 2) =&gt; &#123;      return num.toFixed(fix)    &#125;  &#125;&#125;)export default class MyComponent extends Vue &#123;  public list: number[] = [0, 1, 2, 3, 4]  get evenList() &#123;    return this.list.filter((item: number) =&gt; item % 2 === 0)  &#125;&#125;\n\n2，@Prop(options: (PropOptions | Constructor[] | Constructor) &#x3D; {})\n@Prop装饰器接收一个参数，这个参数可以有三种写法：\n\nConstructor，例如String，Number，Boolean等，指定 prop 的类型；\nConstructor[]，指定 prop 的可选类型；\nPropOptions，可以使用以下选项：type，default，required，validator。\n\n1234567891011import &#123; Vue, Component, Prop &#125; from &#x27;vue-property-decorator&#x27;export default class MyComponent extends Vue &#123;  @Prop(String) public propA: string | undefined  @Prop([String, Number]) public propB!: string | number  @Prop(&#123;    type: String,    default: &#x27;abc&#x27;  &#125;)  public propC!: string&#125;\n\n等同于下面的js写法\n1234567891011121314export default &#123;  props: &#123;    propA: &#123;      type: String    &#125;,    propB: &#123;      type: [String, Number]    &#125;,    propC: &#123;      type: String,      defalut: &#x27;abc&#x27;    &#125;  &#125;&#125;\n\n注意：\n\n属性的ts类型后面需要加上undefined类型；或者在属性名后面加上!，表示非null 和 非undefined的断言，否则编译器会给出错误提示；\n指定默认值必须使用上面例子中的写法，如果直接在属性名后面赋值，会重写这个属性，并且会报错。\n\n3，@PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) &#x3D; {})\n@PropSync装饰器与@prop用法类似，二者的区别在于：\n\n@PropSync 装饰器接收两个参数：propName: string 表示父组件传递过来的属性名；options: Constructor | Constructor[] | PropOptions 与@Prop的第一个参数一致；\n@PropSync 会生成一个新的计算属性。\n\n123456import &#123; Vue, Component, PropSync &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class MyComponent extends Vue &#123;  @PropSync(&#x27;propA&#x27;, &#123; type: String, default: &#x27;abc&#x27; &#125;) public syncedPropA!: string&#125;\n\n等同于下面的js写法\n123456789101112131415161718export default &#123;  props: &#123;    propA: &#123;      type: String,      default: &#x27;abc&#x27;    &#125;  &#125;,  computed: &#123;    syncedPropA: &#123;      get() &#123;        return this.propA      &#125;,      set(value) &#123;        this.$emit(&#x27;update:propA&#x27;, value)      &#125;    &#125;  &#125;&#125;\n\n注意：@PropSync需要配合父组件的.sync修饰符使用\n4，@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) &#x3D; {})\n@Model装饰器允许我们在一个组件上自定义v-model，接收两个参数：\n\nevent: string 事件名。\noptions: Constructor | Constructor[] | PropOptions 与@Prop的第一个参数一致。\n\n123456import &#123; Vue, Component, Model &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class MyInput extends Vue &#123;  @Model(&#x27;change&#x27;, &#123; type: String, default: &#x27;123&#x27; &#125;) public value!: string&#125;\n\n等同于下面的js写法\n123456789101112export default &#123;  model: &#123;    prop: &#x27;value&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    value: &#123;      type: String,      default: &#x27;123&#x27;    &#125;  &#125;&#125;\n\n上面例子中指定的是change事件，所以我们还需要在template中加上相应的事件：\n1234567&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;value&quot;    @change=&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n对自定义v-model不太理解的同学，可以查看自定义事件\n5，@Watch(path: string, options: WatchOptions &#x3D; {})\n@Watch 装饰器接收两个参数：\n\npath: string 被侦听的属性名；\noptions可以包含两个属性 ：\nimmediate?:boolean 侦听开始之后是否立即调用该回调函数；deep?:boolean 被侦听的对象的属性被改变时，是否调用该回调函数；\n\n\n侦听开始，发生在beforeCreate勾子之后，created勾子之前\n12345678910111213import &#123; Vue, Component, Watch &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class MyInput extends Vue &#123;  @Watch(&#x27;msg&#x27;)  public onMsgChanged(newValue: string, oldValue: string) &#123;&#125;  @Watch(&#x27;arr&#x27;, &#123; immediate: true, deep: true &#125;)  public onArrChanged1(newValue: number[], oldValue: number[]) &#123;&#125;  @Watch(&#x27;arr&#x27;)  public onArrChanged2(newValue: number[], oldValue: number[]) &#123;&#125;&#125;\n\n等同于下面的js写法\n12345678910111213141516171819202122232425262728export default &#123;  watch: &#123;    msg: [      &#123;        handler: &#x27;onMsgChanged&#x27;,        immediate: false,        deep: false      &#125;    ],    arr: [      &#123;        handler: &#x27;onArrChanged1&#x27;,        immediate: true,        deep: true      &#125;,      &#123;        handler: &#x27;onArrChanged2&#x27;,        immediate: false,        deep: false      &#125;    ]  &#125;,  methods: &#123;    onMsgVhanged(newValue, oldValue) &#123;&#125;,    onArrChange1(newValue, oldValue) &#123;&#125;,    onArrChange2(newValue, oldValue) &#123;&#125;  &#125;&#125;\n\n6，@Emit(event?: string)\n\n@Emit 装饰器接收一个可选参数，该参数是$Emit的第一个参数，充当事件名。如果没有提供这个参数，$Emit会将回调函数名的camelCase转为kebab-case，并将其作为事件名；\n@Emit会将回调函数的返回值作为第二个参数，如果返回值是一个Promise对象，$emit会在Promise对象被标记为resolved之后触发；\n@Emit的回调函数的参数，会放在其返回值之后，一起被$emit当做参数使用。\n\n123456789101112131415161718192021222324252627282930import &#123; Vue, Component, Emit &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class MyComponent extends Vue &#123;  count = 0  @Emit()  public addToCount(n: number) &#123;    this.count += n  &#125;  @Emit(&#x27;reset&#x27;)  public resetCount() &#123;    this.count = 0  &#125;  @Emit()  public returnValue() &#123;    return 10  &#125;  @Emit()  public onInputChange(e) &#123;    return e.target.value  &#125;  @Emit()  public promise() &#123;    return new Promise(resolve =&gt; &#123;      setTimeout(() =&gt; &#123;        resolve(20)      &#125;, 0)    &#125;)  &#125;&#125;\n\n等同于下面的js写法\n123456789101112131415161718192021222324252627282930313233export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  methods: &#123;    addToCount(n) &#123;      this.count += n      this.$emit(&#x27;add-to-count&#x27;, n)    &#125;,    resetCount() &#123;      this.count = 0      this.$emit(&#x27;reset&#x27;)    &#125;,    returnValue() &#123;      this.$emit(&#x27;return-value&#x27;, 10)    &#125;,    onInputChange(e) &#123;      this.$emit(&#x27;on-input-change&#x27;, e.target.value, e)    &#125;,    promise() &#123;      const promise = new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; &#123;          resolve(20)        &#125;, 0)      &#125;)      promise.then(value =&gt; &#123;        this.$emit(&#x27;promise&#x27;, value)      &#125;)    &#125;  &#125;&#125;\n\n7，@Ref(refKey?: string)\n@Ref 装饰器接收一个可选参数，用来指向元素或子组件的引用信息。如果没有提供这个参数，会使用装饰器后面的属性名充当参数\n1234567891011121314151617import &#123; Vue, Component, Ref &#125; from &#x27;vue-property-decorator&#x27;import &#123; Form &#125; from &#x27;element-ui&#x27;@Componentexport default class MyComponent extends Vue &#123;  @Ref() readonly loginForm!: Form  @Ref(&#x27;changePasswordForm&#x27;) readonly passwordForm!: Form  public handleLogin() &#123;    this.loginForm.validate(valide =&gt; &#123;      if (valide) &#123;        // login...      &#125; else &#123;        // error tips      &#125;    &#125;)  &#125;&#125;\n\n等同于下面的js写法\n12345678910111213141516export default &#123;  computed: &#123;    loginForm: &#123;      cache: false,      get() &#123;        return this.$refs.loginForm      &#125;    &#125;,    passwordForm: &#123;      cache: false,      get() &#123;        return this.$refs.changePasswordForm      &#125;    &#125;  &#125;&#125;\n\n@Provide&#x2F;@Inject 和 @ProvideReactive&#x2F;@InhectReactive\n由于平时基本不用到provide&#x2F;inject选项，暂时先放着，以后有时间再研究\n参考：https://github.com/kaorun343/...\n","slug":"vue/vue-property-decorator使用手册","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"6536456cce33052f0b5d72fc51f8140f","title":"vue2.x升级到vue3.0","content":"开始升级直接使用脚手架，如果本地没有安装的可以执行脚手架安装命令：\n1npm install -g @vue/cli\n\n如果本地安装过的，可以尝试更新一下：\n1npm update -g @vue/cli\n\n测试 vue-cli 版本：\n12vue -V@vue/cli 4.5.4\n\n将vue-cli更新到最新版本后，升级到vue-next (vue3.0)\n1vue add vue-next\n\n执行完上述命令后，会自动安装 vue-cli-plugin-vue-next 插件，它会将项目升级为 vue3.0 的依赖环境，包括 vue-router 和 vuex 都会升级为 4.x 的版本。\nantd-vue升级\n1npm i --save ant-design-vue@next\n\n","slug":"vue/vue2.x升级到vue3.0","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"08218342bd24599d0dae687c1993c61d","title":"vue兼容ie","content":"vue兼容ie浏览器babel-polyfillbabel-polyfill的作用是是让ie浏览器支持es6语法\n安装\n1npm install --save-dev babel-polyfill\n\n引用方式有三种：\n\nrequire(&quot;babel-polyfill&quot;);\n\nimport &quot;babel-polyfill&quot;;\n\nwebpack.config.js\n\n\n123module.exports = &#123;   entry: [&quot;babel-polyfill&quot;, &quot;./app/js&quot;]&#125;;\n\n注：第三种方法适用于使用webpack构建的同学，加入到webpack配置文件(webpack.config.js)entry项中\naxios在安卓低版本兼容性处理在较低版本的安卓手机中发现发现封装的axios请求无效，主要原因还是低版本的安卓手机无法使用promise\n注意：安卓4.3以下的手机不支持axios的使用，无法使用promise，加上 polyfill就可以了。\n解决方案： （1）、项目中安装 es6-promise\n1npm install es6-promise -s\n\n（2）、引入 es6-promise\n1import promise from &#x27;es6-promise&#x27;\n\n（3）、注册 es6-promise (一定要在axios之前注册)\n1234567// 注意： es6-promise   一定要在 axios 之前注册promise.polyfill()或者require(&#x27;es6-promise&#x27;).polyfill();\n\n","slug":"vue/vue兼容ie","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"01ed74d49392915bb74b2485eb4564a7","title":"vue支持tsx","content":"使用vuecl3创建的项目，集成tsx\n1vue add tsx-support\n\n导入和配置安装 vue-tsx-support 包\n1npm install vue-tsx-support --save\n\n导入TS声明，有两种方式\n编辑tsconfig.js\n12345678910&quot;include&quot;: [    &quot;node_modules/vue-tsx-support/enable-check.d.ts&quot;,     &quot;src/**/*.ts&quot;,    &quot;src/**/*.tsx&quot;,    &quot;src/**/*.vue&quot;,    &quot;tests/**/*.ts&quot;,    &quot;tests/**/*.tsx&quot;  ],   // 注意：将exclude内的 &quot;node_modules&quot; 删掉，不然永远也无法被引用到了\n\n或者在main.js中 import\n1import &quot;vue-tsx-support/enable-check&quot;;\n\n创建视图组件来创建个按钮组件：\n\n12345678910111213141516171819202122232425262728293031323334 1 import &#123; Component, Prop &#125; from &quot;vue-property-decorator&quot;; 2 import * as tsx from &quot;vue-tsx-support&quot;; 3  4 export enum ButtonType &#123; 5   default = &quot;default&quot;, 6   primary = &quot;primary&quot; 7 &#125; 8  9 export enum ButtonSize &#123;10   large = &quot;large&quot;,11   small = &quot;small&quot;12 &#125;13 export interface IButtonProps &#123;14   type?: ButtonType;15   size?: ButtonSize;16   num: number;17 &#125;18 19 @Component20 export default class Button extends tsx.Component&lt;IButtonProps&gt; &#123;21   @Prop() public type!: ButtonType;22   @Prop() public size!: ButtonSize;23   @Prop(&#123; default: 0 &#125;) public num!: number;24 25   protected render() &#123;26     return (27       &lt;div&gt;28         &lt;p&gt;id:&#123;this.num&#125;&lt;/p&gt;29         &#123;this.type &amp;&amp; &lt;p&gt;type:&#123;this.type&#125;&lt;/p&gt;&#125;30         &#123;this.size &amp;&amp; &lt;p&gt;size:&#123;this.size&#125;&lt;/p&gt;&#125;31       &lt;/div&gt;32     );33   &#125;34 &#125;\n\n\n再创建Container 用TSX引用组件Button：\n\n12345678910111213141516171819202122232425import &#123; Component, Prop &#125; from &quot;vue-property-decorator&quot;;import &#123; Component as tsc &#125; from &quot;vue-tsx-support&quot;;import Button, &#123; ButtonType, ButtonSize &#125; from &quot;./button&quot;;interface IContainerProps &#123;  name?: string;&#125;@Componentexport default class Container extends tsc&lt;IContainerProps&gt; &#123;  @Prop() public name!: string;  protected render() &#123;    return (      &lt;div&gt;        &lt;p&gt;container Name:&#123;this.name&#125;&lt;/p&gt;        &lt;p&gt;&#123;this.$slots.default&#125;&lt;/p&gt;        &lt;p&gt;          button:          &lt;Button num=&#123;9&#125; type=&#123;ButtonType.primary&#125; size=&#123;ButtonSize.large&#125; /&gt;        &lt;/p&gt;      &lt;/div&gt;    );  &#125;&#125;","slug":"vue/vue支持tsx","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"c1c47e74b74b6468b32ad71db9f1ca1a","title":"vue的model选项","content":"允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。\n示例\n12345678910111213141516Vue.component(&#x27;my-checkbox&#x27;, &#123;  model: &#123;    prop: &#x27;checked&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    // this allows using the `value` prop for a different purpose    value: String,    // use `checked` as the prop which take the place of `value`    checked: &#123;      type: Number,      default: 0    &#125;  &#125;,  // ...&#125;)\n\n1&lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;\n\n相当于：\n12345&lt;my-checkbox  :checked=&quot;foo&quot;  @change=&quot;val =&gt; &#123; foo = val &#125;&quot;  value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;","slug":"vue/vue的model选项","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"7719887b14906dac83ce9a6697915a1c","title":"1.双向绑定实现原理","content":"vue3.0通过Proxy实现数据的双向绑定\n\n\n\n\n\n\n\n\nproxy是什么？\nProxy是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\n使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。基本\n基本用法\n1let p = new Proxy(target, handler);\n\n举例\n12345678910111213141516let obj = &#123;&#125;;let handler = &#123;    get(target, property) &#123;        console.log(&quot;读取到&quot;, target, property);        return property in target ? target[property] : 88;    &#125;,    set(target, property, value) &#123;        console.log(`$&#123;property&#125; 被设置为 $&#123;value&#125;`);        target[property] = value;        return true;  // 不加上这句代码会报错，必须要返回是否复制成功    &#125;&#125;let p = new\tProxy(obj, handler);p.name = &#x27;小王&#x27;;console.log(p.name);console.log(p.age);\n\n\n写一个Proxy实现输入框双向绑定显示的例子\n12&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;&lt;div&gt;您输入的是：&lt;span id=&quot;title&quot;&gt;&lt;/span&gt;&lt;/div&gt;\n\n1234567891011121314151617181920const obj = &#123;&#125;;const input = document.getElementById(&quot;input&quot;);const title = document.getElementById(&quot;title&quot;);const newObj = new Proxy(obj, &#123;    get(target, key, receiver) &#123;        console.log(&quot;getting&quot;, key);        return Reflect.get(target, key, receiver);    &#125;,    set(target, key, value, receiver) &#123;        console.log(target, key, value, receiver);        if(key == &#x27;text&#x27;) &#123;            input.value = value            title.innerHTML = value;        &#125;        return Reflect.set(target, key, value, receiver);    &#125;&#125;)input.addEventListener(&quot;keyup&quot;, e =&gt; &#123;    newObj.text = e.target.value;&#125;)\n\n\n\n参考文档  https://juejin.im/post/5bf3e632e51d452baa5f7375\n","slug":"vue-next/1.双向绑定实现原理","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"b57579c1d8477aa7ac0530064b6472c7","title":"3.Composition API","content":"Composition API 上手初体验\n\n\n\n\n\n\n\n\nVue3.0最大的变化就是 Vue Composition API， Composition API是一种全新的逻辑重用和代码组织方法。\n在Vue2.X中使用的是“options”API 构建组件，为了将逻辑添加到Vue组件中，我们填充（options）属性，如data、methods、computed等。这种方法最大的缺点是，它本身不是一个工作的JavaScript代码。您需要确切地知道模板中可以访问哪些属性以及this关键字的行为。在底层，Vue编译器需要将此属性转换为工作代码。正因为如此，我们无法从自动建议或类型检查中获益。\nComposition API希望将通过当前组件属性、可用的机制公开为JavaScript函数来解决这个问题。Vue核心团队将组件Composition API描述为“一套附加的、基于函数的api，允许灵活地组合组件逻辑”。使用Composition API编写的代码更易读，并且场景不复杂，这使得阅读和学习变得更容易。\n下面看一个简单的组件示例\n123456789101112131415161718192021222324252627&lt;template&gt;\t&lt;div&gt;\t\t&lt;button @click=&quot;add&quot;&gt;\t\t\tCount is &#123;&#123;count&#125;&#125;, double is &#123;&#123;double&#125;&#125;, click to add\t\t&lt;/button&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27;;export default &#123;\tsetup() &#123;\t\tconst count = ref(0);\t\tconst double = computed(() =&gt; count.value * 2)\t\tfunction add() &#123;\t\t\tcount.value ++;\t\t&#125;\t\tonMounted(() =&gt; &#123;\t\t\tconsole.log(&quot;onMounted&quot;);\t\t&#125;)\t\treturn &#123;\t\t\tcount,\t\t\tdouble,\t\t\tadd\t\t&#125;\t&#125;&#125;&lt;/script&gt;\n\n","slug":"vue-next/3.Composition API","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"33aa72f8b64b99fc96be527b5ecc3c03","title":"2.vue3.0项目初始化","content":"Vue3.0项目初始化第一步，安装vue-cli\n1npm install -g @vue/cli\n\n安装成功后可以查看安装版本\n12$ vue -V@vue/cli 4.3.1\n\n第二步，初始化 vue 项目：\n1vue create vue-next-test\n\n第三步，升级Vue3.0项目\n12cd vue-next-testvue add vue-next\n\n完成上述操作后，项目将会升级到Vue3.0，但该方法还不支持typescript。\n","slug":"vue-next/2.vue3.0项目初始化","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"22377e2893b037c03e67fd62bbabaf47","title":"4. v-model","content":"v-modelvue3支持定义多个v-model， 格式为v-model:title&#x3D;”data”，子组件\n123456789101112131415export default &#123;  model: &#123;    prop: &#x27;title&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    // 这将允许 `value` 属性用于其他用途    value: String,    // 使用 `title` 代替 `value` 作为 model 的 prop    title: &#123;      type: String,      default: &#x27;Default title&#x27;    &#125;  &#125;&#125;\n\n如果只写v-model&#x3D;”data”\n子组件的props定义一个modelValue属性可以接收值，并且可以通过 this.$emit(&#39;update:modelValue&#39;, &#39;8888&#39;); 改这个值\nv-model修饰符.trim\n.number\n.lazy\n","slug":"vue-next/4. v-model","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"f1409d4d45a40174565c85ea9b0932d6","title":"Vue查缺补漏","content":"自定义指令","slug":"vue-next/Vue查缺补漏","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"b73630ac73571fe9078d5077fe4b9a72","title":"vue3.0学习笔记","content":"一个新的全局 API：createApp调用 createApp 返回一个应用实例，这是 Vue 3 中的新概念：\n123import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)\n\n应用实例暴露当前全局 API 的子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上，以下是当前全局 API 及其相应实例 API 的表：\n\n\n\n2.x 全局 API\n3.x 实例 API (app)\n\n\n\nVue.config\napp.config\n\n\nVue.config.productionTip\nremoved (见下方)\n\n\nVue.config.ignoredElements\napp.config.isCustomElement (见下方)\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use (见下方)\n\n\n所有其他不全局改变行为的全局 API 现在被命名为 exports，文档见全局 API Treeshaking。\nprovide\n参数：\n\n&#123;string | Symbol&#125; key\nvalue\n\n\n返回值：\n\n应用实例\n\n\n用法：\n设置一个可以被注入到应用范围内所有组件中的值。组件应该使用 inject 来接收提供的值。\n从 provide&#x2F;inject 的角度来看，可以将应用程序视为根级别的祖先，而根组件是其唯一的子级。\n该方法不应该与 provide 组件选项或组合式 API 中的 provide 方法混淆。虽然它们也是相同的 provide&#x2F;inject 机制的一部分，但是是用来配置组件提供的值而不是应用提供的值。\n通过应用提供值在写插件时尤其有用，因为插件一般不能使用组件提供值。这是使用 globalProperties 的替代选择。\nNote\nprovide 和 inject 绑定不是响应式的。这是有意为之。不过，如果你向下传递一个响应式对象，这个对象上的 property 会保持响应式。\n\n示例：\n向根组件中注入一个 property，值由应用提供。\n\n\n123456789101112import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;  inject: [&#x27;user&#x27;],  template: `    &lt;div&gt;      &#123;&#123; user &#125;&#125;    &lt;/div&gt;  `&#125;)app.provide(&#x27;user&#x27;, &#x27;administrator&#x27;)\n\n\n参考：\nProvide &#x2F; Inject\n\n\n\n","slug":"vue-next/vue3.0学习笔记","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"5c0a0a75442500bc3ebe7f3bf1ba536c","title":"中老年社交产品","content":"中老年社交产品用户真正需要的是什么？你的产品能缓解什么样的痛苦？\n中老年是被互联网遗忘的一个群体，他们有些人或已经退休，是该享受着天伦之乐的年纪，因此他们就有很多的空闲时间。中老年群体的社交圈大部分都是熟人圈子，很难去接触认识到陌生人，互联网可以缩短人与人之间的距离，但是对中老年人来说，并没有出现一个比较火热的陌生人社交软件。\n现在社会生活节奏迅速，家，这个在原始记忆里，应该陪伴我们出生、成长乃至衰老、死亡的地方，已经渐渐削弱了自身的养老功能。儿女工作繁忙，老人得不到陪伴；搬进高楼大厦，他们缺少社交；周边都是适应年轻人的事物，他们被边缘化、感知不到存在感。\n老年需要社交，像年轻人一样需要自己的生活圈子，参加丰富的活动，自主选择友谊或爱情。\n","slug":"产品/中老年社交产品","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"产品","author_index":"MessageWall"},{"id":"cf04a302e97a8c2ae7843d6accad5067","title":"随笔","content":"随笔中老年人生活普遍匮乏中年人需要良好的导向，奔向他们向往的生活方式他们被边缘化，感知不到存在感。儿女工作忙，得不到陪伴\n","slug":"产品/随笔","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"产品","author_index":"MessageWall"},{"id":"89bcb1c930785aaae911d56fd0f783b4","title":"2023计划","content":"如何做好UI设计\n做好边界测试，预想UI可能会出现的各种情况并做好处理，比如模拟文字很长的情况，UI应当能够进行很好的适配。\n\n一比一还原设计稿，注重细节，比如文字的高度居中、元素之间的间距等的细节问题\n\n尺寸自适应，样式单位尽量都写rem，如果不写rem，在不同的屏幕上会呈现不同的大小，在pc端调试时拉大屏幕宽度会更加明显\n\nUI可复用性，某些比较常用的组件可以进行封装，通过预先的参数设置满足不同场景的业务需求\n目前封装的组件有：Tabs选项卡切换（商城）、Svga播放器组件、弹窗（透明弹窗、通用弹窗、alert提示弹窗、loading等）、Form表单组件（支持规则校验）、InnerSelect选择器、TextField输入框（指定输入规范）\n\n设计规范：比如主体颜色，主要字体大小、文字间距、圆角等\n\n字体库：某些设计字体无法实现，需要引入字体库\n\ncss预处理\n\n特殊机型的适配问题，比如小米手机开启经典导航设置打开h5时，底部导航会占用h5页面的空间，导致被遮挡的情况\n\n图标库\n\n多调研同类型产品，培养设计审美，取长补短\n\n\n如何做好自测\n提交代码前进行代码审查，发现并纠正代码中的错误和问题\n细心，充分考虑各种情况以及边界条件\n自动化测试工具 - 比如Selenium\n单元测试\n利用谷歌调试工具进行真机调试\n核心业务代码评审\n兼容性测试\n\n如何发现并思考项目中存在的问题\n代码审查：定期进行代码审查，发现和纠正代码中的错误和问题。\n单元测试：重要的地方使用单元测试工具发现项目中的问题。\n性能监控：使用工具监控项目的性能，发现和优化性能瓶颈。\n反馈：收集和分析用户反馈，发现和解决用户需求和问题。\n代码评审：和团队成员一起进行代码评审，发现和纠正代码中的错误和问题。\n主动寻找问题：主动寻找项目中的问题，并思考如何解决。\n总结经验：总结项目中遇到的问题和解决方案，以便在未来的项目中使用。\napollo配置的痛点问题\n\napollo出于通用性的考虑，没有对json类型的数据做一些限制，这就导致了一些痛点问题。\n配置的属性名不可知，在不查阅文档或者问情相关人员的情况下，很难知道每个属性名代表什么意义\n无法对属性进行格式锁定以及校验，比如一个应当是数字类型的字段配制成了字符串类型，可能会导致报错，浪费排查时间\n无法清晰的知道支持配置哪些功能\n无法设置枚举，比如某个地方需要设置性别。1代表男，2代表女，需要查文档才知道枚举关系\n很难找到某个需求的配置位置，有时间可能需要问好几个人才知道配置在哪，增加了无效的沟通成本\n无法进行属性值约束，只能进行口头约束，这种约束是不可靠的\n配置较多的情况是，json太长容易配置错\n产品提出的痛点问题：希望能够支持输入建议，比如可以预置一些常用的原生协议。在配置过程中需要不断的进行复制粘贴，很麻烦\n\n解决方案制作一个通用的浏览器插件，增强apollo的配置校验功能，使用JSON Schema描述字段的标题、备注、约束条件、枚举等，用来进行校验。插件具有非侵入式的特点，不影响apollo的原有功能\n\nschema设置字段标题，使其支持查看每个字段的名称和备注\nschema设置字段类型，可以根据当前的配置json生产schema，当json变动时能够检测出字段类型是否和之前的schema中的类型一致，可以支持格式校验\n支持列举出所有的属性名称、备注以及相关信息\n支持设置枚举，并有边界校验\n支持配置的检索，收藏\n支持配置规则，比如数字可以配置范围区间、字符串支持配置正则校验\n提供表单化配置功能，根据json schema生成的一个多维表单，表单化配置\n输入建议\n\n\njenkins部署慢\n\n如何进行自我总结\n回顾过去：回顾过去的项目，总结自己在项目中的表现和贡献，提取经验教训。\n总结技能：总结自己的技能，发现自己的强项和弱项，并计划如何提升。\n研究新技术：不断研究新技术，更新自己的技能，保持对行业的关注\n分享经验：和团队成员分享自己的经验和知识，建立良好的沟通和学习氛围。\n制定计划，设定目标，明确自己想要达到的目标\n记录下自己的思考过程以及结论，形成文档\n分析问题：发现并分析自己存在的问题，如时间管理、沟通能力、团队协作等\n持续改进：根据评估结果持续调整目标和计划，持续改进。\n\n","slug":"其他/2023计划","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"其他","author_index":"MessageWall"},{"id":"56b4c3cf9f6d15fdabe8eaa9ff26c1e2","title":"apollo谷歌浏览器插件计划","content":"功能列表- \n","slug":"其他/apollo谷歌浏览器插件计划","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"其他","author_index":"MessageWall"},{"id":"0fe6c6eef6e43a0de60f25d72232eb4f","title":"前端性能监控","content":"前端性能监控是指在前端项目中收集和分析页面加载、渲染和交互的性能数据，主要包括以下几个方面：\n\n页面加载性能监控：监控页面加载时间、请求数量和大小、页面资源加载情况等。\n渲染性能监控：监控页面渲染时间、帧率、JavaScript运行时间等。\n交互性能监控：监控用户交互时间、延迟和错误等。\n错误监控：监控 JavaScript 错误、请求错误和资源错误等。\n\n为了监控前端性能,可以使用工具，如: Google Analytics, Google Tag Manager, Google Lighthouse, Webpagetest, YSlow, SpeedCurve, New Relic Browser, etc.\n通过使用这些工具，可以发现页面加载、渲染和交互的性能瓶颈，并采取相应的优化措施，提高页面的加载速度和用户体验。\n","slug":"其他/前端性能监控","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"其他","author_index":"MessageWall"},{"id":"d177b7da3f653e24c739049a5d098166","title":"基站定位算法","content":"手机基站 &amp; 蜂窝网络基站：基站即公用移动通信基站是无线电台站的一种形式，是指在一定的无线电覆盖区中，通过移动通信交换中心，与移动电话终端之间进行信息传递的无线电收发信电台。\n基站定位一般应用于手机用户，手机基站定位服务又叫做移动位置服务（LBS——Location Based Service），它是通过电信移动运营商的网络（如GSM网）获取移动终端用户的位置信息（经纬度坐标），在电子地图平台的支持下，为用户提供相应服务的一种增值业务，例如目前中国移动动感地带提供的动感位置查询服务等。\n1.1  COO（Cell of Origin）定位：COO定位是一种单基站定位，即根据设备当前连接的蜂窝基站的位置来确定设备的位置。\n1.2  AOA定位：AOA(Angle of Arrival到达角度)定位是一种两基站定位方法，基于信号的入射角度进行定位。\n1.3  TOA&#x2F;TDOA定位：TOA(Time of Arrival到达时间)、TDOA(Time Difference of Arrival到达时间差)都是基于电波传播时间的定位方法。也都是三基站定位方法，二者的定位都需要同时有三个位置已知的基站合作才能进行。基站定位的大致原理为：移动电话测量不同基站的下行导频信号，得到不同基站下行导频的TOA（Time of Arrival，到达时刻）或TDOA(Time Difference of Arrival，到达时间差)，根据该测量结果并结合基站的坐标，一般采用三角公式估计算法，就能够计算出移动电话的位置。实际的位置估计算法需要考虑多基站(3个或3个以上)定位的情况，因此算法要复杂很多。一般而言，移动台测量的基站数目越多，测量精度越高，定位性能改善越明显。\n什么是MNC&#x2F;LAC&#x2F;Cell ID\nMobile Network Code(MNC)移动网号码，中国联通CDMA系统的MNC为03，中国移动的为00。\nMobile Country Code(MCC)移动用户所属国家代号：460\nLocation Area Code(LAC)地区区域码，用来划分区域，一般一个小地方就一个LAC，大地方就\nCell Tower ID(Cell ID)CellID代表一个移动基站，如果你有基站数据，查CellID你就可以知道这个基站在哪里，移动公司或者警察通过这个知道你是在哪个基站范围打的移动电话。\n\n　这些信息有什么用呢？ 通过这些信息可以知道你的手机是从哪个国家，区域和哪个基站接入移动网络的。所以有些防盗手机丢失后，会发一些类 似”MCC:460;MNC:01;LAC:7198:CELLID:24989”内容的短信到你指定号码就是这个用途，通过这些信息可以从移动查到你的 被盗手机在哪里出现过。不过知道了也没用，中国人口这么密集，就是在你身边你也不知道谁是小偷：） \nTrilateration三边测量定位算法Trilateration（三边测量）是一种常用的定位算法：\n\n已知三点位置 (x1, y1), (x2, y2), (x3, y3)\n已知未知点 (x0, y0) 到三点距离 d1, d2, d3\n\n以 d1, d2, d3 为半径作三个圆，根据毕达哥拉斯定理，得出交点即未知点的位置计算公式：\n123( x1 - x0 )2 + ( y1 - y0 )2 = d12( x2 - x0 )2 + ( y2 - y0 )2 = d22( x3 - x0 )2 + ( y3 - y0 )2 = d32\n\n\n设未知点位置为 (x, y)， 令其中的第一个球形 P1 的球心坐标为 (0, 0)，P2 处于相同纵坐标，球心坐标为 (d, 0)，P3 球心坐标为 (i, j)，三个球形半径分别为 r1, r2, r3，z为三球形相交点与水平面高度。则有：\n123r12 = x2 + y2 + z2r22 = (x - d)2 + y2 + z2r32 = (x - i)2 + (y - j)2 + z2\n\n当 z &#x3D; 0 时， 即为三个圆在水平面上相交为一点，首先解出 x:\n1x = (r12 - r22 + d2) / 2d\n\n将公式二变形，将公式一的 z2 代入公式二，再代入公式三得到 y 的计算公式：\n1y = (r12 - r32 - x2 + (x - i)2 + j2) / 2j\n\njavascript算法实现1234567891011121314function trilateration(x1, y1, d1, x2, y2, d2, x3, y3, d3) &#123;  var d = [0.0, 0.0];  var a11 = 2 * (x1 - x3);  var a12 = 2 * (y1 - y3);  var b1 = Math.pow(x1, 2) - Math.pow(x3, 2) + Math.pow(y1, 2) - Math.pow(y3, 2) + Math.pow(d3, 2) - Math.pow(d1, 2);  var a21 = 2 * (x2 - x3);  var a22 = 2 * (y2 - y3);  var b2 = Math.pow(x2, 2) - Math.pow(x3, 2) + Math.pow(y2, 2) - Math.pow(y3, 2) + Math.pow(d3, 2) - Math.pow(d2, 2);  d[0] = (b1 * a22 - a12 * b2) / (a11 * a22 - a12 * a21);  d[1] = (a11 * b2 - b1 * a21) / (a11 * a22 - a12 * a21);  return d;&#125;var area = trilateration(12641371.971, 4138703.5211, 6, 12641381.9026, 4138706.4714, 6, 12641370.7839, 4138708.7705, 6);console.log(area.join(&#x27;,&#x27;));\n\nD3.js实现定义三个圆的坐标及半径，计算\t出交点的坐标 (obj_x, obj_y).\n12345678var x_0 = 150, y_0 = 150;var x_1 = x_0, y_1 = y_0, d = 150, x_2 = x_0 + d, x_3 = 225, y_3 = 315, r = 100;var i = x_3 - x_0, j = y_3 - y_0;var x = (Math.pow(r, 2) - Math.pow(r, 2) + Math.pow(d, 2)) / (2 * d) + x_0;var obj_x = x + x_0;var y = (Math.pow(r, 2) - Math.pow(r, 2) - Math.pow(x, 2) + Math.pow((x - i), 2)    + Math.pow(j, 2)) / (2 * j);var obj_y = y + y_0;\n\n绘出圆形及交点：\n123456789101112svg.append(&quot;circle&quot;).attr(&quot;cx&quot;, x_1)    .attr(&quot;cy&quot;, y_1).attr(&quot;r&quot;, r)    .style(&quot;fill&quot;, &quot;blue&quot;).style(&quot;opacity&quot;, 0.3);svg.append(&quot;circle&quot;).attr(&quot;cx&quot;, x_2)    .attr(&quot;cy&quot;, y_0).attr(&quot;r&quot;, r)    .style(&quot;fill&quot;, &quot;red&quot;).style(&quot;opacity&quot;, 0.4);svg.append(&quot;circle&quot;).attr(&quot;cx&quot;, x_3)    .attr(&quot;cy&quot;, y_3).style(&quot;opacity&quot;, 0.5)    .attr(&quot;r&quot;, r).style(&quot;fill&quot;, &quot;yellow&quot;);svg.append(&quot;circle&quot;).attr(&quot;cx&quot;, obj_x)    .attr(&quot;cy&quot;, obj_y).attr(&quot;r&quot;, 3)    .style(&quot;fill&quot;, &quot;red&quot;);\n\n多于用实现定位算法，与之相同的也许还可以采用K-Means或Overlap聚类算法，后两者在地图标注上使用比较广。\n","slug":"其他/基站定位算法","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"其他","author_index":"MessageWall"},{"id":"7b1d9f1b53c09e4a6b55593ac7c3e160","title":"认识mongodb","content":"认识mongodbMongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。\n在高负载的情况下，添加更多的节点，可以保证服务器性能。\nMongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n启动mongo服务 \n1mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork\n\n主要特点\nMongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。\n你可以在MongoDB记录中设置任何属性的索引 (如：FirstName&#x3D;”Sameer”,Address&#x3D;”8 Gandhi Road”)来实现更快的排序。\n你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。\n如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。\nMongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。\nMongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。\nMongodb中的Map&#x2F;reduce主要是用来对数据进行批量处理和聚合操作。\nMap和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。\nMap函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。\nGridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。\nMongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。\nMongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。\nMongoDB安装简单。\n\n概念解析\n数据库一个mongodb中可以建立多个数据库。\nMongoDB的默认数据库为”db”，该数据库存储在data目录中。\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n“show dbs” 命令可以显示所有数据的列表。\n执行 “db” 命令可以显示当前数据库对象或集合。\n有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。\n\nadmin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n文档(Document)文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n一个简单的文档例子如下：\n{“site”:”www.runoob.com“, “name”:”菜鸟教程”}\n需要注意的是：\n文档中的键&#x2F;值对是有序的。文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。MongoDB区分类型和大小写。MongoDB的文档不能有重复的键。文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。文档键命名规范：\n键不能含有\\0 (空字符)。这个字符用来表示键的结尾。.和$有特别的意义，只有在特定环境下才能使用。以下划线”_”开头的键是保留的(不是严格要求的)。\n集合集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。\n集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n比如，我们可以将以下不同数据结构的文档插入到集合中：\n{“site”:”www.baidu.com&quot;}{“site”:”www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}{“site”:”www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5}\n当第一个文档插入时，集合就会被创建。\n\n\n常用命令\n创建一个数据库或者切换到该数据库use test\n\n显示所有的数据库show dbs\n\n删除数据库db.dropDatabase()\n\n创建集合db.createCollection(name, options)\n\n\n\n\n显示所有的集合show collections或者show tables\n\n删除集合db.user.drop()\n\n添加一个文档db.user.insert(&#123;&quot;name&quot;:&quot;菜鸟教程&quot;&#125;)或db.user.save(&#123;&quot;name&quot;: &quot;wangjinxin&quot;&#125;)\n\n\n添加文档时如果这个集合没有创建，则会自动创建集合\nsave()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据\n\n更新文档\n\n123456789db.collection.update(   &lt;query&gt;,   &lt;update&gt;,   &#123;     upsert: &lt;boolean&gt;,     multi: &lt;boolean&gt;,     writeConcern: &lt;document&gt;   &#125;)\n\n参数说明：\nquery : update的查询条件，类似sql update查询内where后面的。update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。writeConcern :可选，抛出异常的级别。\n也可以使用save方法save() 方法通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入。语法格式如下：\n123456db.collection.save(   &lt;document&gt;,   &#123;     writeConcern: &lt;document&gt;   &#125;)\n参数说明：\ndocument : 文档数据。writeConcern :可选，抛出异常的级别。\n","slug":"数据库/认识mongodb","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"数据库","author_index":"MessageWall"},{"id":"4ec3ab85b3f89beb24c14eb859217c27","title":"1.尚方能源一面","content":"\n字符串截取方法有哪些\n\nstr.slice(start,end) &#x2F;&#x2F;从索引start开始到索引end结束不包括end。\nstart为起始索引，end为结束索引。start(end)如果为负，则值为 str.length+start（end）。\n如为负则代表从尾部开始截取\nstr.substring(start,end)。 &#x2F;&#x2F;从索引start开始到索引end结束不包括end。\nstr.substr(start,sum) &#x2F;&#x2F;从索引start开始到sum个结束包括sum。\nstart为起始索引，sum为截取个数。start如果为负值，则为str.length+start,sum为负值默认为0。\n\n数组追加元素有哪些方法\n\n\n1、push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。\n2、unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\n3、splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。\n\n\n数组push方法返回值是啥\n\n数组长度\n\nvue的自定义指令\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 自动获取焦点 vue2Vue.directive(&#x27;focus&#x27;, &#123;  inserted: function (el) &#123;    el.focus()  &#125;&#125;)有以下五个钩子函数：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。每个钩子函数有以下参数：el：指令所绑定的元素，可以用来直接操作 DOM。binding：一个对象，包含以下 property：name：指令名，不包括 v- 前缀。value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。vnode：Vue 编译生成的虚拟节点。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用————————————————版权声明：本文为CSDN博主「思考的行者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xiaonankeji/article/details/128223177vue3指令的钩子会传递以下几种参数：el：指令绑定到的元素。这可以用于直接操作 DOM。binding：一个对象，包含以下属性。value：传递给指令的值。例如在 v-my-directive=“1 + 1” 中，值是 2。oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 “foo”。modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 &#123; foo: true, bar: true &#125;。instance：使用该指令的组件实例。dir：指令的定义对象。vnode：代表绑定元素的底层 VNode。prevNode：之前的渲染中代表指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。————————————————版权声明：本文为CSDN博主「北海屿鹿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zz130428/article/details/128426017vue3的钩子函数&#123;// 自定义指令所在组件, 创建后  created(el, binding, vnode, prevVnode) &#123;    // 下面会介绍各个参数的细节  &#125;,  // (相当于vue2的bind)自定义指令绑定到 DOM 后调用. 只调用一次, 注意: 只是加入进了DOM, 但是渲染没有完成，  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,   //就是Vue2.x中的 inserted, 自定义指令所在DOM, 插入到父 DOM 后调用, 渲染已完成(最最重要)  mounted(el, binding, vnode, prevVnode) &#123;&#125;,  // 自定义指令所在 DOM, 更新之前调用  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,  // 就是Vue2.x中的 componentUpdated  updated(el, binding, vnode, prevVnode) &#123;&#125;,  //销毁前  beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;,  // 销毁后  unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125;\n\n\n浏览器的事件循环机制\n\n12345678910111213141516171819202122在 js 中任务会分为同步任务和异步任务。如果是同步任务，则会在主线程（也就是 js 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（js 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。在 js 中，任务队列中的任务又可以被分为 2 种类型：宏任务（macrotask）与微任务（microtask）但这两种分类已经无法满足现如今复杂的浏览器环境了，所以后续舍弃了宏任务，用一种更加灵活的方式取代了它。根据W3C的官方解释，每个任务都有不同的类型，同类型的任务必须在一个队列，不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列任务的优先级仅次于主线程，必须先调度执行，其次是延时队列（主要用来处理延时器setTimeOut），最后是交互队列（处理与用户的交互，如点击事件等）。所以任务的优先级为：微队列 &gt; 延时队列 &gt; 交互队列\n\n\n看代码的执行顺序\n看一下代码的执行结果\n\n12345678910111213141516171819202122function Foo() &#123;  Foo.a = function() &#123;    console.log(1);  &#125;  this.a = function() &#123;    console.log(3);  &#125;  console.log(&#x27;this&#x27;, this)&#125;Foo.a = function() &#123;  console.log(4);&#125;Foo.prototype.a = function() &#123;  console.log(2);&#125;Foo.a();const obj = new Foo();obj.a();Foo.a();\n\n\n\n执行结果是：\n4\nthis Foo{ a: () {} }\n3\n1\n\nnextTick原理\n\n\nnextTick 是 Vue 提供的一个全局的API ，由于Vue的异步更新策略导致我们对数据的修改不会立马体现到变化上，此时如果想要立即获取更新后的dom的状态，就需要使用这个方法。\nVue在更新dom时是异步执行的。只要监听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓存时去重对于避免不必要的计算和dom操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。 用一张图可以很好的描述下这个过程。\n\n\n","slug":"面试题/1.尚方能源一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"9570406cfe6951000c21d8d5155a0b25","title":"10.鲁大师一面","content":"\nWebpack的构建流程\n\nType和interface的区别\n\njs垃圾回收机制\n\n说说对范型的理解\n\nSync的原理\n\n\n","slug":"面试题/10.鲁大师一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"9e13f3b46bb4f0248b7fc78b0ae5b39a","title":"11.黑镜一面","content":"\n什么是事件冒泡和事件捕获\n\nhttps://www.pipipi.net/27549.html\n\nvue和react的事件实现原理\n\nReact基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等\n在React中这套事件机制被称之为合成事件\n合成事件（SyntheticEvent）合成事件是 React模拟原生 DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器\n根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：\n1const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;\n\n如果想要获得原生DOM事件，可以通过e.nativeEvent属性获取\n12const handleClick = (e) =&gt; console.log(e.nativeEvent);;const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;\n\n从上面可以看到React事件和原生事件也非常的相似，但也有一定的区别：\n\n事件名称命名方式不同\n12345// 原生事件绑定方式&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;      // React 合成事件绑定方式const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;\n\n\n事件处理函数书写不同\n12345// 原生事件 事件处理函数写法&lt;button onclick=&quot;handleClick()&quot;&gt;按钮命名&lt;/button&gt;      // React 合成事件 事件处理函数写法const button = &lt;button onClick=&#123;handleClick&#125;&gt;按钮命名&lt;/button&gt;\n\n\n\n虽然onclick看似绑定到DOM元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听\n这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象\n当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升\n二、执行顺序关于React合成事件与原生事件执行顺序，可以看看下面一个例子：\n\n12345678910111213141516171819202122232425262728293031323334353637import  React  from &#x27;react&#x27;;class App extends React.Component&#123;  constructor(props) &#123;    super(props);    this.parentRef = React.createRef();    this.childRef = React.createRef();  &#125;  componentDidMount() &#123;    console.log(&quot;React componentDidMount！&quot;);    this.parentRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;原生事件：父元素 DOM 事件监听！&quot;);    &#125;);    this.childRef.current?.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;原生事件：子元素 DOM 事件监听！&quot;);    &#125;);    document.addEventListener(&quot;click&quot;, (e) =&gt; &#123;      console.log(&quot;原生事件：document DOM 事件监听！&quot;);    &#125;);  &#125;  parentClickFun = () =&gt; &#123;    console.log(&quot;React 事件：父元素事件监听！&quot;);  &#125;;  childClickFun = () =&gt; &#123;    console.log(&quot;React 事件：子元素事件监听！&quot;);  &#125;;  render() &#123;    return (      &lt;div ref=&#123;this.parentRef&#125; onClick=&#123;this.parentClickFun&#125;&gt;        &lt;div ref=&#123;this.childRef&#125; onClick=&#123;this.childClickFun&#125;&gt;          分析事件执行顺序        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default App;\n\n\n输出顺序为：\n12345原生事件：子元素 DOM 事件监听！ 原生事件：父元素 DOM 事件监听！ React 事件：子元素事件监听！ React 事件：父元素事件监听！ 原生事件：document DOM 事件监听！ \n\n可以得出以下结论：\n\nReact 所有事件都挂载在 document 对象上\n当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件\n所以会先执行原生事件，然后处理 React 事件\n最后真正执行 document 上挂载的事件\n\n对应过程如图所示：\n \n所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：\n\n阻止合成事件间的冒泡，用e.stopPropagation()\n阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()\n阻止合成事件与最外层document上的原生事件上的冒泡，通过判断e.target来避免\n\n\n123456document.body.addEventListener(&#x27;click&#x27;, e =&gt; &#123;       if (e.target &amp;&amp; e.target.matches(&#x27;div.code&#x27;)) &#123;          return;        &#125;        this.setState(&#123;   active: false,    &#125;);   &#125;); &#125;\n\n\n三、总结React事件机制总结如下：\n\nReact 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)\nReact 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。\nReact 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback\nReact 有一套自己的合成事件 SyntheticEvent\n\n\n判断数组有几种方法\n\n1234a instanceof Array;a.constructor === Array; Object.prototype.toString.call(a) === &#x27;[Object Array]&#x27;;Array.isArray(a);\n\n\nWeb pack loader的执行循序\n箭头函数和普通函数的区别\n\n123456this指向不同箭头函数没有arguments，不能用...箭头函数不能实例化，不能当构造函数箭头函数没有原型，箭头函数不具备super箭头函数没有new.target箭头函数都是匿名函数，普通函数可以有匿名函数也可以有具名函数\n\n","slug":"面试题/11.黑镜一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"a27f8cb4a0e9f55c9e8d2da96f3e5630","title":"2.交易所一面","content":"\nVue3和vue2有啥区别\n\n12345678910111213141516171819202122232425262728293031323334353637383940411.双向数据绑定原理不同Vue2 的双向数据绑定是利用ES5的一个APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。Vue3 中使用ES6的Proxy API对数据代理。Vue3 使用数据代理的优势有以下几点：1）definePropert 只能监听某个属性，不能对整个对象进行监听 2）可以省去for in，闭包等内容来提升效率（直接绑定整个对象即可）3）可以监听数组，不用再单独的对数组做特异性操作，Vue3可以检测到数组内部数据的变化2.是否支持碎片Vue2 不支持碎片。Vue3 支持碎片，就是说可以拥有多个根节点3.API 类型不同Vue2 使用选项类型api,选项型api 在代码里分割了不同的属性：data,computed,method等。Vue3 使用合成型api,新的合成型api 能让我们使用方法来分割，相比于旧的api 使用属性来分组，这样代码会更加简便和整洁。4定义数据变量和方法不同Vue2是把数据放到了data 中，在 Vue2中 定义数据变量是data()&#123;&#125;,创建的方法要在method:&#123;&#125;Vue3 就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：1）从vue 引入 reactive；2）使用 reactive ()方法来声明数据为响应性数据；3） 使用setup()方法来返回我们的响应性数据，从而template 可以获取这些响应性数据。5.生命周期钩子函数不同Vue2 中的生命周期：beforeCreate 组件创建之前；created 组建创建之后；beforeMount 组件挂载到页面之前执行；Mounted 组件挂载到页面之后执行，beforeUpdate 组件更新之前；updated组件更新之后Vue3 中的生命周期：setup 开始创建组件；onBeforeMount 组件挂载到页面之前执行；onMounted 组件挂载到页面之后执行；onBeforeUpdate 组件更新之前；onUpdated 组件更新之后；而且 Vue3 生命周期在调用前需要先进行引入。除了这些钩子函数外，Vue3 还增加了 onRenderTracked 和onRenderTriggered 函数。6.父子传参不同Vue2 父传子，用props ；子传父用事件Emitting Events。在Vue2 中，会调用this$emit 然后传入事件名和对象。Vue3 父传子，用props;子传父用Emitting Events 。在Vue3 中的setup()中的第一参数content 对象中就有 emit,那么我们只要在setup()接收第二个参数中使用分解对象法取出emit 就可以在setup 方法中随意使用了。7.指令与插槽不同Vue2 中使用slot 可以直接使用slot ;v-for 与v-if 在Vue2中优先级高的是v-for 指令，而且不建议一起使用。Vue3 中必须是使用v-slot的形式；vue 3中v-for 与v-if ，只会把当前v-if 当作v-for 的一个判断语句，不会相互冲突；Vue3 中移除keyCode 作为v-on 的修饰符，当然也不支持config.keyCodes，取而代之的是使用键名来作为事件的修饰符来使用，于是Vue.config.keyCodes 也被弃用了-vue2我们在监听按键事件的时候，是可以通过在事件后面加上按键码来实现监听某一个按键的--mulingyuer.com/archives/831/# ；————————————————版权声明：本文为CSDN博主「多啦爱梦的梦想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_56263402/article/details/128799953\n\n\n写h5和pc端有什么区别嘛\n\n怎么做首屏优化\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243HTML优化：将CSS放在里，可用来避免浏览器渲染的重复计算。将JavaScript脚本放在的最后面，避免资源阻塞页面渲染。减少DOM数量，减少浏览器渲染过程中的计算耗时。通过合理使用浏览器GPU合成，提升浏览器渲染效率。请求优化：非核心资源异步加载，控制首屏请求数量；静态文件进行缓存处理，合理设置缓存时效；使用http2.0协议，来提升传输性能，减小请求阻塞；网站开启GZIP优化，进行网页压缩处理；对客户端进行资源预请求和预加载，比如使用预热Web容器。渲染优化：可以使用骨架屏进行页面预渲染；对页面进行分片/分屏加载，将页面可见/可交互时间提前；优化资源加载的顺序和粒度，仅加载需要的资源，通过异步加载方式加载剩余资源；使用差异化服务，比如读写分离，对于不同场景按需加载其所需要的模块；使用服务端直接渲染，减少页面二次请求和渲染的耗时。静态资源优化:针对JS、CSS 、HTML资源合并与压缩。针对不同场景使用不同的图片格式。使用雪碧图（CSS Sprites）和SVG，替代多个小图。首屏预加载，非首屏懒加载。\n\n\nh5的适配怎么做\n\n123rem适配vmcalc\n\n5.rem适配有啥缺点\n12345678（1）在奇葩的dpr设备上(设备像素比(简称dpr))表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。（4）rem在处理小数的时候会有误差，而且对小屏幕不友好。————————————————版权声明：本文为CSDN博主「more名奇妙」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/m0_67948827/article/details/127031751\n\n\n有做过老项目改造吗\n老项目改造有什么难点\n做过国际化嘛\nWebpack做过哪些优化\n你的强项在哪\n谈谈你对redux的理解\n\n","slug":"面试题/2.交易所一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"edc763cbfc515ed7263e9656729e3c28","title":"3.交研智慧一面","content":"\n详细介绍一个项目\nseviceWorker和普通缓存有啥区别\n\n1234567891011121314151617181920Service Worker 和普通的缓存机制在功能和使用场景上存在明显的区别。普通缓存：普通缓存通常指的是浏览器对网页资源的存储机制。当用户请求一个网页或资源时，浏览器会将获取到的资源（如 HTML、CSS、JavaScript、图片等）存储在本地的缓存中。如果用户再次请求相同的网页或资源，浏览器会首先检查缓存中是否存在该资源，如果存在，则直接从缓存中获取，避免了再次从服务器下载。这样可以提高网页的加载速度，减少网络请求的次数。普通缓存是一种通用的浏览器缓存机制，适用于所有网页和资源。它具有以下特点：自动缓存：浏览器会自动缓存用户访问过的网页和资源。持久性：缓存的资源可以在一段时间内保持有效，甚至在浏览器关闭后重新打开时仍然可用。无法控制：开发者无法直接控制普通缓存的机制和行为，只能通过设置 HTTP 头部的缓存控制策略来影响缓存行为。Service Worker：Service Worker 是一种由浏览器在后台独立于网页运行的脚本，通常用于处理网络请求和实现离线功能。它是一种更高级的缓存机制，允许开发者通过编程方式控制网页资源的缓存和网络请求。Service Worker 具有以下特点：可编程性：Service Worker 可以由开发者编写自定义的 JavaScript 代码来控制资源的缓存和网络请求。可以通过拦截请求、响应和处理离线事件等方式，实现自定义的缓存策略和离线功能。生命周期独立：Service Worker 的生命周期独立于网页的生命周期，可以在网页关闭后仍然运行。因此，它可以实现离线功能，如离线推送、离线同步等。资源限制：Service Worker 的资源使用受到限制，例如存储空间和并发连接数等。因此，需要谨慎管理和优化资源的使用。安全性和隔离：Service Worker 在运行时具有安全性和隔离性。它无法访问 DOM 和其他浏览器 API，同时与其他 Service Worker 之间也相互隔离。总结起来，普通缓存是一种自动的、持久的、无法控制的浏览器缓存机制，适用于所有网页和资源；而 Service Worker 是一种可编程的、独立的、有资源限制的缓存机制，主要用于实现离线功能和更高级的网络请求处理。\n\n\nReact做过什么项目\n在写代码过程中哪些东西会影响代码质量和稳定性\n\n123456789在写代码过程中，许多因素都会影响代码质量和稳定性，以下是一些主要的因素：需求和设计：需求和设计是影响代码质量和稳定性的重要因素。如果需求和设计不清晰、不完整或者不合理，那么代码的质量和稳定性就很难得到保证。因此，在开发过程中，需要充分了解需求和设计，并及时与相关人员进行沟通和反馈。编码规范和标准：编码规范和标准是保证代码质量和稳定性的重要工具。通过遵循统一的编码规范和标准，可以减少代码的错误率和维护难度，提高代码的可读性和可维护性。代码结构和设计模式：良好的代码结构和设计模式可以提高代码的可读性、可维护性和可扩展性，从而保证代码的质量和稳定性。因此，在编写代码时，应该注重代码的结构和设计模式的选择。测试和质量保证：测试和质量保证是保证代码质量和稳定性的重要手段。通过编写测试用例、进行单元测试、集成测试和系统测试等，可以发现和修复代码中的错误和缺陷，提高代码的质量和稳定性。代码审查和文档：代码审查和文档是保证代码质量和稳定性的重要工具。通过进行代码审查可以发现代码中的问题和缺陷，并及时进行修复；同时编写文档可以方便后续的维护和理解。版本控制和持续集成：版本控制和持续集成可以提高代码的质量和稳定性。通过使用版本控制工具可以方便地跟踪和管理代码的变化；而持续集成可以及时发现和修复问题，保证代码的质量和稳定性。团队协作和沟通：团队协作和沟通也是影响代码质量和稳定性的重要因素。通过良好的团队协作和沟通，可以保证信息的及时传递和理解，避免因误解或沟通不畅而导致的错误和缺陷。\n\n\n常用的设计模式有哪些\n\n\n\n渲染的性能问题如何解决\n\n12345678910前端的渲染性能问题可以从以下几个方面进行优化：合并请求：过多的请求会增加网络延迟，影响渲染速度。可以通过合并请求来减少网络延迟。缓存策略：使用缓存策略，如浏览器缓存、CDN缓存等，可以减少每次加载资源的时间，提高渲染速度。异步加载和延迟渲染：对于一些非关键资源，可以采取异步加载和延迟渲染的策略，即在页面加载后再进行渲染，从而提高页面的初始加载速度。优化图片：对于图片资源，可以通过优化图片格式、压缩图片大小、使用懒加载等方式来减少加载时间和渲染时间。使用CDN：使用CDN可以将资源存储在全球各地的服务器上，让用户从最近的服务器获取资源，减少加载时间和网络延迟。优化代码：通过优化代码来减少渲染时间也是一种有效的方法。例如，避免使用过多的嵌套样式、避免使用过于复杂的JavaScript表达式等。使用前端性能工具：使用前端性能工具可以对页面性能进行监测和优化，帮助开发者发现和解决性能问题。综上所述，前端的渲染性能问题可以通过合并请求、缓存策略、异步加载和延迟渲染、优化图片、使用CDN、优化代码以及使用前端性能工具等多种方式进行优化和解决。\n\n","slug":"面试题/3.交研智慧一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"72491d8a53840bf6b32cd4a867f37441","title":"5.小红书一面","content":"\n浏览器的事件循环机制和node的事件循环机制有什么不同\n\n1234567891. 执行环境：浏览器的Event Loop运行在浏览器环境中，而Node.js的Event Loop运行在Node.js环境中。浏览器的Event Loop负责处理浏览器事件、用户交互和渲染等，而Node.js的Event Loop主要处理I/O操作和网络请求等。　　2. 宏任务和微任务：浏览器和Node.js都将任务分为宏任务(Macro Task)和微任务(Micro Task)，但它们在微任务的处理上有所不同。在浏览器中，微任务包括Promise、MutationObserver和queueMicrotask等，而在Node.js中，微任务包括Promise和process.nextTick等。　　3. 触发时机：浏览器的Event Loop通常在每次完成宏任务后执行微任务队列，然后执行浏览器渲染，从而实现动画效果。而Node.js的Event Loop在每次完成一个宏任务后，会先执行微任务队列，然后继续执行下一个宏任务。　　4. Event Loop的运行机制：浏览器的Event Loop通常是单线程的，通过异步回调函数和事件触发来实现非阻塞的异步操作。而Node.js的Event Loop是基于Libuv库实现的，它利用了底层操作系统提供的多线程特性，使得Node.js能够处理更高的并发请求。　　总体而言，浏览器和Node.js的事件循环在目标、实现和行为上存在一些差异。了解这些区别有助于开发者更好地理解和处理异步操作，并根据具体场景做出适当的调整。\n\n\nscript标签中 defer和async分别是什么\n\n12345678defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。async比较适合第三方的脚本，defer适合与dom有关联的脚本，双方都只适于外部脚本。 \n\n\n如何计算首屏时间\n\n1234567891011// 确保页面已完全加载  window.onload = function() &#123;    // 获取性能数据    var performanceData = window.performance.timing;        // 计算TTFB    var ttfb = performanceData.responseStart - performanceData.navigationStart;        // 输出TTFB    console.log(&#x27;TTFB: &#x27; + ttfb + &#x27;ms&#x27;);  &#125;\n\n\nrequestAnimationFrame是什么\n\n1requestAnimationFrame是浏览器提供的一个用于优化动画和渲染的API。它基于浏览器的刷新率，调度回调函数的执行，以确保动画和渲染的流畅性和高性能。使用requestAnimationFrame，开发者可以在每个浏览器刷新帧之前请求执行一个函数。浏览器会在适当的时机调用这个函数，以保证动画和渲染的协调性。\n\n\nservicesWorker在什么时候更新\nh t t p2.0更新了什么\n\nHTTP2.0主要更新了以下内容：\n\nHTTP&#x2F;2是超文本传输协议（HTTP）的第二个主要版本，相较于之前的HTTP&#x2F;1.1，它带来了多项重要的改进和优化，主要包括：\n\n二进制协议：HTTP&#x2F;2使用二进制格式而不是HTTP&#x2F;1.x的文本格式。二进制协议解析起来更高效，更少出错。\n多路复用：在同一个连接上同时发送多个请求-响应消息，而不需要等待一个交换完成后再开始下一个。这减少了页面加载时间和服务器压力。\n头部压缩：HTTP&#x2F;2使用HPACK（头部压缩算法）减少了头部大小，减轻了带宽压力。\n服务器推送：服务器可以对一个客户端请求发送多个响应。服务器可以主动推送资源给客户端，而不必等待客户端对这些资源的请求。\n流控制：HTTP&#x2F;2为每个流提供了流控制，从而优化了数据传输过程，提高了性能。\n优先级和依赖性：客户端可以指定请求的优先级，允许更重要的资源更快地传输。\n\n\nBFC是啥\n\n\nBFC即Block Formatting Contexts（块级格式化上下文），是W3C CSS2.1规范中的一个概念。\nBFC是指浏览器中创建了一个独立的渲染区域，并且拥有一套渲染规则，它决定了其子元素如何定位，以及与其他元素的相互关系和作用。简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。\n","slug":"面试题/5.小红书一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"df6f60ca2a548c4bb3e07a9eadb3264a","title":"8.途家一面","content":"\njs的数据类型\n\njs怎么理解闭包，有哪些应用场景\n\n事件循环机制\n\n对原型和原型链怎么理解\n\nj s深拷贝\n\n变量声明提升\n\njs异步的理解\n\njs的垃圾回收机制\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136二、垃圾回收策略在 JavaScript 内存管理中有一个概念叫做 可达性 ，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收。至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， JavaScript 垃圾回收机制的原理就是定期找出那些不再用到的内存（变量），然后释放其内存。（不是实时的找出无用内存并释放的原因：实时开销太大了）。1、标记清除法1.1 策略标记清除（ Mark-Sweep ），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异。 此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。你可能会疑惑怎么给变量加标记？当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记）；维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表；引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组根对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树等。整个标记清除算法大致过程就像下面这样：垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0；然后从各个根对象开始遍历，把不是垃圾的节点改成1；清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间；最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收；1.2 优点实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单1.3 缺点在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题：2、引用计数算法1.策略引用计数（ Reference Counting ），这其实是早先的一种垃圾回收算法，它把对象是否不再需要简化定义为对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，但因为它的问题很多，目前很少使用这种算法了。它的策略是跟踪记录每个变量值被使用的次数当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1；如果同一个值又被赋给另一个变量，那么引用数加 1；如果该变量的值被其他的值覆盖了，则引用次数减 1；当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存；let a = new Object() // 1alet b = a // 2a,ba = null // 1bb = null // 0... // GC循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A：function test()&#123; let A = new Object() let B = new Object() A.b = B B.a = A&#125;2.优点引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾；标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了；3.缺点需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限；无法解决循环引用无法回收的问题；3、V8对GC的优化1.分代式垃圾回收上文所说的垃圾回收策略在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说，同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，这也是分代式的原则。1.1 新老生代V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大 V8 整个堆内存的大小就等于新生代加上老生代的内存：1.2 新生代垃圾回收新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge 算法的具体实现中，主要采用了一种复制 式的方法即 Cheney 算法： Cheney 算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为使用区，一个是处于闲置状态的空间我们称之为空闲区：新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。1.3 老生代垃圾回收相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是标记清除了。首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象。 清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉。前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了上文中说的标记整理算法来解决这一问题来优化空间。1.4总结分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。2.并行回收(Parallel)先了解一个概念：全停顿（ Stop-The-World ），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿。所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作。新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，这就是并行回收。3.增量标记与懒性清理并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间。所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记。3.1 什么是增量3.2 三色标记法(暂停与恢复)三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑白色指的是未被标记的对象；灰色指自身被标记，成员变量（该对象的引用对象）未被标记；黑色指自身和成员变量皆被标记；我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象 时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色；就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）。采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以。三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间。4. 总结V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，上述的这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的：老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）；标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）；\n\n\n跨域\nvue data为啥必需是函数\ncomputed和watch有什么不同\nvue怎么实现响应式数据\nmvvm的理解\n虚拟dom的作用\nKeep-aliVE的用处和原理\n\n12345678910111213在 Vue 的世界里，keep-alive 就像是一种魔法保险箱，它能够保护和缓存你的组件，让它们即使在被切换或隐藏时，仍然保留它们的状态、避免重新渲染。让我们一探究竟，看看这个神奇的 keep-alive 是怎么工作的！6.2 keep-alive 的工作原理6.2.1 缓存机制当组件第一次渲染时，keep-alive 会将其存储在内部缓存中。当组件再次需要渲染时，keep-alive 会从缓存中取出组件实例，而不是重新创建。6.2.2 生命周期影响当组件被 keep-alive 包裹时，它不会经历常规的销毁和重建过程。keep-alive 会触发特定的生命周期钩子，如 activated 和 deactivated。6.3 使用场景6.3.1 多标签页在构建类似多标页的界面时，keep-alive 可以保持每个标签页状态，用户切换标签时不会失去之前的状态。6.3.2 性能优化在移动端应用或性能敏感的应用中，keep-alive 可以减少组件渲染的性能开销。\n\n\nnextTick的作用和原理\nssr\n\n\n","slug":"面试题/8.途家一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"9b6f7175aa7ad59c5476f0295f502b50","title":"9.美团一面","content":"\nv-if和v-show的区别\nvue2和vue3区别\n看代码的输出结果\n\n\n","slug":"面试题/9.美团一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"ff00ce35a2f14eec99334118a6d1eec3","title":"6.智联招聘一面和二面","content":"\ncss水平居中，垂直居中的几种实现方式\nPosition定位都有哪些\n数组有哪些属性或方法\n\n12345678910111213141516171819202122232425262728293031323334353637383940JavaScript 数组的常用属性和方法包括：属性:length方法:concat()copyWithin()entries()every()fill()filter()find()findIndex()flat()flatMap()forEach()includes()indexOf()isArray()join()keys()lastIndexOf()map()pop()push()reduce()reduceRight()reverse()shift()slice()some()sort()splice()toLocaleString()toString()unshift()values()这些是JavaScript数组对象中最常用的属性和方法。\n\n\nObject有哪些属性和方法\n\n1234567891011121314151617181920212223242526属性:prototype方法:assign()create()defineProperties()defineProperty()entries()freeze()fromEntries()getOwnPropertyDescriptor()getOwnPropertyDescriptors()getOwnPropertyNames()getOwnPropertySymbols()getPrototypeOf()is()isExtensible()isFrozen()isSealed()keys()preventExtensions()seal()setPrototypeOf()values()\n\n\n介绍一下Promise\n\nwebpack有哪些hash类型\n\n\n123456在 Webpack 中，常用的哈希(hash)类型有以下几种：hash - 模块标识符的哈希值，对整个项目构建有效。chunkhash - 依赖于 chunk 的内容。contenthash - 依赖于文件内容，适用于样式文件等。这些哈希类型在 Webpack 的配置中经常用于缓存管理和文件版本控制。\n\n\ntype和interface的区别\n\nvue的key有啥作用\n\nvue的data为啥是函数而不是对象\n\nVue 2 和 Vue 3的区别\n\n1234567891011121314151617181920212223242526272829303132Vue 2 和 Vue 3 在多个方面有显著区别，以下是一些主要差异：组合式 API:Vue 3 引入了组合式 API (setup 函数、ref、reactive 等)，提供更灵活的组件逻辑复用方式。Vue 2 主要使用选项式 API（data、methods、computed 等）。性能改进:Vue 3 提供了更好的性能，包括更小的打包大小和更快的渲染速度。这得益于 Vue 3 的虚拟 DOM 重写和树摇(tree-shaking)支持。Composition API vs Options API:Vue 3 的 Composition API 使得逻辑重用和代码组织更加灵活。Vue 2 的 Options API 在组件变得复杂时，相关功能的代码可能会分散在不同的选项中。响应式系统:Vue 3 使用了基于 Proxy 的响应式系统，这带来了更好的性能和更丰富的功能。Vue 2 使用了基于 Object.defineProperty 的响应式系统。TypeScript 支持:Vue 3 从一开始就以 TypeScript 编写，提供更好的 TypeScript 支持。Vue 2 的 TypeScript 支持是后来添加的，不如 Vue 3 紧密集成。新的生命周期钩子:Vue 3 引入了新的生命周期钩子，如 onMounted、onUpdated 等，与组合式 API 结合使用。模板特性和改进:Vue 3 引入了一些新的模板特性，如 Fragment、Teleport、Suspense 等。全局 API 和应用实例:Vue 3 引入了应用实例 (createApp)，减少了全局 API 的使用，使得多个 Vue 应用能更容易共存。这些变化使 Vue 3 更加灵活和强大，同时保留了 Vue 的核心特性，如易用性和轻量级。对于新项目，Vue 3 是一个更好的选择，但 Vue 2 仍然是一个稳定且功能丰富的选择。\n\n\nre f和reactive的区别\n\n12.常见的请求头\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811.AcceptAccept: text/html 浏览器可以接受服务器回发的类型为 text/html。Accept: */* 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。2.Accept-EncodingAccept-Encoding: gzip, deflate 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。3.Accept-LanguageAccept-Language:zh-CN,zh;q=0.9 浏览器申明自己接收的语言。4.ConnectionConnection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。5.Host（发送请求时，该报头域是必需的）Host:www.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。6.RefererReferer:https://www.baidu.com/?tn=62095104_8_oem_dg 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。7.User-AgentUser-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。8.Cache-ControlCache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享Cache-Control:public 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.Cache-Control:must-revalidate 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。Cache-Control:no-cache 响应不会被缓存,而是实时向服务器端请求资源。Cache-Control:max-age=10 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。Cache-Control:no-store 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。9.CookieCookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。10.Range（用于断点续传）Range:bytes=0-5 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。二、常用的http响应头1.Cache-Control（对应请求中的Cache-Control）Cache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享Cache-Control:public 浏览器和缓存服务器都可以缓存页面信息。Cache-Control:must-revalidate 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。Cache-Control:no-cache 浏览器和缓存服务器都不应该缓存页面信息。Cache-Control:max-age=10 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。Cache-Control:no-store 请求和响应的信息都不应该被存储在对方的磁盘系统中。2.Content-TypeContent-Type：text/html;charset=UTF-8 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。3.Content-EncodingContent-Encoding:gzip 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。4.DateDate: Tue, 03 Apr 2018 03:52:28 GMT 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。5.ServerServer：Tengine/1.4.6 这个是服务器和相对应的版本，只是告诉客户端服务器信息。6.Transfer-EncodingTransfer-Encoding：chunked 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。7.ExpiresExpires:Sun, 1 Jan 2000 01:00:00 GMT 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。8.Last-ModifiedLast-Modified: Dec, 26 Dec 2015 17:30:00 GMT 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)9.ConnectionConnection：keep-alive 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。10.EtagETag: &quot;737060cd8c284d8af7ad3082f209582d&quot; 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。11.RefreshRefresh: 5; url=http://baidu.com 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。12.Access-Control-Allow-OriginAccess-Control-Allow-Origin: *号代表所有网站可以跨域资源共享，如果当前字段为那么Access-Control-Allow-Credentials就不能为trueAccess-Control-Allow-Origin: www.baidu.com 指定哪些网站可以跨域资源共享13.Access-Control-Allow-MethodsAccess-Control-Allow-Methods：GET,POST,PUT,DELETE 允许哪些方法来访问14.Access-Control-Allow-CredentialsAccess-Control-Allow-Credentials: true 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true15.Content-RangeContent-Range: bytes 0-5/7877 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。\n\n\n\n","slug":"面试题/6.智联招聘一面和二面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"781e89f9c8e6c0119b401876874dff73","title":"javascript面试题整理","content":"\njs事件循环机制\n\n12345678910111213141516171819202122在 js 中任务会分为同步任务和异步任务。如果是同步任务，则会在主线程（也就是 js 引擎线程）上进行执行，形成一个执行栈。但是一旦遇到异步任务，则会将这些异步任务交给异步模块去处理，然后主线程继续执行后面的同步代码。当异步任务有了运行结果以后，就会在任务队列里面放置一个事件，这个任务队列由事件触发线程来进行管理。一旦执行栈中所有的同步任务执行完毕，就代表着当前的主线程（js 引擎线程）空闲了，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。在 js 中，任务队列中的任务又可以被分为 2 种类型：宏任务（macrotask）与微任务（microtask）但这两种分类已经无法满足现如今复杂的浏览器环境了，所以后续舍弃了宏任务，用一种更加灵活的方式取代了它。根据W3C的官方解释，每个任务都有不同的类型，同类型的任务必须在一个队列，不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列任务的优先级仅次于主线程，必须先调度执行，其次是延时队列（主要用来处理延时器setTimeOut），最后是交互队列（处理与用户的交互，如点击事件等）。所以任务的优先级为：微队列 &gt; 延时队列 &gt; 交互队列\n\n\n那说说哪些属于微队列、延时队列、交互队列分别有哪些任务呢？\n\n微队列任务：\n\nPromise.then();（Promise是同步的，then方法是微任务）\nasync&#x2F;await\nObject.observe\nMutationObserver\nprocess.nextTick(Node.js 环境)\n\n延时任务队列：\n\nsetTimeout\n\n交互队列：\n\n各种事件回调\n\n\nlet&#x2F;const&#x2F;var 的区别是什么？\n\nvar 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问，有变量提升。 let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明。 const 用来定义常量，使用时必须初始化（即必须赋值），只能在块作用域里访问，而且不能修改，无变量提升（对象和数组依然修改其中的属性，但不建议这么用），不可以重复声明。\n\n什么是防抖和节流\n\n123456我们在平时开发的时候，会有很多场景会频繁触发事件，比如说搜索框实时发请求，onmousemove、resize、onscroll 等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和函数节流。函数防抖(debounce)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。函数节流(throttle)，指连续触发事件但是在 n 秒中只执行一次函数。即 2n 秒内执行 2 次... 。节流如字面意思，会稀释函数的执行频率。\n\n\n那具体如何实现防抖和节流呢？\n\n**防抖实现：**\n1234567891011121314function debounce(func, wait)&#123;    // 设置变量，记录 setTimeout 得到的 id    let timerId = null;    return function(...args)&#123;        if(timerId)&#123;            // 如果有值，说明目前正在等待中，清除它            clearTimeout(timerId);        &#125;        // 重新开始计时        timerId = setTimeout(() =&gt; &#123;            func(...args);        &#125;, wait);    &#125;&#125;\n\n节流实现：\n12345678910111213function throttle(func, wait)&#123;    let context, args;    let previous = 0;    return function ()&#123;        let now = +new Date();        context = this;        args = arguments;        if (now - previous &gt; wait)&#123;            func.apply(context, args);            previous = now;        &#125;    &#125;&#125;\n\n\n介绍下Set、Map、WeakSet、WeakMap 的区别\n\n参考答案：Set\n\n成员唯一、无序且不重复\n键值与键名是一致的（或者说只有键值，没有键名）\n可以遍历，方法有 add, delete,has\n\nWeakSet\n\n成员都是对象\n成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏\n不能遍历，方法有 add, delete,has\n\nMap\n\n本质上是健值对的集合，类似集合\n可以遍历，方法很多，可以跟各种数据格式转换\n\nWeakMap\n\n只接受对象作为健名（null 除外），不接受其他类型的值作为键名\n键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾机制回收，此时键名是无效的\n不能遍历，方法有 get、set、has、delete\n\n\n断点续传怎么做的\n\n答：断点续传是一种网络传输技术，可以在文件传输中出现中断后恢复传输而无需重新开始传输整个文件。这在文件传输较大、网络不稳定、带宽有限等情况下尤为重要。 通常情况下，实现断点续传需要客户端和服务端的相互配合。\n以下是一般的实现步骤：\n客户端发起文件上传请求时，向服务端发送一个 HTTP 请求，包含文件名、文件大小等信息。服务端接收到请求后，根据文件名和文件大小创建一个空文件，并返回已经上传的文件大小，如果之前有部分数据已经上传过，那么服务端可以根据已上传的大小确定从哪个位置开始上传。客户端接收到服务端返回的已经上传的文件大小后，可以根据已上传的大小计算出下一次应该从哪个位置开始上传。客户端将文件切分为多个小块，每个小块的大小一般为几十 KB 或几百 KB，将每个小块的数据上传到服务端，并在每个小块的末尾添加一个分界符，标记上传结束。服务端接收到每个小块后，将其存储到文件对应的位置，等待下一次上传。如果上传过程中出现中断，客户端可以记录已经上传的文件大小和已经上传的小块数，下次上传时从上一次中断的位置开始继续上传。总的来说，断点续传的实现需要客户端和服务端的相互配合，并需要考虑文件上传的稳定性和可靠性。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*秒传怎么实现？*\n\n答：秒传是指上传一个文件时，如果已经存在相同的文件，就直接使用已经存在的文件，而不需要重新上传。实现秒传需要用到文件的唯一标识。\n一种常见的实现方式是在上传文件时，先计算文件的哈希值或者MD5值，并将其作为文件的唯一标识。然后将该标识与后台数据库中已经存在的文件的标识进行比对。\n如果存在相同的标识，说明该文件已经上传过，那么就直接使用已经存在的文件；\n如果不存在相同的标识，说明该文件是一个新文件，那么就进行正常的上传操作。\n在实现过程中，可以通过在前端计算文件哈希值或MD5值的方式，避免上传重复的文件，减少服务器的压力，提高文件上传的效率。\n同时，后台服务器也需要维护一个文件信息的数据库，用于存储已经上传过的文件的唯一标识和存储路径等信息，以便实现秒传功能。\n需要注意的是，文件的唯一标识需要具备唯一性和不可修改性，否则就无法实现秒传功能。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*var let const 块级作用域。*\n\n答：在 JavaScript 中，var、let、const 都是声明变量的关键字，它们在作用域、赋值和重复声明方面有所不同。\nvar 声明变量的作用域是函数级别的，不受块级作用域的限制。在全局作用域中声明的变量会成为全局对象的属性。let 声明的变量是块级作用域的，只在声明的块内有效。在 for 循环中，每次迭代都会创建一个新的变量。const 声明的变量也是块级作用域的，和 let 类似，但是其值不能被重新赋值，只能被赋值一次。在开发中，尽可能地使用 let 和 const 来代替 var，避免变量提升和重复声明的问题，以及更好地控制变量作用域，提高代码的可读性和可维护性。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*promise用过那些api？*\n\n答：在 JavaScript 中，Promise 是一种用于处理异步操作的对象。\n它有一些常见的方法可以用来操作和处理异步操作：\nthen()：指定 Promise 成功(resolve)和失败(reject)时的回调函数，接受两个参数，一个是成功时的回调函数，一个是失败时的回调函数。catch()：指定 Promise 拒绝(reject)时的回调函数，接收一个参数，即拒绝时的回调函数。finally()：无论 Promise 成功还是失败，都会执行的回调函数，没有参数。all()：接收一个 Promise 数组，返回一个新的 Promise，当所有 Promise 都成功(resolve)时，返回值为数组，包含所有 Promise 成功时的结果；当其中任何一个 Promise 失败(reject)时，返回值为失败的 Promise 的值。race()：接收一个 Promise 数组，返回一个新的 Promise，当其中任何一个 Promise 成功(resolve)或失败(reject)时，返回值为该 Promise 的值。除了上述方法外，Promise 还有一些静态方法，例如：\nPromise.resolve()：返回一个解决(resolve)的 Promise 对象，可以指定解决的值。Promise.reject()：返回一个拒绝(reject)的 Promise 对象，可以指定拒绝的原因。Promise.allSettled()：接收一个 Promise 数组，返回一个新的 Promise，当所有 Promise 都结束时，返回值为数组，包含所有 Promise 的状态和值。Promise.any()：接收一个 Promise 数组，返回一个新的 Promise，当其中任何一个 Promise 成功(resolve)时，返回值为成功的 Promise 的值；当所有 Promise 失败(reject)时，返回值为失败的 Promise 的值。以上是 Promise 常见的方法和静态方法，可以用来管理异步操作的状态和结果。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*、Map和Object的区别。*\n\n答：在 JavaScript 中，Map 和 Object 都可以用来存储键值对。但是它们之间有几个关键的区别。 键的类型：Map 中的键可以是任意类型，包括原始类型和对象引用，而 Object 的键必须是字符串或者 Symbol 类型。\n插入顺序：Map 保留了插入顺序，因此在迭代 Map 时会按照插入顺序返回元素，而 Object 不保留插入顺序。大小：Map 可以使用 size 属性来获取元素的数量，而 Object 只能手动计算属性的数量。迭代：Map 支持 for-of 循环和 forEach 方法来迭代元素，而 Object 只能使用 for-in 循环来迭代属性，但是需要手动判断是否是自身属性而不是继承属性。性能：在非常大的数据集合下，Map 的查找和插入操作通常比 Object 更快。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\nvue2和vue3的双向绑定原理。\n答：在vue2中：使用Object.defineProperty对象以及对象属性的劫持+发布订阅模式，只要数据发生变化直接通知变化 并驱动视图更新。\n\n\n在vue3中的响应式采用了ES6中的 Proxy 方法。Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）\n详情参考： vue2和vue3的双向绑定原理_vue2和vue3双向绑定_m0_73464874的博客-CSDN博客————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*如何封装组件？*\n\n如何封装组件？答：封装组件是前端开发中一个非常常见的任务，\n以下是一些封装组件的方法：\n定义组件API：在设计组件时，首先需要考虑它的使用方式。定义组件API有助于其他开发人员快速理解如何使用组件，并确保组件在不同情况下具有一致的行为。使用props传递数据：在Vue中，组件通过props属性接收父组件传递的数据。在定义组件时，可以指定props属性的类型、默认值和必需性等。使用slot插槽分发内容：插槽是Vue中一种非常有用的功能，它可以允许组件的使用者插入内容到组件中。通过使用插槽，可以增加组件的灵活性，允许组件的使用者在不同的情况下自由地定制组件的外观和行为。使用事件向外通信：组件通常需要与外部环境进行交互。Vue中通过使用自定义事件可以实现组件向外部环境通信的功能。通过定义事件并在组件中触发该事件，可以允许外部环境对组件进行操作。使用mixins实现代码复用：Vue中提供了mixins功能，可以将一个或多个属性和方法混合到组件中。通过使用mixins，可以将常用的功能提取到可重用的模块中，减少代码的重复性。使用插件扩展Vue：Vue插件是一种可以扩展Vue功能的机制。通过编写插件，可以为Vue添加全局功能、指令、过滤器等。使用插件可以提高开发效率，减少代码量。使用动态组件：Vue中提供了动态组件的功能。通过使用动态组件，可以允许组件的使用者在运行时根据不同的条件选择不同的组件。以上是一些封装组件的方法，当然具体的实现方式还需要根据具体的业务场景和组件功能来进行选择。————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n*实现栈，有入栈出栈的方法，以及length属性。*\n\n答：栈是一种数据结构，它是一种线性的、具有一定特殊限制的数据结构，只能在一端进行插入和删除操作。栈的特点是后进先出，即最后压入的元素最先弹出。\nclass Stack{    constructor() { this.items &#x3D; []; }                   &#x2F;&#x2F; 入栈    push(element) { this.items.push(element); }          &#x2F;&#x2F; 出栈    pop() { return this.items.pop(); }                   &#x2F;&#x2F; 返回栈顶元素    peek() { return this.items[this.items.length - 1]; } &#x2F;&#x2F; 判断栈是否为空    isEmpty() { return this.items.length &#x3D;&#x3D; &#x3D; 0; }       &#x2F;&#x2F; 返回栈的长度    get length() { return this.items.length; }}在这个栈实现中，我们使用了 push 方法来进行入栈操作，pop 方法来进行出栈操作，peek 方法来返回栈顶元素，isEmpty 方法来判断栈是否为空，length 属性来返回栈的长度。 使用这个栈实现的例子： \nconst myStack &#x3D; new Stack();myStack.push(1);myStack.push(2);myStack.push(3);console.log(myStack.length);    &#x2F;&#x2F; 3console.log(myStack.peek());    &#x2F;&#x2F; 3console.log(myStack.pop());     &#x2F;&#x2F; 3console.log(myStack.pop());     &#x2F;&#x2F; 2console.log(myStack.length);    &#x2F;&#x2F; 1console.log(myStack.isEmpty()); &#x2F;&#x2F; false\n————————————————版权声明：本文为CSDN博主「suoh’s Blog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41579104/article/details/131235631\n\n虚拟dom是什么? 原理? 优缺点?\n\n","slug":"面试题/javascript面试题整理","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"1b126a749ab446fe1b61b88b411b0563","title":"7.汉迪移动","content":"\nvue和react有什么区别\n\n\n\n","slug":"面试题/7.汉迪移动","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"c6acbc48be12d4651df481a8d172d54a","title":"vue面试题复习","content":"\nVue模版引擎\n\nVue会根据其规定的模板语法规则，将其解析成AST语法树（其实就是用一个树状的大对象来描述我们所谓的“HTML”）；然后会对这个大对象进行一些初步处理，比如标记没有动态绑定值的节点；最后，会把这个大对象编译成render函数，并将它绑定在组件的实例上。这样，我们所认为的“HTML”就变成了JavaScript代码，可以基于JavaScript模块规则进行导入导出，在需要渲染组件的地方，就调用render函数，根据组件当前的状态生成虚拟dom，然后就可以根据这个虚拟dom去更新视图了。————————————————版权声明：本文为CSDN博主「Yaalon Cui」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_42482733/article/details/111502669\n\nAxios如何中断请求\n\nXMLHttpRequest.abort()   方法用于终止 XMLHttpRequest 对象的请求，该方法没有参数，也没有返回值。\n1234567891011121314151617181920// axios 0.22.0版本之前// 创建一个CancelToken对象： const source = axios.CancelToken.source();// 将CancelToken对象传递给请求的config中：axios.get(&#x27;/api/data&#x27;, &#123;  cancelToken: source.token&#125;).then(response =&gt; &#123;  console.log(response.data);&#125;).catch(error =&gt; &#123;  if (axios.isCancel(error)) &#123;    console.log(&#x27;请求已被取消：&#x27;, error.message);  &#125; else &#123;    console.log(&#x27;请求出错：&#x27;, error.message);  &#125;&#125;);// 在需要中断请求的地方，调用cancel方法：source.cancel(&#x27;请求被用户取消&#x27;);————————————————版权声明：本文为CSDN博主「ATalk机器人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/liyananweb/article/details/130334371\n\n12345678910111213141516171819202122232425262728293031// 0.22之后的版本// 创建请求控制器 this.controller = new AbortController();console.log(&quot;初始声明的请求控制器------&quot;, this.controller);// 第一种方法：绑定事件处理程序this.controller.signal.addEventListener(&quot;abort&quot;, () =&gt; &#123;   console.log(&quot;请求已终止，触发了onabort事件&quot;);   // 进行后续处理&#125;);// 第二种方法：try...catchtry &#123;    // 发送文件上传请求    const res = await this.$axios.post(api.Upload, uploadData, &#123;     timeout: 0, // 设置超时时间为 0/null 表示永不超时     signal: this.controller.signal, // 绑定取消请求的信号量\t&#125;);&#125; catch (error) &#123;    console.log(&quot;终止请求时catch的error---&quot;, error);    // 判断是否为取消上传    if (error.message == &quot;canceled&quot;)&#123;        // 进行后续处理    &#125;;&#125;// 终止请求this.controller.abort();————————————————版权声明：本文为CSDN博主「努力的小朱同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_45092437/article/details/131211952\n\n\nvue组件的设计原则\n\n单一职责原则、扩展性、通用性、可配置性、可测试的单元、幂等性\n\nVue中data和methods的方法名可以重复吗？\n\n可以重复，但是重名的话只会执行data里的，不会执行methods的\n\nslot是什么，有哪些类型\n\n插槽、默认插槽、具名插槽、作用域插槽\n\nvue如何检测路由改变\n\n1234567891011121314151617181920212223242526272829303132331. 组件内watch监听$router2. router.beforeEach((to, from, next) =&gt; &#123;&#125;) 全局路由守卫3. 路由独享的守卫 const router = new VueRouter(&#123;  routes: [    &#123;      path: &#x27;/foo&#x27;,      component: Foo,      beforeEnter: (to, from, next) =&gt; &#123;        // ...      &#125;    &#125;  ]4. 组件内的守卫(组件内钩子) beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当钩子执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`   &#125;————————————————版权声明：本文为CSDN博主「笑魇轻轻」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_45259626/article/details/106076863\n\n\nVue-loader是什么\n\n  简单的说，他就是基于webpack的一个的loader，解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理，核心的作用，就是提取，划重点。\n","slug":"面试题/vue面试题复习","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"125d4282561b985e7f89533fd43b5b20","title":"react面试题","content":"\nFiber的理解\n\nFiber 是一种数据结构，支撑 Fiber 构建任务的运转。\n当某一个 Fiber 任务执行完成后，怎样去找下一个要执行的 Fiber 任务呢？\nReact 通过链表结构找到下一个要执行的任务单元。\n要构建链表结构，需要知道每一个节点的父级节点是谁，要知道他的子级节点是谁，要知道他的下一个兄弟节点是谁。\nFiber 其实就是 JavaScript 对象，是虚拟dom的增强版本，存储的信息比虚拟dom多。在这个对象中有 child 属性表示节点的子节点，有 sibling 属性表示节点的下一个兄弟节点，有 return 属性表示节点的父级节点。\n12345678910111213type Fiber = &#123;  // type：组件类型。 div、span、组件构造函数  type: any,  // DOM 对象  stateNode: any,  // 指向自己的父级 Fiber 对象  return: Fiber | null,  // 指向自己的第一个子级 Fiber 对象  child: Fiber | null,  // 指向自己的下一个兄弟 iber 对象  sibling: Fiber | null,&#125;;123456789101112\n\n\nFiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个”执行单元”，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。\n即是实现了”增量渲染”，实现了可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点。\n实现的方式是requestIdleCallback这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。\n\n\n\n\n\n\n\n\n\nwindow.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。\nrequestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。\n即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。\n简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。\nReact 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。\n作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件等等）、对应的 DOM 节点等信息。\n作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。\n每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性：\n123456// 指向父级Fiber节点this.return = null// 指向子Fiber节点this.child = null// 指向右边第一个兄弟Fiber节点this.sibling = null","slug":"面试题/react面试题","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"a8813826449979feb1532bc7da9f4047","title":"Sequelize-typescript","content":"定义一个模型12345678910111213141516171819202122232425262728import * as path from &#x27;path&#x27;;import &#123; Table, Column, Model &#125; from &#x27;sequelize-typescript&#x27;var sequelize = require(&#x27;../lib/sequelize&#x27;)@Table(&#123;  tableName: &#x27;friends&#x27;,  timestamps: true&#125;)export default class Friends extends Model&lt;Friends&gt; &#123;  @Column(&#123;    primaryKey: true,    allowNull: false,    unique: true,    autoIncrement: true  &#125;)  id: number  @Column  uid: number  @Column  fUid: number&#125;  sequelize.addModels([path.resolve(__dirname, `./friends.ts`)])\n\nAPI@ForeignKey这个还是比较明显的,需要外联的key,用在源模型中。参数是目标模型。\n1@ForeignKey(() =&gt; Team)\n\n@BelongsTo创建源模型到目标模型的关系。可以传1到2个参数,第一个参数是目标模型,第二个参数是源模型的外联key,第二个参数也可以传一个对象,如:\n1234@BelongsTo(() =&gt; Team)// 传入teamName作为源模型的外联key,默认目标模型对应的外联key为目标模型的主键@BelongsTo(() =&gt; Team, &#x27;teamName&#x27;)\n\n@HasOne &#x2F; @hasMany &#x2F; @BelongsToMany不太好用就不介绍了-_-\n\n\n\n\n\n\n\n\n\n又研究了下发现@ForeignKey可以不使用,改为放在@BelongsTo里,见如下示例\n示例:player.ts\n12345678910111213141516171819202122232425262728export default class Player extends Model&lt;Player&gt; &#123;  @Column  teamName: string;  @Column  gameName: string;  @Column  teamId: number;  // 传入targetKey指定目标模型的外联key  @BelongsTo(() =&gt; Team, &#123; foreignKey: &#x27;teamName&#x27;, targetKey: &#x27;tname&#x27; &#125;)  team: Team;  // 关联其他模型  @BelongsTo(() =&gt; Game, &#123; foreignKey: &#x27;gameName&#x27;, targetKey: &#x27;gname&#x27; &#125;)  game: Game;  static async findData() &#123;    return this.findOne(&#123;      include: [&#123;        model: Team,        // 获取目标模型某些key        attributes: [&#x27;type&#x27;],     &#125;],      raw: true,    &#125;)  &#125;&#125;\n\nteam.ts\n12345678@Table(&#123;  tableName: &#x27;team&#x27;&#125;)export default class Team extends Model&lt;Team&gt; &#123;  @Column  tname: string;&#125;\n\ngame.ts\n12345678@Table(&#123;  tableName: &#x27;game&#x27;&#125;)export default class Game extends Model&lt;Game&gt; &#123;  @Column  gname: string;&#125;\n\n常见问题1Error: Game is not associated to Player\n\n处理: 目标模型没有与源模型相关联,是@BelongsTo下缺少team: Team\n1Error: Foreign key for &quot;Game&quot; is missing on &quot;Player&quot;\n\n处理: 缺少foreignKey,可以在源模型的key上添加@ForeignKey,或者在@BelongsTo第二个参数里添加foreignKey对象\n","slug":"nodejs/Sequelize/Sequelize-typescript","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Sequelize","author_index":"MessageWall"},{"id":"ff590af8a3e15078ecfbc463aea307fc","title":"方法","content":"Sequelize的相关方法查询相关的方法\nfindOne - 查询一条数据\n\nfindAll - 查询多条数据\n\ncount - 查询数据条数\n\n\n参数\nwhere\n\n","slug":"nodejs/Sequelize/方法","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Sequelize","author_index":"MessageWall"},{"id":"1165eaf05b864098a8be158dfcace9b9","title":"Node Web开发ORM框架 Sequelize","content":"Node Web开发ORM框架 Sequelize一、什么是 ORM？首先看下维基百科上的定义，ORM 是「对象关系映射」的翻译，英语全称为Object Relational Mapping，它是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的「虚拟对象数据库」。\n随着面向对象软件开发方法的发展，ORM 的概念应运而生，它用来把对象模型表示的对象，映射到基于 SQL 的关系模型数据库结构中去。这样，我们在具体的操作实体数据库的时候，就不需要再去和复杂的 SQL 语句打交道，只需简单的操作实体对象的属性和方法，就可以达到操作数据库的效果。\nORM 技术是在对象和数据库之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化。\n不同的编程语言，有不同的ORM框架。例如Java，它的ORM框架就有：Hibernate，Ibatis&#x2F;Mybatis等等。在Node Web开发中，Sequelize 就是一款比较流行的 ORM 框架。\n二、Sequelize 初步使用在 Node Web 开发过程中，后台数据库我一直使用的都是 Mysql。起初在做 Node Web 开发的时候，都是提前在 Mysql 图形界面里创建好数据表，然后再开始实际开发，这个过程一直穿插在整个项目的开发过程中。一个人在一台机器上，做全栈的开发，这个过程可能并不会出现什么问题，因为数据表结构以及整个项目代码都在一台电脑上，不管你怎么修改，都是一套代码，一个数据库结构。\n然而，当你需要在多台电脑之间协同工作的时候，你就会发现这种方式的弊端。比如在A电脑上修改了数据表结构之后，接着去B电脑上继续编码，我们虽然能通过Git同步代码，但是数据表结构却无法同步过去，我们就需要在B电脑上，手动将数据库结构维护成一致，否则无法接着进行。这种操作方式非常的不方便，而且很LOW。\n而 Sequelize 框架就能很好的解决这个问题，通过 Sequelize 框架，我们将每个数据表直接定义为数据模型，通过调用数据模型的一些方法，就可以直接操作数据库，甚至是同步数据表结构。好了，废话不多说了，直接上手实战。\n\n\n\n\n\n\n\n\n\nPS. 下面我会介绍，我在实际开发中的一些实用技巧，而不会逐条介绍增删改查的使用。所以增删改查的基本使用，建议直接查看官方文档。\n1. 创建连接对象，并模块化新建数据库连接模块dbConn.js，单独提出连接数据库的对象sequelize，如下代码：\n12345678910111213141516171819var Sequelize = require(&#x27;sequelize&#x27;);// 数据库配置文件var sqlConfig = &#123;    host: &quot;localhost&quot;,    user: &quot;root&quot;,    password: &quot;Lupeng1&quot;,    database: &quot;example-sequelize&quot;&#125;;var sequelize = new Sequelize(sqlConfig.database, sqlConfig.user, sqlConfig.password, &#123;    host: sqlConfig.host,    dialect: &#x27;mysql&#x27;,    pool: &#123;        max: 10,        min: 0,        idle: 10000    &#125;&#125;);module.exports = sequelize;\n\n我们根据数据库的一些参数，创建了sequelize数据库连接模块，并对外引用。\n2. 定义数据表结构，将表结构写进代码里建议每个表对应一个文档，放入项目的单独目录下，例如我通常放进了/db/models下，这里拿我创建的一个todolist表来做示例，在models目录中创建todolist.js文件，代码如下：\n12345678910111213141516171819202122232425262728293031var Sequelize = require(&#x27;sequelize&#x27;);var sequelize = require(&#x27;./dbConn.js&#x27;);var todolist = sequelize.define(&#x27;todolist&#x27;,&#123;    id: &#123;        type: Sequelize.BIGINT(11),        primaryKey: true,        allowNull: false,        unique: true,        autoIncrement: true    &#125;,    title: Sequelize.STRING(100),          // 标题    content: Sequelize.STRING(500),        // 详细内容    priority: Sequelize.INTEGER,          // 级别    owner: Sequelize.STRING,              // 承接人    officer: Sequelize.STRING,             // 负责人    startDate: Sequelize.STRING,         // 开始时间    planFinishDate: Sequelize.STRING,     // 计划完成时间    realFinishDate: Sequelize.STRING,     // 实际完成时间    bz: Sequelize.STRING(500),               // 备注    state: Sequelize.INTEGER,            // 状态    createdAt: Sequelize.BIGINT,    updatedAt: Sequelize.BIGINT,    createUser: Sequelize.STRING,    updateUser: Sequelize.STRING,    version: Sequelize.BIGINT&#125;,&#123;    timestamps: false               // 不要默认时间戳&#125;);module.exports = todolist;\n\n以上代码，直接引入之前创建的sequelize对象，然后使用defind方法定义数据表结构。其他的所有数据表都可以通过这种方式来定义，保存在每一个独立的文件中，引出数据模模型即可。\n3. 同步数据表结构这个就简单了，在/db目录下，新建syncTable.js，代码如下：\n123456var todolist = require(&#x27;./models/todolist.js&#x27;);// 同步表结构todolist.sync(&#123;    force: true  // 强制同步，先删除表，然后新建&#125;);\n\n当我们换台电脑继续项目的时候，不用手动去同步数据表结构了，只需要执行一下该文件就可以了。\n1node db/syncTable.js\n\n4. 创建一些初始数据我们同样可以创建一个方法，用来初始化一些基础数据，如下initData.js代码：\n12345678910var priority = require(&#x27;./models/priority.js&#x27;);// 创建u_priority表的基础数据priority.create(&#123;    title: &#x27;重要 紧急&#x27;&#125;).then(function (p) &#123;    console.log(&#x27;created. &#x27; + JSON.stringify(p));&#125;).catch(function (err) &#123;    console.log(&#x27;failed: &#x27; + err);&#125;);...\n\n给prioritys表里创建一些初始数据，默认表名会添加s，定义表的时候可以通过tableName属性值来定义对应的表名，如下示例将表名定义为u_priority：\n123456789101112var priority = sequelize.define(&#x27;priority&#x27;,&#123;    id: &#123;        type: Sequelize.BIGINT(11),        primaryKey: true,        allowNull: false,        autoIncrement: true    &#125;,    title: Sequelize.STRING,&#125;,&#123;    timestamps: false,    tableName: &#x27;u_priority&#x27;  // 数据表名为u_priority&#125;);\n\nSequelize 的初步使用，就介绍到这里。接下来，通过实际项目示例，再深入了解一下 Sequelize 的其他功效。\n三、实际项目示例1. 协同开发规范实际项目中，直接面临的一个问题就是协同规范的问题，例如，数据表名命名的规则，是采用默认方案，直接在后面加s，变成prioritys，还是改成u_priority；还有，每个表是否要加时间戳，或者其他一些通用字段。\n如果没有规范，那么同一个项目中，数据表的形式就会百花齐放了，这是个人开发习惯问题，并不是错误。所以，当在做协同开发的时候，我们非常有必要定义一个标准接口，大家通过统一的标准调用方法建立模型，这样就形成一种内部规范。我们把所有需要规范的内容，全部封装在一个对象里，例如我们这样改写dbConn.js文件。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var Sequelize = require(&#x27;sequelize&#x27;);// 数据库配置文件var sqlConfig = &#123;    host: &quot;localhost&quot;,    user: &quot;root&quot;,    password: &quot;Lupeng1&quot;,    database: &quot;example-sequelize&quot;&#125;;console.log(&#x27;init sequelize...&#x27;);console.log(&#x27;mysql: &#x27; + JSON.stringify(sqlConfig));var sequelize = new Sequelize(sqlConfig.database, sqlConfig.user, sqlConfig.password, &#123;    host: sqlConfig.host,    dialect: &#x27;mysql&#x27;,    pool: &#123;        max: 10,        min: 0,        idle: 10000    &#125;,    timezone: &#x27;+08:00&#x27; //东八时区&#125;);exports.sequelize = sequelize;exports.defineModel = function (name, attributes) &#123;    var attrs = &#123;&#125;;    for (let key in attributes) &#123;        let value = attributes[key];        if (typeof value === &#x27;object&#x27; &amp;&amp; value[&#x27;type&#x27;]) &#123;            value.allowNull = value.allowNull || false;            attrs[key] = value;        &#125; else &#123;            attrs[key] = &#123;                type: value,                // allowNull: false            &#125;;        &#125;    &#125;    attrs.version = &#123;        type: Sequelize.BIGINT,        // allowNull: false    &#125;;    attrs.createUser = &#123;        type: Sequelize.STRING,        allowNull: false    &#125;;    attrs.updateUser = &#123;        type: Sequelize.STRING,        allowNull: false    &#125;;    return sequelize.define(name, attrs, &#123;        tableName: name,        timestamps: true,        paranoid: true,         charset: &#x27;utf8mb4&#x27;,         collate: &#x27;utf8mb4_general_ci&#x27;,        hooks: &#123;            beforeBulkCreate: function(obj)&#123;                obj.version = 0 ;            &#125;,            beforeValidate: function(obj)&#123;                if(obj.isNewRecord)&#123;                    console.log(&#x27;first&#x27;);                    obj.version = 0 ;                 &#125;else&#123;                    console.log(&#x27;not first&#x27;);                    obj.version = obj.version + 1 ;                &#125;            &#125;        &#125;    &#125;);&#125;;\n\n我们在dbConn.js中，定义了defineModel方法，这个方法中，我们规范了，每个模型都要添加version、createUser以及updateUser三个字段、表名即为模型名，以及数据的字符集为utf8mb4等等。那么，当我们要创建模型的时候，通过调用defineModel方法就可以达到统一规范的效果。如下模型代码：\n12345678910111213141516171819202122var Sequelize = require(&#x27;sequelize&#x27;);var db = require(&#x27;../dbConn.js&#x27;);module.exports = db.defineModel(&#x27;project_master&#x27;, &#123;    p_id: &#123;        type: Sequelize.BIGINT(11),        primaryKey: true,        allowNull: false,        autoIncrement: true    &#125;,    p_name: Sequelize.STRING(100),    p_academy: Sequelize.STRING(100),    p_start_date: Sequelize.STRING(10),    p_end_date: Sequelize.STRING(10),    p_days: Sequelize.DECIMAL(10, 1),    p_place: Sequelize.STRING(20),    p_owner: Sequelize.STRING(10),    p_operator: Sequelize.STRING(10),    p_is_fee: Sequelize.BIGINT(1),    p_state: Sequelize.BIGINT(2),  // 开启，关闭    p_bz: Sequelize.STRING(255),&#125;);\n\n这样还有一个好处，那就是在模型定义里，只需要写业务相关的字段，与业务无关的一些通用字段（例如，时间戳等等）就全部放到规范里。业务字段一目了然，显得更加清晰。\n2. 批量同步数据结构上面介绍过，在同步数据结构的时候，我们可以通过sync方法进行同步，这里介绍一种批量同步的方法。正常情况下，我们都会把数据模型放在一个目录下models，于是我们在models目录外，新建一个sync.js文件。\n1234567891011121314var sequelize = require(&#x27;./dbConn.js&#x27;).sequelize;var fs = require(&#x27;fs&#x27;);var files = fs.readdirSync(__dirname + &#x27;/models&#x27;);var js_files = files.filter((f)=&gt;&#123;    return f.endsWith(&#x27;.js&#x27;);&#125;, files);console.log(js_files);module.exports = &#123;&#125;;for (var f of js_files) &#123;    console.log(`import model from file $&#123;f&#125;...`);    var name = f.substring(0, f.length - 3);    module.exports[name] = require(__dirname + &#x27;/models/&#x27; + f);&#125;sequelize.sync();\n\n该方法的本质其实就是自动找出models目录下，所有以js结尾的文件，引入并执行sync()方法。命令行执行node db/sync.js后，效果如下图：\n\n再查看数据库情况，可以发现models目录下的所有模型全部创建成功。\n\n3. 数据表关系结构我们知道数据表的关系有一对一，一对多以及多对多的关系结构。一般 ORM 框架都会提供与之对应的对象方法，当然 Sequelize 也不例外。实战项目，直接上代码说话。新建一个relation.js 文件，用来定义模型之间的关系，代码如下：\n1234567891011121314151617// 项目表var ProjectMaster = require(&#x27;./models/Project-master&#x27;);var ProjectCost = require(&#x27;./models/Project-cost&#x27;);var ProjectState = require(&#x27;./models/Project-state&#x27;);// 费用明细表var TeachFee = require(&#x27;./models/Detail-teach-fee.js&#x27;);ProjectMaster.hasOne(ProjectState, &#123;foreignKey: &#x27;p_id&#x27;, as: &#x27;State&#x27;&#125;);ProjectMaster.hasOne(ProjectCost, &#123;foreignKey: &#x27;p_id&#x27;, as: &#x27;Cost&#x27;&#125;);ProjectMaster.hasMany(TeachFee, &#123;foreignKey: &#x27;p_id&#x27;, as: &#x27;TeachFee&#x27;&#125;);module.exports = &#123;    ProjectMaster: ProjectMaster,    ProjectCost: ProjectCost,    ProjectState: ProjectState,    TeachFee: TeachFee&#125;;\n\n这里介绍一对一，一对多的关系，示例中，ProjectMaster与ProjectCost, ProjectState是一对一的关系，于是我们使用hasOne的方法，并且指定字段p_id为连接外键。而TeachFee是费用明细表，与项目表是一对多的关系，于是使用hasMany的方法，同样指定外键。\n当定义完数据表关系后，我们重新编辑同步数据表方法，因为我们需要使用新定义的关系模型，新建sync2.js文件，代码如下：\n12345678910111213var sequelize = require(&#x27;./dbConn.js&#x27;).sequelize;var relation = require(&#x27;./relation.js&#x27;);module.exports = &#123;  ProjectMaster: relation.ProjectMaster,  ProjectCost: relation.ProjectCost,  ProjectState: relation.ProjectState,  TeachFee: relation.TeachFee&#125;;sequelize.sync(&#123;    force: true      // 强制同步&#125;);\n\n执行node db/sync2.js后，在表结构中，你会发现出现的外键关联关系。上述代码会在ProjectMaster、ProjectCost以及TeachFee模型对应的数据表中，新增了外键关联。如下状态表的情况。\n1234567891011121314151617181920CREATE TABLE `project_state` (  `p_state_id` bigint(11) NOT NULL AUTO_INCREMENT,  `p_id` bigint(11) DEFAULT NULL,  `p_state_teach` bigint(2) DEFAULT NULL,  `p_state_place` bigint(2) DEFAULT NULL,  `p_state_stay` bigint(2) DEFAULT NULL,  `p_state_catering` bigint(2) DEFAULT NULL,  `p_state_goods` bigint(2) DEFAULT NULL,  `p_state_clean` bigint(2) DEFAULT NULL,  `p_state_report` bigint(2) DEFAULT NULL,  `version` bigint(20) DEFAULT NULL,  `createUser` varchar(255) NOT NULL,  `updateUser` varchar(255) NOT NULL,  `createdAt` datetime NOT NULL,  `updatedAt` datetime NOT NULL,  `deletedAt` datetime DEFAULT NULL,  PRIMARY KEY (`p_state_id`),  KEY `p_id` (`p_id`),  CONSTRAINT `project_state_ibfk_1` FOREIGN KEY (`p_id`) REFERENCES `project_master` (`p_id`) ON DELETE SET NULL ON UPDATE CASCADE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n创建完表之后，接下来的问题就是我们如何使用？这里给个建议方案，我们在db目录下，新建一个api的目录，用来存放数据库调用接口。我们把所有对数据库的操作，全部写成方法，供后台路由调用。例如，对项目的查询，删除，修改等等操作，都定义成一个一个的方法。在api目录下，新建projectModel.js文件，用来定义对项目的一些数据库操作。代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var sequelize = require(&#x27;../dbConn.js&#x27;).sequelize;var ProjectMaster = require(&#x27;../relation.js&#x27;).ProjectMaster;var ProjectCost = require(&#x27;../relation.js&#x27;).ProjectCost;var ProjectState = require(&#x27;../relation.js&#x27;).ProjectState;module.exports = &#123;    // 单表：仅更新项目表    updateProject: function(data, id, callback)&#123;        ProjectMaster.update(data ,&#123;where: &#123;p_id: id&#125;&#125;).then(function(p)&#123;            callback();        &#125;);    &#125;    // 双表：查找成本表    getCostList: function(start, end, callback)&#123;        ProjectMaster.findAll(&#123;            include: [&#123;                model: ProjectCost,                as: &#x27;Cost&#x27;,            &#125;],            where: &#123;                p_start_date: &#123;                    $lte: end,                    $gte: start                &#125;            &#125;,            order: [sequelize.literal(&#x27;p_start_date&#x27;)]        &#125;).then(function(p)&#123;            callback(p);        &#125;);    &#125;,    // 双表：添加项目，同时在状态表添加项目状态    addProject: function(data, callback)&#123;        ProjectMaster.create(data).then(function(p)&#123;            var state = ProjectState.build(&#123;                p_state_teach: 1,                p_state_stay: 1,                p_state_catering: 1,                p_state_place: 1,                p_state_goods: 1,                p_state_clean: 1,                p_state_report: 1,                createUser: data.createUser,                updateUser: data.updateUser,            &#125;);            p.setState(state);            callback(p);        &#125;);    &#125;,&#125;;\n\n由于对数据库的操作方法较多，这里用3个示例方法来介绍。\n\n第一个为单表操作，更新项目表。增删改查的一些基本方法，建议查看官方文档；\n第二个为双表联合查询，通过include参数来关联模型，得到的结果中会包含一个Cost对象，包含ProjectCost的模型数据；\n第三个为添加项目的时候，同时添加状态表，这里用到关系模型中的set方法，创建项目主数据表后，通过关联关系，使用set方法自动在State表中insert数据。\n\n","slug":"nodejs/Sequelize/Node Web开发ORM框架 Sequelize","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Sequelize","author_index":"MessageWall"},{"id":"b4ebdb6509523e7ae3421c10b60ef62f","title":"4.八月瓜一面","content":"\nvue模版编译原理\n\nhttps://zhuanlan.zhihu.com/p/621318626\n\njs文档碎片\n\nVue文档碎片是一个容器，用于暂时存放创建的DOM元素。具体来说，在Vue中，当需要添加大量元素时，可以先将这些元素添加到文档碎片中，然后再将文档碎片添加到需要插入的位置，这样可以大大减少DOM操作，提高性能。文档碎片的使用类似于先让元素进入到一个容器中，然后再使用appendChild方法将这个容器添加到需要插入的位置。\n文档碎片可以提高DOM操作的性能，因为每次对DOM的操作都会触发“重排”，这会影响到能耗。为了减少这种影响，通常的做法是尽可能的减少DOM操作。而使用文档碎片就是一种有效的优化手段。\n\nvue 数组如何实现双向绑定\n\n重写数组方法\n\nvue组件传值有哪些方式\n\n\n父子通信：父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 &#x2F; 子链也可以通信（$parent/$children）；ref 也可以访问组件实例；provide&#x2F;inject API；$attrs/$listeners\n兄弟通信：Bus；Vuex\n跨级通信：Bus；Vuex；provide&#x2F;inject API、$attrs&#x2F;$listeners\n\n\nvuex的工作流程\n\nhttps://blog.csdn.net/m0_74331160/article/details/128806413\nhttps://blog.csdn.net/shanglin1122/article/details/131812888\n\nvuex的模块化开发\n\nvuex的辅助函数\n\n\n1介绍：通过辅助函数mapGetters、mapState、mapActions、mapMutations，把vuex.store中的属性映射到vue实例身上，这样在vue实例中就能访问vuex.store中的属性了，对于操作vuex.store就变得非常方便。\n\n\n$nextTick原理\n\nvue2和vu e3的生命周期函数\n\nvue2的watch和vue3的有什么不同\n\n\n写法不同，vue3可以进行组合监听，vue3默认开深度监听\n11.ref和reactive的区别\n12345678910111213141516理解：1.ref是定义简单类型 和单一的对象2.reactive 定义复杂的类型梳理文档：ref和reactive都是Vue.js 3.x版本中新增的响应式API，用于实现组件的数据响应式更新。它们的主要区别如下：1. 数据类型不同：ref用于包装JavaScript基本类型的数据（如字符串、数字、布尔值等），而reactive可以用于包装JavaScript对象和数组等复杂类型的数据。2. 使用方式不同：ref需要通过在模板中使用ref指令以及在JavaScript代码中使用ref函数进行创建和使用，而reactive则需要通过调用Vue.js提供的reactive函数进行包装和创建。3. 访问方式不同：对于通过ref函数创建的响应式数据，我们可以通过.value属性来访问其实际值；而对于通过reactive函数创建的响应式对象，我们可以直接访问其属性或调用其方法。4. 设计理念不同：ref主要是为了解决单一元素/数据的响应式问题，而reactive则是为了解决JavaScript对象和数组等复杂数据结构的响应式问题。总的来说，ref和reactive都是用于实现Vue.js组件的数据响应式更新，但是它们的使用方法、适用范围和设计理念等方面略有不同，需要根据具体的应用场景选择合适的API进行使用。————————————————版权声明：本文为CSDN博主「Xxf909011」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Xxf909011/article/details/130635325\n\n\nVue3 ref的原理\n\n有哪些hook\nuseState、useEffect、useContext、useMemo、useCallback。useState\n\n受控组件和非受控组件\n\n\nreact受控组件和不受控组件的区别：1、受控组件依赖于状态，而非受控组件不受状态的控制；2、受控组件只有继承“React.Component”才会有状态，而非受控组件则不是只有继承才有状态；3、受控组件一般适用于需要动态设置初始值时，非受控组件一般用于无任何动态初始值信息时。\n\nredux中间件\n\nRedux 中间件是一种用于扩展 Redux 功能的插件系统。通过使用中间件，你可以在 Redux 的 action 被分发到 reducer 之前或之后执行自定义的逻辑。以下是一些常用的 Redux 中间件：\n\nredux-thunk：这是一个用于处理异步操作的中间件。它允许你分发一个函数作为 action，该函数接收 dispatch 和 getState 作为参数，并可以执行异步操作，如 API 调用。一旦异步操作完成，你可以使用 dispatch 分发一个新的 action。\nredux-saga：这是另一个用于处理异步操作的中间件，采用更严格的方式管理副作用。它使用 Generator 函数和 yield 表达式来处理异步操作，提供更细粒度的控制。与 redux-thunk 相比，redux-saga 更适合于复杂的异步流和副作用管理。\nredux-promise：这个中间件允许你分发一个 Promise 对象作为 action。当 Promise 解析时，中间件会自动分发一个新的 action，将 Promise 的结果作为 payload。这对于处理异步操作（如 API 调用）非常有用，尤其是当使用 fetch 或其他返回 Promise 的函数时。\nredux-observable：这个中间件使用 RxJS（Reactive Extensions for JavaScript）来处理异步操作和副作用。它允许你使用 Observable 流来处理 action，并提供更强大的操作符来处理复杂的异步逻辑。\nredux-logger：这是一个简单的中间件，用于在控制台中记录 Redux store 的状态变化和 action 分发。它可以帮助你在开发过程中调试和跟踪应用程序的状态变化。\nredux-devtools-extension：这是一个浏览器扩展程序，用于在开发过程中实时跟踪和调试 Redux store 的状态变化。它可以显示 action 历史记录、状态快照和时间旅行的功能，帮助你更好地理解和调试应用程序的状态管理。\n\n这些中间件只是 Redux 社区中的一部分，还有很多其他中间件可以用于扩展 Redux 的功能，以满足各种应用程序的需求。\n","slug":"面试题/4.八月瓜一面","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"面试题","author_index":"MessageWall"},{"id":"4dc2cf4ec571e0ddd37f9a1c0c0fec2d","title":"Jest辅助函数","content":"Setup and Teardown写测试的时候你经常需要在运行测试前做一些准备工作，和在运行测试后进行一些整理工作。 Jest 提供辅助函数来处理这个问题。\n为多次测试重复设置如果你有一些要为多次测试重复设置的工作，你可以使用 beforeEach 和 afterEach。\n例如，我们考虑一些与城市信息数据库进行交互的测试。 你必须在每个测试之前调用方法 initializeCityDatabase() ，同时必须在每个测试后，调用方法 clearCityDatabase()。 你可以这样做：\n123456789101112131415beforeEach(() =&gt; &#123;  initializeCityDatabase();&#125;);afterEach(() =&gt; &#123;  clearCityDatabase();&#125;);test(&#x27;city database has Vienna&#x27;, () =&gt; &#123;  expect(isCity(&#x27;Vienna&#x27;)).toBeTruthy();&#125;);test(&#x27;city database has San Juan&#x27;, () =&gt; &#123;  expect(isCity(&#x27;San Juan&#x27;)).toBeTruthy();&#125;);\n\nbeforeEach 和 afterEach 能够通过与 异步代码测试 相同的方式处理异步代码 — — 他们可以采取 done 参数或返回一个 promise。 例如，如果 initializeCityDatabase() 返回解决数据库初始化时的 promise ，我们会想返回这一 promise︰\n123beforeEach(() =&gt; &#123;  return initializeCityDatabase();&#125;);\n\nbeforeEach 会根据test测试用例的数量遍历循环，如果只想执行一次的话，可以用beforeAll 和 afterAll 处理这种情况\n","slug":"其他/Jest/Jest辅助函数","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Jest","author_index":"MessageWall"},{"id":"cb05db90efeecb5af5d994efc32f8989","title":"Jest入门笔记","content":"1. 介绍Jest是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。\n2. 安装\n通过 npm 添加依赖：\n\n1npm install --save-dev jest babel-jest babel-core babel-preset-env regenerator-runtime\n\nbabel-jest、 babel-core、 regenerator-runtime、babel-preset-env这几个依赖是为了让我们可以使用ES6的语法特性进行单元测试，ES6提供的 import 来导入模块的方式，Jest本身W是不支持的。\n\n添加.babelrc文件\n\n 在项目的根目录下添加.babelrc文件，并在文件复制如下内容:\n123&#123;  &quot;presets&quot;: [&quot;env&quot;]&#125;\n\n\n修改package.json中的test脚本\n\n打开package.json文件，将script下的test的值修改为jest：\n123&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;jest&quot;&#125;\n\n如果在typescript中使用需要安装ts-jest\n1npm install ts-jest --save-dev\n\n在项目根目录新建 jest.config.js 文件，如下：\n12345678910module.exports = &#123;    roots: [        &quot;&lt;rootDir&gt;/test&quot;    ],    testRegex: &#x27;test/(.+)\\\\.test\\\\.(jsx?|tsx?)$&#x27;,    transform: &#123;        &quot;^.+\\\\.tsx?$&quot;: &quot;ts-jest&quot;    &#125;,    moduleFileExtensions: [&#x27;ts&#x27;, &#x27;tsx&#x27;, &#x27;js&#x27;, &#x27;jsx&#x27;, &#x27;json&#x27;, &#x27;node&#x27;],&#125;;\n\n3. 使用\nsum.js\n\n1234567891011121314151617import axios from &#x27;axios&#x27;;function sum (a, b) &#123;  return a+b;&#125;function add (a, b) &#123;  return a+b;&#125;function fetchUser() &#123;  return axios.get(&#x27;http://jsonplaceholder.typicode.com/users/1&#x27;)    .then(res =&gt; res.data)    .catch(error =&gt; console.log(error));&#125;export &#123;\tsum,  fetchUser&#125;\n\n\nsun.test.js\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123;sum , fetchUser&#125;  from &#x27;./sum&#x27;;// const fetchUser = require(&#x27;./sum&#x27;)// 1. 相等判断：toBe 使用 Object.is 来判断相等，// toEqual 会递归判断 Object 的每一个字段，// 对数值来说 toBe 和 toEqual 相同；test(&quot;两个数字相加&quot;, () =&gt; &#123;  expect(sum(1,2)).not.toBe(2);&#125;)test(&#x27;object assignment&#x27;, () =&gt; &#123;  const data = &#123;one: 1&#125;;  data[&#x27;two&#x27;] = 2;  expect(data).toEqual(&#123;one: 1, two: 2&#125;);&#125;);// 2. 判断符点数：可使用 toBeCloseTo 来解决 JS 浮点精度带来的问题，如下示例；test(&#x27;adding floating point numbers&#x27;, () =&gt; &#123;  const value = 0.1 + 0.2; // 0.30000000000000004  expect(value).toBeCloseTo(0.3); // 测试通过&#125;);test(&#x27;fetchUser() 可以请求到一个含有name属性值为Leanne Graham的对象&#x27;, () =&gt; &#123;  expect.assertions(1);  return fetchUser()    .then(data =&gt; &#123;      expect(data.name).toBe(&#x27;Leanne Graham&#x27;);    &#125;);&#125;);//上面调用了expect.assertions(1)，它能确保在异步的测试用例中，//有一个断言会在回调函数中被执行。这在进行异步代码的测试中十分有效。test(&#x27;mock&#x27;, () =&gt; &#123;  const mockCallback = jest.fn(x =&gt; 42 + x);  [0, 1].forEach(mockCallback);  console.log(mockCallback.mock.calls,&#x27;mockCallback.mock.calls&#x27;)  // Mock函数被调用两次  expect(mockCallback.mock.calls.length).toBe(2);  // 第一次调用Mock函数时，第一个参数为0  expect(mockCallback.mock.calls[0][0]).toBe(0);  // 第二次调用Mock函数时，第一个参数为1  expect(mockCallback.mock.calls[1][0]).toBe(1);  // 第一次调用Mock函数的返回值为42  expect(mockCallback.mock.results[0].value).toBe(42);  // const myMock = jest.fn();  // const a = new myMock();  // const b = &#123;&#125;;  // const bound = myMock.bind(b);  // bound();  // console.log(myMock.mock.instances);  // // &gt; [ &lt;a&gt;, &lt;b&gt; ]  // Mock 函数还可以通过工具函数模拟返回值。  const myMock = jest.fn();  console.log(myMock());  // &gt; undefined  myMock  .mockReturnValueOnce(10)  .mockReturnValueOnce(&#x27;x&#x27;)  .mockReturnValue(true);  console.log(myMock(), myMock(), myMock(), myMock());  // &gt; 10, &#x27;x&#x27;, true, true&#125;);\n\n4. 常用断点123456789101112131415161718192021222324expect(&#123;a:1&#125;).toBe(&#123;a:1&#125;)//判断两个对象是否相等expect(&#123;a:1&#125;).toEqual(&#123;a:1&#125;)//归检查对象或数组的每个字段是否相等expect(1).not.toBe(2)//判断不等expect(n).toBeNull(); //判断是否为nullexpect(n).toBeUndefined(); //判断是否为undefinedexpect(n).toBeDefined(); //判断结果与toBeUndefined相反expect(n).toBeTruthy(); //判断结果为trueexpect(n).toBeFalsy(); //判断结果为falseexpect(value).toBeGreaterThan(3); //大于3expect(value).toBeGreaterThanOrEqual(3.5); //大于等于3.5expect(value).toBeLessThan(5); //小于5expect(value).toBeLessThanOrEqual(4.5); //小于等于4.5expect(value).toBeCloseTo(0.3); // 浮点数判断相等expect(&#x27;Christoph&#x27;).toMatch(/stop/); //正则表达式判断expect([&#x27;one&#x27;,&#x27;two&#x27;]).toContain(&#x27;one&#x27;); //不解释function compileAndroidCode() &#123;  throw new ConfigError(&#x27;you are using the wrong JDK&#x27;);&#125;test(&#x27;compiling android goes as expected&#x27;, () =&gt; &#123;  expect(compileAndroidCode).toThrow();  expect(compileAndroidCode).toThrow(ConfigError); //判断抛出异常&#125;）\n\n了解更多断点\n5. 运行测试\n运行测试 npm test\n\n使用 –watch 参数可以启动一个监控界面，当文件发生变化时，会便会运行相关的测试。 npm test --watch\n\n使用 –coverage 参数，测试结束时还会得到一份测试覆盖度报告，如下图。\n1npm test --coverage\n\n\nJest 单元测试术语解析：describe、it、expect、testjest测试代码片段123456789describe(&quot;number test&quot;, ()=&gt;&#123;\tit(&#x27;1 is true&#x27;, ()=&gt;&#123;\t\texpect(1).toBeTruthy()\t&#125;)\ttest(&#x27;2 is true&#x27;,()=&gt;&#123;\t\texpect(2).toBeTruthy()\t&#125;)&#125;)12345678\n\n\ndescribe 描述, decribe会形成一个作用域\nit 断言\nexpect 期望\ntest 测试，类似it\n\n","slug":"其他/Jest/Jest入门笔记","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Jest","author_index":"MessageWall"},{"id":"d1e934425bd2164e83202854a7d7852f","title":"eslint入门笔记","content":"Eslint 是什么编码规范每个程序员都有自己的编码习惯，最常见的莫过于：\n\n有的人写代码一行代码结尾必须加分号 ;，有的人觉得不加分号 ; 更好看；\n有的人写代码一行代码不会超过 80 个字符，认为这样看起来简洁明了，有的人喜欢把所有逻辑都写在一行代码上，觉得别人看不懂的代码很牛逼；\n有的人使用变量必然会先定义 var a = 10;，而粗心的人写变量可能没有定义过就直接使用 b = 10;；\n\nLint 的含义如果你写自己的项目怎么折腾都没关系，但是在公司中老板希望每个人写出的代码都要符合一个统一的规则，这样别人看源码就能够看得懂，因为源码是符合统一的编码规范制定的。\n那么问题来了，总不能每个人写的代码老板都要一行行代码去检查吧，这是一件很蠢的事情。凡是重复性的工作，都应该被制作成工具来节约成本。这个工具应该做两件事情：\n\n提供编码规范；\n提供自动检验代码的程序，并打印检验结果：告诉你哪一个文件哪一行代码不符合哪一条编码规范，方便你去修改代码。\n\nLint 因此而诞生。\nEslint 的含义Lint 是检验代码格式工具的一个统称，具体的工具有 Jslint 、 Eslint 等等 ………..\n我们可以形象地将 Lint 看成是电商行业，而电商行业具体表现有淘宝（Eslint）、京东（Jslint）等。\n使用 Eslint\n\n\n\n\n\n\n\n\n确保你的电脑安装了 node 和 npm 环境\n创建项目npm init 指令会在项目根目录下生成 package.json 文件。\n12345$ d:$ cd d:$ mkdir test-eslint$ cd test-eslint$ npm init\n\n安装依赖包--save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。\n1$ npm install eslint --save-dev\n\n设置 package.json 文件打开 package.json 文件，修改 script 属性如下：\n12345&quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;lint:create&quot;: &quot;eslint --init&quot;&#125;\n\n\nscript 属性的意思是脚本，使用方法是在 cmd 窗口中输入 npm run 指令 的形式，如：npm run lint:create；\n&quot;lint:create&quot;: &quot;eslint --init&quot; 这个脚本是为了生成 .eslintrc.js 文件，在介绍 Lint 的时候说到 Lint 应该提供编码规范，规范写在哪里，就写在这个文件，所以我们需要创建它；\n&quot;lint&quot;: &quot;eslint src&quot; 在介绍 Lint 的时候也说到 Lint 应该提供自动校验代码的程序，这个脚本是让 Lint 自动检验 src 目录下所有的 .js 文件。\n\n创建 .eslint.js 文件123456789101112131415161718$ npm run lint:create&gt; 20170811@0.1.0 lint:create D:\\code\\test\\20170811&gt; eslint --init? How would you like to configure ESLint? Answer questions about your style // 以问答的形式创建配置文件? Are you using ECMAScript 6 features? Yes      // 是否校验 Es6 语法? Are you using ES6 modules? Yes                // 是否校验 Es6 模块语法? Where will your code run? Browser             // 代码运行环境，Browser 指浏览器? Do you use CommonJS? Yes                      // 是否校验 CommonJs 语法? Do you use JSX? Yes                           // 是否校验 JSX 语法? Do you use React? Yes                         // 是否校验 React 语法? What style of indentation do you use? Tabs    // 首行空白选择 Tab 键还是 Space? What quotes do you use for strings? Double    // 字符串使用单引号 &#x27;string&#x27; 还是双引号 &quot;string&quot;? What line endings do you use? Windows         // 操作系统? Do you require semicolons? Yes                // 每行代码结尾是否校验加分号 ;? What format do you want your config file to be in? JavaScript     // 以 .js 格式生成配置文件Installing eslint-plugin-react@latest   // 因为要校验 Reac 语法，所以这里需要下载一个 React 语法规则的包\n\n创建完成后根目录下应该会出现 .eslintrc.js 文件\n创建 index.js 文件在根目录下创建 src&#x2F;index.js 文件，内容如下，接下来就使用 Eslint 来检验这个 .js 文件是否符合编码规范。\n1const lint = &#x27;eslint&#x27;\n\n此时的目录结构应该为：\n12345- test-eslint    + .eslintrc.js    + package.json    - src        + index.js\n\n校验代码12345678$ npm run lint    1:7   error  &#x27;lint&#x27; is assigned a value but never used  no-unused-vars    1:14  error  Strings must use doublequote               quotes    1:22  error  Missing semicolon                          semi    3 problems (3 errors, 0 warnings)    2 errors, 0 warnings potentially fixable with the `--fix` option.\n\n这里报了三个错误，分别是：\n\nindex.js 第1行第7个字符，报错编码规则为 no-unused-vars：变量 lint 只定义了，但是未使用；\nindex.js 第1行第14个字符，报错编码规则为 quotes：编码规范字符串只能使用双引号，这里却使用了单引号；\nindex.js 第1行第22个字符，报错编码规则为 semi：编码规范每行代码结尾必须加分号，这里没有加分号。\n\n当我们熟悉了编码规范之后，只需进行响应的修改就可以使代码形成统一的风格。刚开始如果对编码规范具体某一条规则不了解的话，可以在 eslint规则表 查看用法。（不建议去背规则表，而是用到什么查什么，把它当成字典来用，不那么累）\n设置 –fix 参数打开 package.json 文件，修改 script 属性如下：\n12345&quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;lint&quot;: &quot;eslint src --fix&quot;,    &quot;lint:create&quot;: &quot;eslint --init&quot;&#125;\n\n说明：这里给 &quot;lint&quot;: &quot;eslint src --fix&quot;, 加上 --fix 参数，是 Eslint 提供的自动修复基础错误的功能。\n此时运行 npm run lint 会看到少了两条报错信息，并不是说编码规范变了，而是 Eslint 自动修复了基础错误，打开 index.js 文件，可看到字符串自动变成了双引号，并且代码末尾也加上了分号。可惜的是 –fix 只能修复基础的不影响代码逻辑的错误，像 no-unused-vars 这种错误只能手动修改。\n配置文件讲解按照上述操作，会生成默认 .eslintrc.js 配置文件，内容如下：\n12345678910111213141516171819202122232425262728293031323334353637// .eslintrc.js module.exports = &#123;    &quot;env&quot;: &#123;        &quot;browser&quot;: true,        &quot;commonjs&quot;: true,        &quot;es6&quot;: true    &#125;,    &quot;extends&quot;: &quot;eslint:recommended&quot;,    &quot;parserOptions&quot;: &#123;        &quot;ecmaFeatures&quot;: &#123;            &quot;experimentalObjectRestSpread&quot;: true,            &quot;jsx&quot;: true        &#125;,        &quot;sourceType&quot;: &quot;module&quot;    &#125;,    &quot;plugins&quot;: [        &quot;react&quot;    ],    &quot;rules&quot;: &#123;        &quot;indent&quot;: [            &quot;error&quot;,            &quot;tab&quot;        ],        &quot;linebreak-style&quot;: [            &quot;error&quot;,            &quot;windows&quot;        ],        &quot;quotes&quot;: [            &quot;error&quot;,            &quot;double&quot;        ],        &quot;semi&quot;: [            &quot;error&quot;,            &quot;always&quot;        ]    &#125;&#125;\n\n该文件导出一个对象，对象包含属性 env、extends、parserOptions、plugins、rules 五个属性，作为刚学习 Eslint 的新手，我们总是想要竭尽所能的详细了解每一个属性是什么，干嘛用的，以获取小小的安全感。\nenv、parserOptions、plugins这三个放在一起将是因为你只需要知道它们是干嘛的：我的程序里要用到 ES6 、React 、JSX 语法，这几个属性就是让 Eslint 能够检验到这些语法的。其余的你不需要知道更多的哪怕一丢丢的东东了。\n作者在学习之初在这块浪费了很多时间，官方文档看了很多遍，大多不能理解什么意思，后来想它既然提供这么一个自动生成配置文件的工具，并且是命令行交互的方式，我只需要告诉它我要用 ES6 、React 、JSX 语法，它会自动进行相关配置满足我的要求即可。\nextends前面一直说检验代码遵循编码规范，那到底是什么规范呢。\n值为 “eslint:recommended” 的 extends 属性启用一系列核心规则，这些规则是经过前人验证的最佳实践（所谓最佳实践，就是大家伙都觉得应该遵循的编码规范），想知道最佳实践具体有哪些编码规范，可以在 eslint规则表  中查看被标记为 √ 的规则项。\n如果觉得官方提供的默认规则不好用，可以自定义规则配置文件，然后发布成 Npm 包，eslint-config-airbnb 就是别人自定义的编码规范，使用 npm 安装后，在我们自己的 .eslintrc.js 中进行配置 “extends”: “airbnb”，eslint-config 这个前缀可以省略不写，这样我们就使用了 eslint-config-airbnb 中的规则，而不是官方的规则 “extends”:”eslint:recommended” 了。关于如何创建自定义规则配置并共享可以参考： 如何自定义规则配置\n关于 “airbnb” 编码规范说两句，在接触到大多数开源项目中，大多数的作者都会使用 “airbnb” 编码规范而不是 官方的 “extends”: “eslint:recommended” 编码规范。\n如果我们觉得 eslint-config-airbnb 规则配置中个别规则并不符合当前项目的要求，可以直接在 .eslintrc.js 配置 rules 属性，优先级高于共享规则 airbnb。\nrules配置文件也生成了，我们怎么知道我们的系统会遵循什么规则呢？？\n在前面的列子中，使用 npm run lint 校验出了三处错误，假如我们的项目中字符串就是要使用单引号而不是双引号，代码结尾就是要不加分号才好看，变量就是定义了可能不会使用，我们可以通过设置 rules 来定义我们自己的编码规范，即规则。\nESLint 附带有大量的规则，修改规则应遵循如下要求：\n\n“off” 或 0 - 关闭规则\n“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)\n“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)\n\n有的规则没有属性，只需控制是开启还是关闭，像这样：”eqeqeq”: “off”，有的规则有自己的属性，使用起来像这样：”quotes”: [“error”, “double”]，具体有没有自带属性，可查看 eslint规则表。\n修改 .eslintrc.js 文件中的 rules 属性：\n12345678910111213141516171819&quot;rules&quot;: &#123;    &quot;indent&quot;: [        &quot;error&quot;,        &quot;tab&quot;    ],    &quot;linebreak-style&quot;: [        &quot;error&quot;,        &quot;windows&quot;    ],    &quot;quotes&quot;: [        &quot;error&quot;,        &quot;single&quot;        // 改成字符串必须由单引号括起来而不是双引号，&#x27;string&#x27;不报错，&quot;string&quot;报错    ],    &quot;semi&quot;: [        &quot;error&quot;,        &quot;never&quot;         // 改成代码结尾不再加分号，加了分号报错，不加分号不报错    ],    &quot;no-unused-vars&quot;: 0 // 0 相当于 off，表示关闭规则，相当于不再校验这条规则：变量定义了必须使用&#125;\n\n此时再使用 npm run lint 进行代码校验，没有报错就说明校验通过，代码符合统一编码规范。\n1234567D:\\code\\test\\20170811&gt;npm run lint&gt; 20170811@0.1.0 lint D:\\code\\test\\20170811&gt; eslint srcD:\\code\\test\\20170811&gt;\n\n可能存在的疑问刚接触 ESlint ，并不清楚有哪些规则怎么办，要去 eslint规则表 一条条记忆吗？答案是 no。\n个人认为 ESlint 的配置文件并不是一次性完成的，而是在项目过程中慢慢完善的。你可以放心大胆的先进行编码，然后使用 npm run lint 校验代码的编码规范，如果这时候报错，可以在报错信息中知道是哪一条编码规范报错了，你可能并不认识它们，此时去 eslint规则表 查询相应规则的使用方法，如：no-unused-vars，从而进一步确定项目中是否需要这条编码规范，如果需要，进行局部调整即可。\n12345678$ npm run lint    1:7   error  &#x27;lint&#x27; is assigned a value but never used  no-unused-vars    1:14  error  Strings must use doublequote               quotes    1:22  error  Missing semicolon                          semi    3 problems (3 errors, 0 warnings)    2 errors, 0 warnings potentially fixable with the `--fix` option.\n\n更新部分全局变量配置。如使用 window 对象，默认情况下会报 no-undef 的错误，需要在 .eslintrc 中进行相应配置。\n12345678&#123;    &quot;rules&quot;: &#123;        // ...    &#125;,    &quot;globals&quot;: &#123;        &quot;window&quot;: true    &#125;&#125;\n\n单行跳过 lint 校验在实际编码时，可能会出现以下的代码。\n123456const apple = &quot;apple&quot;;const balana = &quot;balana&quot;;module.exports = &#123;    fruit: balana ;&#125;\n\n在最上面定义了两个变量，在底部的配置文件中只可能用到其中一个变量，另一个用不到的在 eslint 校验时就会报错 no-unused-vars 的错误，意思是变量定义了但是没有被用到。\n其中一种解决方案是在 .eslintrc 文件中配置 rules no-unused-vars: 0，意思是项目中不检验变量定义未使用这条规则。强烈不建议这样做，这个规则十分有用，可以规避编写代码时遗漏的变量。\n另一种解决方案就是使用行内注释跳过对 apple 和 balana 两个变量跳过 eslint 校验，只影响这两个变量，不影响外部。\n123456const apple = &quot;apple&quot;;  // eslint-disable-lineconst balana = &quot;balana&quot;;  // eslint-disable-line  module.exports = &#123;    fruit: balana ;&#125;\n\n此时使用 eslint 校验时就不会再报错了。\n常见规则含义解释\nobject-shorthand 设置该规则，表示对象属性要简写。\n\n1234var foo = &#123;x: x&#125;;    // 会报错var bar = &#123;a: function () &#123;&#125;&#125;;  // 会报错var foo = &#123;x&#125;;    // 不会报错var bar = &#123;a () &#123;&#125;&#125;;    // 不会报错\n\n\nprefer-arrow-callback 要求回调函数使用箭头函数\n\n123456// 回调函数，函数的参数是个函数，这个参数函数就是回调函数funciton bar () &#123;&#125;      // 不是回调函数，不会报错// setTimeout 的第一个参数就是回调函数，不用箭头函数会报错setTimeout(() =&gt; &#123;    // .......&#125;, 1000)\n\n\nno-param-reassign 禁止对函数的参数重新赋值\n\n123456789function bar (&#123; data = &#123;&#125; &#125;) &#123;    data.num = 12;      // 会报错&#125;/* 虽然报错，又不想要将该校验关闭，如果代码中只有 data 这个属性有这种情形，可以在 .eslintrc.js 中的 rules 属性中添加配置（可忽略 data 属性做此校验）：&#x27;no-param-reassign&#x27;: [&#x27;error&#x27;, &#123; &#x27;props&#x27;: true, &#x27;ignorePropertyModificationsFor&#x27;: [&#x27;data&#x27;] &#125;],&#x27;no-param-reassign&#x27;: 0,  // 关闭该属性校验*/\n\n\nno-trailing-spaces 禁止行尾空格\nno-shadow 禁止变量声明与外层作用域的变量同名\n\n123function sum (num) &#123;  let num = 2;    // 报错，因为 num 变量作为参数已经申明过了&#125;\n\n常用的几个规则1234&quot;quotes&quot;: [1, &quot;single&quot;],            # 单引号&quot;quote-props&quot;:[2, &quot;as-needed&quot;],     # 双引号自动变单引号&quot;semi&quot;: [2, &quot;never&quot;],               # 一行结尾不要写分号&quot;comma-dangle&quot;: [1,&quot;always-multiline&quot;]  # 对象或数组多行写法时，最后一个值加逗号\n\nVue需要配置eslint-plugin-vue安装\n1npm install --save-dev eslint-plugin-vue\n\n配置代码规范\n1&quot;extends&quot;: [&quot;plugin:vue/recommended&quot;]\n\n","slug":"其他/Eslint/eslint入门笔记","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Eslint","author_index":"MessageWall"},{"id":"075200b24f3b143c5139f73a1f31aa8b","title":"开始","content":"从入口开始我们之前提到过 Vue.js 构建过程，在 web 应用下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 src/platforms/web/entry-runtime-with-compiler.js：\n当我们的代码执行 import Vue from &#39;vue&#39; 的时候，就是从这个入口执行代码来初始化 Vue， 那么 Vue 到底是什么，它是怎么初始化的，我们来一探究竟。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* @flow */import config from &#x27;core/config&#x27;import &#123; warn, cached &#125; from &#x27;core/util/index&#x27;import &#123; mark, measure &#125; from &#x27;core/util/perf&#x27;import Vue from &#x27;./runtime/index&#x27;import &#123; query &#125; from &#x27;./util/index&#x27;import &#123; shouldDecodeNewlines &#125; from &#x27;./util/compat&#x27;import &#123; compileToFunctions &#125; from &#x27;./compiler/index&#x27;const idToTemplate = cached(id =&gt; &#123;  const el = query(id)  return el &amp;&amp; el.innerHTML&#125;)const mount = Vue.prototype.$mountVue.prototype.$mount = function (  el?: string | Element,  hydrating?: boolean): Component &#123;  el = el &amp;&amp; query(el)  /* istanbul ignore if */  if (el === document.body || el === document.documentElement) &#123;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`    )    return this  &#125;  const options = this.$options  // resolve template/el and convert to render function  if (!options.render) &#123;    let template = options.template    if (template) &#123;      if (typeof template === &#x27;string&#x27;) &#123;        if (template.charAt(0) === &#x27;#&#x27;) &#123;          template = idToTemplate(template)          /* istanbul ignore if */          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123;            warn(              `Template element not found or is empty: $&#123;options.template&#125;`,              this            )          &#125;        &#125;      &#125; else if (template.nodeType) &#123;        template = template.innerHTML      &#125; else &#123;        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;          warn(&#x27;invalid template option:&#x27; + template, this)        &#125;        return this      &#125;    &#125; else if (el) &#123;      template = getOuterHTML(el)    &#125;    if (template) &#123;      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile&#x27;)      &#125;      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;        shouldDecodeNewlines,        delimiters: options.delimiters,        comments: options.comments      &#125;, this)      options.render = render      options.staticRenderFns = staticRenderFns      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile end&#x27;)        measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;)      &#125;    &#125;  &#125;  return mount.call(this, el, hydrating)&#125;/** * Get outerHTML of elements, taking care * of SVG elements in IE as well. */function getOuterHTML (el: Element): string &#123;  if (el.outerHTML) &#123;    return el.outerHTML  &#125; else &#123;    const container = document.createElement(&#x27;div&#x27;)    container.appendChild(el.cloneNode(true)    return container.innerHTML  &#125;&#125;Vue.compile = compileToFunctionsexport default Vue\n\n可以找到Vue是在 src&#x2F;core&#x2F;instance&#x2F;index.js 被定义的，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。\n有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 xxxMixin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法（这里具体的细节会在之后的文章介绍，这里不展开），Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。\ninitGlobalAPIVue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中：\nvue初始化Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法， 该方法在 src/core/instance/init.js 中定义。Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等\nVue 的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。\n由于我们这一章的目标是弄清楚模板和数据如何渲染成最终的 DOM，所以各种初始化逻辑我们先不看。在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。\n","slug":"源码阅读笔记/vue/开始","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"09fa92eab7d534581236b19377694635","title":"阅读vue源码前的准备工作","content":"认识FlowFlow是facebook出品的javascript静态类型检查工具，vue源码中使用了Flow。\nflow的语法类似typescript，区别在于typescript需要将文件后缀名改成.ts，flow在前边加个注释就行\n12345// @flowfunction add(x: number, y: number): number &#123;  return x + y&#125;add(&#x27;Hello&#x27;, 11)\n\n有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。\n在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。\n这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下：\n12345678flow├── compiler.js        # 编译相关├── component.js       # 组件数据结构├── global-api.js      # Global API 结构├── modules.js         # 第三方库定义├── options.js         # 选项相关├── ssr.js             # 服务端渲染相关├── vnode.js           # 虚拟 node 相关\n\n可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。\nVue.js 源码目录设计Vue.js 的源码都在 src 目录下，其目录结构如下。\n1234567src├── compiler        # 编译相关 ├── core            # 核心代码 ├── platforms       # 不同平台的支持├── server          # 服务端渲染├── sfc             # .vue 文件解析├── shared          # 共享代码\n\ncompilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。\ncorecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。\n这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方。\nplatformVue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。\n我们会重点分析 web 入口打包后的 Vue.js，对于 weex 入口打包的 Vue.js，感兴趣的同学可以自行研究。\nserverVue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。\n服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序\nsfc通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。\n这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。\nsharedVue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的\nVue.js 源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。\n构建脚本通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。\n我们通常会配置 script 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下：\n12345678&#123;  &quot;script&quot;: &#123;    &quot;build&quot;: &quot;node scripts/build.js&quot;,    &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;,    &quot;build:weex&quot;: &quot;npm run build -- weex&quot;  &#125;&#125; ","slug":"源码阅读笔记/vue/阅读vue源码前的准备工作","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue","author_index":"MessageWall"},{"id":"23849453bb676c7918a2ae11cb140881","title":"使用Jest对Vue组件进行单元测试","content":"使用Jest对Vue组件进行单元测试安装依赖\n1npm install --save-dev @vue/test-utils vue-jest jest-transform-stub jest-serializer-vue\n\n然后在components目录下创建Counter.vue，代码如下：\n12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt;  &lt;div&gt;    &lt;div&gt;&#123;&#123; computedCount &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;inc&quot;&gt;加&lt;/button&gt;    &lt;button @click=&quot;dec&quot;&gt;减&lt;/button&gt;    &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    factor: &#123; type: Number, default: 1 &#125;  &#125;,  data() &#123;    return &#123;      count: 0    &#125;;  &#125;,  methods: &#123;    inc() &#123;      this.count++;    &#125;,    dec() &#123;      this.count--;    &#125;,    reset() &#123;      this.count = 0;    &#125;  &#125;,  computed: &#123;    computedCount: function() &#123;      return this.count * this.factor;    &#125;  &#125;&#125;;&lt;/script&gt;\n\n在unit目录下创建Counter.spec.js，代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738import &#123; mount &#125; from &#x27;@vue/test-utils&#x27;import Counter from &#x27;@/components/Counter.vue&#x27;describe(&quot;Counter.vue&quot;, () =&gt; &#123;    it(&quot;渲染Counter组件&quot;, () =&gt; &#123;        const wrapper = mount(Counter)        expect(wrapper.element).toMatchSnapshot()    &#125;)    it(&quot;初始化之为0&quot;, () =&gt; &#123;        const wrapper = mount(Counter)        expect(wrapper.vm.count).toEqual(0)    &#125;)    it(&quot;加1&quot;, () =&gt; &#123;        const wrapper = mount(Counter)        wrapper.vm.inc()        expect(wrapper.vm.count).toEqual(1)    &#125;)    it(&quot;减1&quot;, () =&gt; &#123;        const wrapper = mount(Counter)        wrapper.vm.dec()        expect(wrapper.vm.count).toEqual(-1)    &#125;)    it(&quot;重置&quot;, () =&gt; &#123;        const wrapper = mount(Counter)        wrapper.vm.reset()        expect(wrapper.vm.count).toEqual(0)    &#125;)    it(&quot;因数为10加1操作&quot;, () =&gt; &#123;        const wrapper = mount(Counter, &#123; propsData: &#123; factor: 10 &#125; &#125;)        wrapper.vm.inc()        expect(wrapper.vm.computedCount).toEqual(10)    &#125;)&#125;)\n\n打开控制台，进入项目根目录，运行yarn test:unit，如图1所示：\n\n看代码很容易理解如何在unit test中初始化组件，初始化组件的属性，访问组件的数据，调用组件的方法等等。\n","slug":"其他/Jest/使用Jest对Vue组件进行单元测试","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"Jest","author_index":"MessageWall"},{"id":"2e55a78a98794587d49e3a89fa8798ef","title":"微前端概念","content":"微前端概述   微前端概念是ThoughtWorks在2016年提出来的，它将微服务理念扩展到前端开发，解决中台微服务化后，前端由于仍为单体而存在的逻辑繁杂和臃肿的问题。微前端是按照前端设计方法在前端同时构建多个可以独立部署、完全自治、松耦合的页面组合，其中每个组合只负责特定的 UI 元素和功能。\n   微前端与微服务都是希望将单体应用，按照一定的规则拆分为多个可以独立运行、独立开发、独立部署、独立运维的微服务或者页面聚合，从而满足业务快速变化及分布式多团队并行开发的需求。\n   微前端除了可以实现前端页面的解耦外，还可实现前端页面的复用，做到“一次开发，多端复用”，这也与中台服务共享理念是一脉相承。\n从单体前端到微前端​    传统的软件项目往往采用单体式架构，前端往往由一个团队创建并维护一个 Web 应用程序，通过API网关从微服务调用服务。随着时间的推移，前端往往会越来越臃肿，越来越难维护。\n   随着5G技术的应用，企业活动将进一步移动化和线上化，过去企业的通常做法是为不同的应用开发出很多独立的APP。但是用户来并不想装那么多APP！为了提高用户体验，实现统一运营，很多企业开始缩减APP的数量，通过一个APP集成所有应用功能。\n   试想如果将企业内所有前端页面、流程设计以及前端与后端集成的工作都交给前端项目，将原来独立和分散的应用，展示在一个巴掌大的手机屏幕上。前端项目将会面对无数的中台项目和成千上万不太熟悉的API接口，这绝对会是一场灾难。\n   相对互联网企业而言，传统企业的渠道应用更多样化，有面向内部人员的柜台类应用、面向外部客户的互联网电商及移动APP类应用，还有面向商业生态圈的第三方API集成。由于渠道的差异，传统企业前端设计将会更多样化和复杂化。\n   传统企业在实施中台战略时，为满足前端和中台多渠道共享和复用，部分场景还应有别于阿里巴巴的中台战略。传统企业除了要像阿里巴巴一样进行通用共享服务（主要提供共享API）的中台化建设外，还需要对核心专属业务（除API外，还存在大量面向用户的页面）进行中台化建设，以满足不同渠道的业务复用的需求。\n\n从单体前端到微前端\n   如何实现前端复用，降低前端集成的复杂度？\n   在前端设计时，我们可以参考微服务设计方法，遵循单一职责和共享原则，按照领域模型和微服务边界，将前端页面进行拆分和组合形成微前端，与中台微服务组合成业务单元。\n   业务单元定义：在前后端分离架构模式下，微前端页面与中台微服务共同组成一个业务单元。在同一个业务单元内，从前端页面、中台微服务到后端数据可以独立开发、测试、部署和运维，在业务单元内自包含完成中台领域内的部分或全部业务功能。\n   项目职责和系统边界\n   1）前端项目主要负责前端页面的集成、页面风格设计和流程控制，以及与微前端集成相关的微前端加载、微前端注册、页面路由以及数据共享。\n   2）后端中台项目负责业务单元内中台微服务以及微服务对应微前端开发和集成。\n   通用和专属中台项目既面向第三方生态圈提供API服务，也面向前端集成主页面提供微前端页面复用。微前端和中台微服务组合成业务单元为多渠道业务提供从前端到后台的页面和业务逻辑复用。在面向多渠道业务页面复用时，微前端需要做好页面风格适配，以满足不同渠道界面风格的要求。\n   通过职责分工和应用边界的清晰划分，前端项目专注于微前端集成，后端项目专职做好本业务领域内中台微服务开发和微前端集成，确保领域内前端页面和后端业务逻辑作为一个业务单元整体高可用。\n   由于微前端和微服务之间的API集成已由中台项目完成，前端项目可基于微前端实现拼图式开发，在实现前后端复用的同时，大大降低前端集成复杂度。   \n微前端与微服务组合的几种形态​    微前端与微服务可以有多种组合方式，以实现不同的业务目标。\n​    一个虚框内微前端、中台微服务共同组成一个业务单元（如下图）。虚框内组件可以按照业务单元分前端和后端进行独立部署。\n​    微前端页面包括业务操作必需的页面要素，不含页面导航等要素，页面导航功能位于前端集成主页面内。\n​    微前端页面稍加改造就可以完成简单的单一场景业务，也可根据页面路由动态加载到前端集成主页面完成复杂组合场景业务。\n\n微前端的几种形态\n   微前端与微服务的组合主要有以下几类形式。\n   1）单一类微前端：一个微前端和一个中台微服务组成一个业务单元。微前端完成业务单元内页面流程和前端操作，中台微服务完成后端业务逻辑，业务单元功能独立且自包含。微前端可按照页面路由动态加载至前端集成主页面。\n   2）组合类微前端：一个微前端与多个中台微服务组成业务单元。微前端通过对多个中台微服务进行服务编排和组合，完成业务单元内较复杂的页面流程和前端操作。业务逻辑由后端多个微服务组合完成，如：可由专属业务中台与通用中台微服务组合，也可由同一领域内多个微服务组合。在微前端设计时，微前端对应的组合微服务的数量要均衡考虑，否则很容易将微前端开发成单体前端。同时业务单元的领域边界要清晰，避免由于功能交叉而导致单元与单元之间的耦合，影响项目团队职责边界，进而影响到部署、测试以及运维等。\n   3）通用共享类微前端：一个微前端与一个或多个通用中台微服务组成共享类业务单元。通用共享类微前端一般通过前端集成主页面，以共享页面的模式与其他微前端页面组合，共同完成业务流程。该类微前端通常对应通用中台共享类微服务。\n微前端的价值微前端架构具备以下几个核心价值：\n\n技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n","slug":"其他/微前端/微前端概念","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"微前端","author_index":"MessageWall"},{"id":"9c08a0d97df6bc70228237d5ac86d1b4","title":"部署","content":"\n数据库\ndocker部署\n\nApollo Config Service 获取镜像1docker pull apolloconfig/apollo-configservice\n\n 运行镜像示例：\n1234docker run -p 8080:8080 \\    -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://127.0.0.1:3306/ApolloConfigDB?characterEncoding=utf8&quot; \\    -e SPRING_DATASOURCE_USERNAME=ApolloConfigDB -e SPRING_DATASOURCE_PASSWORD=a0491153a3 \\    -d -v /tmp/logs:/opt/logs --name apollo-configservice apolloconfig/apollo-configservice\n\n参数说明：\n\nSPRING_DATASOURCE_URL: 对应环境ApolloConfigDB的地址\nSPRING_DATASOURCE_USERNAME: 对应环境ApolloConfigDB的用户名\nSPRING_DATASOURCE_PASSWORD: 对应环境ApolloConfigDB的密码\n\n2.3.1.2 Apollo Admin Service2.3.1.2.1 获取镜像1docker pull apolloconfig/apollo-adminservice\n\n2.3.1.2.2 运行镜像示例：\n1234docker run -p 8090:8090 \\    -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://127.0.0.1:3306/ApolloConfigDB?characterEncoding=utf8&quot; \\    -e SPRING_DATASOURCE_USERNAME=root -e SPRING_DATASOURCE_PASSWORD=961306 \\    -d -v /tmp/logs:/opt/logs --name apollo-adminservice apolloconfig/apollo-adminservice\n\n参数说明：\n\nSPRING_DATASOURCE_URL: 对应环境ApolloConfigDB的地址\nSPRING_DATASOURCE_USERNAME: 对应环境ApolloConfigDB的用户名\nSPRING_DATASOURCE_PASSWORD: 对应环境ApolloConfigDB的密码\n\n2.3.1.3 Apollo Portal2.3.1.3.1 获取镜像1docker pull apolloconfig/apollo-portal\n\n2.3.1.3.2 运行镜像示例：\n123456docker run -p 8070:8070 \\    -e SPRING_DATASOURCE_URL=&quot;jdbc:mysql://127.0.0.1:3306/ApolloPortalDB?characterEncoding=utf8&quot; \\    -e SPRING_DATASOURCE_USERNAME=root -e SPRING_DATASOURCE_PASSWORD=961306 \\    -e APOLLO_PORTAL_ENVS=dev,pro \\    -e DEV_META=http://fill-in-dev-meta-server:8080 -e PRO_META=http://fill-in-pro-meta-server:8080 \\    -d -v /tmp/logs:/opt/logs --name apollo-portal apolloconfig/apollo-portal\n\n参数说明：\n\nSPRING_DATASOURCE_URL: 对应环境ApolloPortalDB的地址\nSPRING_DATASOURCE_USERNAME: 对应环境ApolloPortalDB的用户名\nSPRING_DATASOURCE_PASSWORD: 对应环境ApolloPortalDB的密码\nAPOLLO_PORTAL_ENVS(可选): 对应ApolloPortalDB中的apollo.portal.envs配置项，如果没有在数据库中配置的话，可以通过此环境参数配置\nDEV_META&#x2F;PRO_META(可选): 配置对应环境的Meta Service地址，以${ENV}_META命名，需要注意的是如果配置了ApolloPortalDB中的apollo.portal.meta.servers配置，则以apollo.portal.meta.servers中的配置为准\n\ndocker run -d -p 10240:8080 -p 10241:50000 -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home   -v &#x2F;opt&#x2F;apache-maven-3.8.5:&#x2F;usr&#x2F;local&#x2F;maven  -v &#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&#x2F;git:&#x2F;usr&#x2F;local&#x2F;git    -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime –name myjenkins jenkins&#x2F;jenkins\n1234docker run -d -p 8081:8080 -p 50000:50000 --restart=always \\ -v /usr/local/docker/jenkins_home:/var/jenkins_home \\ -v /etc/localtime:/etc/localtime -v /opt/apache-maven-3.8.5:/usr/local/maven \\ -e PHP_TZ=&quot;Asia/Shanghai&quot; --name jenkins jenkins/jenkins:2.341-jdk8","slug":"其他/apollo/部署","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"apollo","author_index":"MessageWall"},{"id":"0de3628c378178e45f54c2175e0c38c6","title":"开始学习","content":"初始化项目\nclone 项目\n\n1$ git clone https://github.com/vuejs/vue-next.git\n\n\n安装项目依赖\n\n1yarn install\n\n\n生成vue.global.js\n\n1yarn run dev\n\n目录结构├── packages│   ├── compiler-core # 所有平台的编译器│   ├── compiler-dom # 针对浏览器而写的编译器│   ├── reactivity # 数据响应式系统│   ├── runtime-core # 虚拟 DOM 渲染器 ，Vue 组件和 Vue 的各种API│   ├── runtime-dom # 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等。│   ├── runtime-test # 专门为测试写的runtime│   ├── server-renderer # 用于SSR│   ├── shared # 帮助方法│   ├── template-explorer│   └── vue # 构建vue runtime + compiler\ncompiler-core：平台无关的编译器，它既包含可扩展的基础功能，也包含所有平台无关的插件。暴露了 AST 和 baseCompile 相关的 API，它能把一个字符串变成一棵 AST\ncompiler-dom：基于compiler-core封装针对浏览器的compiler\nruntime-core：与平台无关的运行时环境。支持实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API， 可以用来自定义 renderer ，vue2中也有\nruntime-dom：针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等， 暴露了重要的render和createApp方法\nruntime-test：一个专门为了测试而写的轻量级 runtime。比如对外暴露了renderToString方法，在此感慨和react越来越像了\nserver-renderer：用于 SSR，尚未实现。\nshared：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法。\n","slug":"源码阅读笔记/vue-next/开始学习","date":"2024-05-05T06:52:32.000Z","categories_index":"","tags_index":"vue-next","author_index":"MessageWall"},{"id":"a23763344ac54e792742fe2976e22df2","title":"React Hooks","content":"React Hooks1. hooks总览\n什么是react 的 hook 以及 react hooks 的由来官网解释：Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 linter 插件来强制执行这些规则：\n\n\n说白了就是对于函数组件的加强，增加了对于函数组件的一些特性，像class组件那样使用\n2.useState 使用状态12const [n,setN] = React.useState(0)const [user,setUser] = React.useState(&#123;name:&#x27;F&#x27;&#125;)\n\n注意事项1：不可局部更新\n\n如果state是一个对象，不可以局部setState\n因为 setState 不会帮我们合并属性\nuseReducer 也不会合并\n\n注意事项2：地址要变\n\nsetState(obi)如果obj地址不变，那么 React 就认为数据没有变化\n\nuseState 可以接受函数\n123const [state,setState] = useState(()=&gt;&#123;    return initialState&#125;)\n\n该函数返回初始state，且只执行一次，相比于传入对象可以减少计算过程\nsetState 接受函数12345678910111213function App() &#123;   // App函数组件    const [n, setN] = useState(0)    const onClick = () =&gt; &#123;        setN(n + 1);        setN(n + 1);    &#125;    return (        &lt;div className=&#x27;App&#x27;&gt;            &lt;h1&gt;n:&#123;n&#125;&lt;/h1&gt;            &lt;button onClick=&#123;onClick&#125;&gt;n+1&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n当我点击按钮，只会加一，而不会加二\n12345678910111213function App() &#123;   // App函数组件    const [n, setN] = useState(0)    const onClick = () =&gt; &#123;        setN(x =&gt; x + 1);      // 改成函数写法        setN(n =&gt; n + 1);    &#125;    return (        &lt;div className=&#x27;App&#x27;&gt;            &lt;h1&gt;n:&#123;n&#125;&lt;/h1&gt;            &lt;button onClick=&#123;onClick&#125;&gt;n+1&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n函数写法最后会执行加2操作，因此要尽可能使用函数的写法\n3. useReducer使用步骤：\n\n创建初始值 initialState\n创建所有操作reducer(state,action)\n传给useReducer，得到读和写API\n调用写 ({type:’操作类型’})\n\n总得来说useReducer是useState的复杂版\n示例代码：\n12345678910111213141516171819202122232425262728293031323334const initial = &#123;    n: 0&#125;const reducer = (state, action) =&gt; &#123;    if (action.type === &#x27;add&#x27;) &#123;        return &#123;n: state.n + action.number&#125;    &#125; else if (action.type === &#x27;multi&#x27;) &#123;        return &#123;n: state.n * 2&#125;    &#125; else &#123;        throw new Error(&#x27;unknown type&#x27;)    &#125;&#125;function App() &#123;    const [state, dispatch] = useReducer(reducer, initial)    const &#123;n&#125; = state    const onClick = () =&gt; &#123;        dispatch(&#123;            type: &#x27;add&#x27;, number: 1        &#125;)    &#125;    const onClick2 = () =&gt; &#123;        dispatch(&#123;            type: &#x27;add&#x27;, number: 2        &#125;)    &#125;    return (        &lt;div className=&#x27;App&#x27;&gt;            &lt;h1&gt;n:&#123;n&#125;&lt;/h1&gt;            &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt;            &lt;button onClick=&#123;onClick2&#125;&gt;+2&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n简单点说就是把操作汇总在一起了\n一个适合使用 useReducer 的场景：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React, &#123; useReducer &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const initFormData = &#123;  name: &quot;&quot;,  age: 18,  nationality: &quot;汉族&quot;&#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &quot;patch&quot;:      return &#123; ...state, ...action.formData &#125;;    case &quot;reset&quot;:      return initFormData;    default:      throw new Error();  &#125;&#125;function App() &#123;  const [formData, dispatch] = useReducer(reducer, initFormData);  // const patch = (key, value)=&gt;&#123;  //   dispatch(&#123; type: &quot;patch&quot;, formData: &#123; [key]: value &#125; &#125;)  // &#125;  const onSubmit = () =&gt; &#123;&#125;;  const onReset = () =&gt; &#123;    dispatch(&#123; type: &quot;reset&quot; &#125;);  &#125;;  return (    &lt;form onSubmit=&#123;onSubmit&#125; onReset=&#123;onReset&#125;&gt;      &lt;div&gt;        &lt;label&gt;          姓名          &lt;input            value=&#123;formData.name&#125;            onInput=&#123;(e) =&gt;              dispatch(&#123; type: &quot;patch&quot;, formData: &#123; name: e.target.value &#125; &#125;)            &#125;          /&gt;        &lt;/label&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;          年龄          &lt;input            value=&#123;formData.age&#125;            onChange=&#123;(e) =&gt;              dispatch(&#123; type: &quot;patch&quot;, formData: &#123; age: e.target.value &#125; &#125;)            &#125;          /&gt;        &lt;/label&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;          民族          &lt;input            value=&#123;formData.nationality&#125;            onChange=&#123;(e) =&gt;              dispatch(&#123;                type: &quot;patch&quot;,                formData: &#123; nationality: e.target.value &#125;              &#125;)            &#125;          /&gt;        &lt;/label&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;        &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;      &lt;/div&gt;      &lt;hr /&gt;      &#123;JSON.stringify(formData)&#125;    &lt;/form&gt;  );&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);\n\n如何使用 useReducer 代替 Redux步骤：\n\n将数据集中在一个store对象\n将所有操作集中在reducer\n创建一个Context\n创建对数据的读写API\n将第四步的内容放到第三步的Context\n用Context.Provider将Context提供给所有组件\n各个组件用useContext 获取读写API\n\n示例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import React, &#123; useReducer, useContext, useEffect &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const store = &#123;  user: null,  books: null,  movies: null&#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &quot;setUser&quot;:      return &#123; ...state, user: action.user &#125;;    case &quot;setBooks&quot;:      return &#123; ...state, books: action.books &#125;;    case &quot;setMovies&quot;:      return &#123; ...state, movies: action.movies &#125;;    default:      throw new Error();  &#125;&#125;const Context = React.createContext(null);function App() &#123;  const [state, dispatch] = useReducer(reducer, store);  const api = &#123; state, dispatch &#125;;  return (      &lt;Context.Provider value=&#123;api&#125;&gt;        &lt;User /&gt;        &lt;hr /&gt;        &lt;Books /&gt;        &lt;Movies /&gt;      &lt;/Context.Provider&gt;  );&#125;function User() &#123;  const &#123; state, dispatch &#125; = useContext(Context);  useEffect(() =&gt; &#123;    ajax(&quot;/user&quot;).then(user =&gt; &#123;      dispatch(&#123; type: &quot;setUser&quot;, user: user &#125;);    &#125;);  &#125;, []);  return (      &lt;div&gt;        &lt;h1&gt;个人信息&lt;/h1&gt;        &lt;div&gt;name: &#123;state.user ? state.user.name : &quot;&quot;&#125;&lt;/div&gt;      &lt;/div&gt;  );&#125;function Books() &#123;  const &#123; state, dispatch &#125; = useContext(Context);  useEffect(() =&gt; &#123;    ajax(&quot;/books&quot;).then(books =&gt; &#123;      dispatch(&#123; type: &quot;setBooks&quot;, books: books &#125;);    &#125;);  &#125;, []);  return (      &lt;div&gt;        &lt;h1&gt;我的书籍&lt;/h1&gt;        &lt;ol&gt;          &#123;state.books ? state.books.map(book =&gt; &lt;li key=&#123;book.id&#125;&gt;&#123;book.name&#125;&lt;/li&gt;) : &quot;加载中&quot;&#125;        &lt;/ol&gt;      &lt;/div&gt;  );&#125; function Movies() &#123;  const &#123; state, dispatch &#125; = useContext(Context);  useEffect(() =&gt; &#123;    ajax(&quot;/movies&quot;).then(movies =&gt; &#123;      dispatch(&#123; type: &quot;setMovies&quot;, movies: movies &#125;);    &#125;);  &#125;, []);  return (      &lt;div&gt;        &lt;h1&gt;我的电影&lt;/h1&gt;        &lt;ol&gt;          &#123;state.movies              ? state.movies.map(movie =&gt; &lt;li key=&#123;movie.id&#125;&gt;&#123;movie.name&#125;&lt;/li&gt;)              : &quot;加载中&quot;&#125;        &lt;/ol&gt;      &lt;/div&gt;  );&#125;// 假 ajax// 两秒钟后，根据 path 返回一个对象，必定成功不会失败function ajax(path) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      if (path === &quot;/user&quot;) &#123;        resolve(&#123;          id: 1,          name: &quot;Frank&quot;        &#125;);      &#125; else if (path === &quot;/books&quot;) &#123;        resolve([          &#123;            id: 1,            name: &quot;JavaScript 高级程序设计&quot;          &#125;,          &#123;            id: 2,            name: &quot;JavaScript 精粹&quot;          &#125;        ]);      &#125; else if (path === &quot;/movies&quot;) &#123;        resolve([          &#123;            id: 1,            name: &quot;爱在黎明破晓前&quot;          &#125;,          &#123;            id: 2,            name: &quot;恋恋笔记本&quot;          &#125;        ]);      &#125;    &#125;, 2000);  &#125;);&#125;export default App\n\n4. useContext\n全局变量是全局的上下文\n上下文是局部的全局变量\n\n使用方法：\n使用 C &#x3D; createContext( initial ) 创建上下文\n使用 &lt; C.provider &gt;圈定作用域\n在作用域内使用 useContext ( C ) 来使用上下文\n\n示例代码：\n123456789101112131415161718192021222324252627282930const Context = React.createContext(null);function App() &#123;  const [state, dispatch] = useReducer(reducer, store);  const api = &#123; state, dispatch &#125;;  return (      &lt;Context.Provider value=&#123;api&#125;&gt;        &lt;User /&gt;        &lt;hr /&gt;        &lt;Books /&gt;        &lt;Movies /&gt;      &lt;/Context.Provider&gt;  );&#125;function User() &#123;  const &#123; state, dispatch &#125; = useContext(Context);  useEffect(() =&gt; &#123;    ajax(&quot;/user&quot;).then(user =&gt; &#123;      dispatch(&#123; type: &quot;setUser&quot;, user: user &#125;);    &#125;);  &#125;, []);  return (      &lt;div&gt;        &lt;h1&gt;个人信息&lt;/h1&gt;        &lt;div&gt;name: &#123;state.user ? state.user.name : &quot;&quot;&#125;&lt;/div&gt;      &lt;/div&gt;  );&#125;\n\n5. useEffecteffect 是副作用的意思，实际上叫做 afterRender 更好一些 ，每次render 后运行，模仿生命周期函数\n用途：\n\n作为componentDidMount使用，[ ] (空数组)作第二个参数\n\n123456789101112131415161718function App() &#123;    const [n, setN] = useState(0)    const onClick = function () &#123;        setN(i =&gt; i + 1)    &#125;    const afterRender = useEffect    afterRender(() =&gt; &#123;        console.log(&#x27;第一次渲染执行这几句话&#x27;)    &#125;, [])    // 第一次渲染执行    return (        &lt;div&gt;            n:&#123;n&#125;            &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n\n作为componentDidUpdate使用，可指定依赖\n\n1234567891011121314151617181920212223function App() &#123;    const [n, setN] = useState(0)    const onClick = function () &#123;        setN(i =&gt; i + 1)    &#125;    const afterRender = useEffect    afterRender(() =&gt; &#123;        console.log(&#x27;n变化时执行这句话&#x27;)      &#125;, [n])    // n变化时执行这句话        const afterRender = useEffect    afterRender(() =&gt; &#123;        console.log(&#x27;任何 state 变化时执行这句话&#x27;)      &#125;)    // 任何 state 变化时 执行这句话    return (        &lt;div&gt;            n:&#123;n&#125;            &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n\n作为componentWillUnmount使用，通过 return\n\n12345678910111213141516171819202122function App() &#123;    const [n, setN] = useState(0)    const onClick = function () &#123;        setN(i =&gt; i + 1)    &#125;    useEffect(() =&gt; &#123;        const id = setInterval(() =&gt; &#123;            console.log(&#x27;hi&#x27;)        &#125;, 1000)        return () =&gt; &#123;            window.clearInterval(id)        &#125;    &#125;, [])    return (        &lt;div&gt;            n:&#123;n&#125;            &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt;        &lt;/div&gt;    )&#125;\n\n以上三种用途可同时存在特点：\n\n如果同时存在多个useEffect，会按照出现次序执行\n\nuseLayoutEffect布局副作用：\nuseEffect在浏览器渲染完成后执行\n\nuseLayoutEffect 在浏览器渲染前执行\n\n\n特点：\nuseLayoutEffect总是比useEffect先执行\nuseLayoutEffect 里的任务最好影响了Layout\n\n经验：\n为了用户体验，优先使用useEffect (优先渲染)\n\n6. useMemo首先认识一下 React.memo\n\nReact 默认有多余的 render\n\n1234567891011121314151617181920212223function App() &#123;  const [n, setN] = React.useState(0);  const [m, setM] = React.useState(0);  const onClick = () =&gt; &#123;    setN(n + 1);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;/button&gt;      &lt;/div&gt;      &lt;Child data=&#123;m&#125;/&gt;      &#123;/* &lt;Child2 data=&#123;m&#125;/&gt; */&#125;    &lt;/div&gt;  );&#125;function Child(props) &#123;  console.log(&quot;child 执行了&quot;);  console.log(&#x27;假设这里有大量代码&#x27;)  return &lt;div&gt;child: &#123;props.data&#125;&lt;/div&gt;;&#125;   \n\n以上代码运行时，点击按钮会打印 20 21 行的log，这假设 Child 组件里面有大量的逻辑代码，会浪费性能\n改进：\n12345678910111213141516171819202122232425262728293031function App() &#123;  const [n, setN] = React.useState(0);  const [m, setM] = React.useState(0);  const onClick = () =&gt; &#123;    setN(n + 1);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;/button&gt;      &lt;/div&gt;      &lt;Child2 data=&#123;m&#125;/&gt;    &lt;/div&gt;  );&#125;function Child(props) &#123;  console.log(&quot;child 执行了&quot;);  console.log(&#x27;假设这里有大量代码&#x27;)  return &lt;div&gt;child: &#123;props.data&#125;&lt;/div&gt;;&#125;const Child2 = React.memo(Child);    // 这样在不改变 Child 组件内部数据的情况下就不会执行函数// 还可以直接写成const Child2 = React.memo(props=&gt;&#123;  console.log(&quot;child 执行了&quot;);  console.log(&#x27;假设这里有大量代码&#x27;)  return &lt;div&gt;child: &#123;props.data&#125;&lt;/div&gt;;&#125;)\n\n但是这样会有问题：当我们在 App 组件内部传给 child 组件一个事件监听函数的时候 ，当App的内部值变化时，child 组件函数还是会执行，因为 App 函数执行的同时，会产生新的函数，相当于函数对象换了地址，就会导致 child 组件函数的执行，解决方法就是使用 useMomo\nuseMemo：缓存一些不希望重新生成的 value value可以是任何数据类型\n特点：\n\n第一个参数是 () &#x3D;&gt; { }\n第二个参数是依赖[ m,n ]\n只有当依赖变化时,才会计算出新的 value\n如果依赖不变，那么就重用之前的value\n是不是跟 vue 2 的 computed 很相似\n\n注意：\n\n如果你的value是个函数,那么你就要写成 useMemo ( ( )&#x3D;&gt; (×) &#x3D;&gt; console.log(×) )\n这是一个返回函数的函数\n这很难用，于是 useCallback 出现了\n\nuseCallback:用法：\n\nuseCallback( x &#x3D;&gt; log(x),[ m ] ) 等价于\nuseMemo ( ( )&#x3D;&gt; x &#x3D;&gt; log( x ) ,[ m ])\n实际上就是缓存函数时的一个语法糖\n\n使用 useMemo 解决上述的 React.memo 的函数复用的问题，示例代码：\n12345678910111213141516171819202122232425262728293031323334function App() &#123;  const [n, setN] = React.useState(0);  const [m, setM] = React.useState(0);  const onClick = () =&gt; &#123;    setN(n + 1);  &#125;;  const onClick2 = () =&gt; &#123;    setM(m + 1);  &#125;;  const onClickChild = useMemo(() =&gt; &#123;    const fn = div =&gt; &#123;      console.log(&quot;on click child, m: &quot; + m);      console.log(div);    &#125;;    return fn;  &#125;, [m]); // 这里呃 [m] 改成 [n] 就会打印出旧的 m  return (    &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;        &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;/button&gt;        &lt;button onClick=&#123;onClick2&#125;&gt;update m &#123;m&#125;&lt;/button&gt;      &lt;/div&gt;      &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt;    &lt;/div&gt;  );&#125;function Child(props) &#123;  console.log(&quot;child 执行了&quot;);  console.log(&quot;假设这里有大量代码&quot;);  return &lt;div onClick=&#123;e =&gt; props.onClick(e.target)&#125;&gt;child: &#123;props.data&#125;&lt;/div&gt;;&#125;const Child2 = React.memo(Child);\n\n7. useRef目的：\n\n如果你需要一个值，在组件不断 render 时保持不变\n初始化:const count &#x3D; useRef ( 0 )\n读取 : count.current\n为什么要 current ? 为了保证两次的 useRef 是同一个值(只有引用能做到)\n\n能否做到变化时自动 render ？\n不能\n为什么不能 ？ 因为这不符合React的理念\nReact 的理念是 UI&#x3D; f(data)\n你如果想要这个功能，完全可以自己加\n监听 ref ,当ref.current 变化时，调用 setX 即可\n\nforwardRef由于 useRef 可以用来引用 DOM 对象，也可以用来引用普通对象，由于 props 不包括 ref，所以需要使用 forwardRed\n使用示例：\n123456789101112function App() &#123;  const buttonRef = useRef(null);  return (    &lt;div className=&quot;App&quot;&gt;      &lt;Button3 ref=&#123;buttonRef&#125;&gt;按钮&lt;/Button3&gt;    &lt;/div&gt;  );&#125;const Button3 = React.forwardRef((props, ref) =&gt; &#123;   // 这样才可以传递 ref DOM 引用  return &lt;button className=&quot;red&quot; ref=&#123;ref&#125; &#123;...props&#125; /&gt;;&#125;);\n\nuseImperativeHandle实际上应该叫做 setRef，他的作用就是设置当前 Ref 为另一个东西\n12345678910111213141516171819202122232425262728293031323334function App() &#123;  const buttonRef = useRef(null);  useEffect(() =&gt; &#123;    console.log(buttonRef.current);  &#125;);  return (    &lt;div className=&quot;App&quot;&gt;      &lt;Button2 ref=&#123;buttonRef&#125;&gt;按钮&lt;/Button2&gt;      &lt;button        className=&quot;close&quot;        onClick=&#123;() =&gt; &#123;          console.log(buttonRef);          buttonRef.current.x();        &#125;&#125;      &gt;        x      &lt;/button&gt;    &lt;/div&gt;  );&#125;const Button2 = React.forwardRef((props, ref) =&gt; &#123;  const realButton = createRef(null);  const setRef = useImperativeHandle;    // 函数本身  setRef(ref, () =&gt; &#123;    return &#123;     // 把真正的 ref 变身了      x: () =&gt; &#123;        realButton.current.remove();      &#125;,      realButton: realButton    &#125;;  &#125;);  return &lt;button ref=&#123;realButton&#125; &#123;...props&#125; /&gt;;&#125;);\n\n8. 自定义 hook主要用于封装数据操作\n示例代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344const useList = () =&gt; &#123;    // 自定义的hook  const [list, setList] = useState(null);  useEffect(() =&gt; &#123;    ajax(&quot;/list&quot;).then(list =&gt; &#123;      setList(list);    &#125;);  &#125;, []); // [] 确保只在第一次运行  return &#123;    list: list,    setList: setList  &#125;;&#125;;export default useList;function ajax() &#123;    // 假的 ajax  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve([        &#123; id: 1, name: &quot;Frank&quot; &#125;,        &#123; id: 2, name: &quot;Jack&quot; &#125;,        &#123; id: 3, name: &quot;Alice&quot; &#125;,        &#123; id: 4, name: &quot;Bob&quot; &#125;      ]);    &#125;, 2000);  &#125;);&#125;function App() &#123;    const &#123; list, setList &#125; = useList();   // 组件中直接使用 非常方便灵活  return (    &lt;div className=&quot;App&quot;&gt;      &lt;h1&gt;List&lt;/h1&gt;      &#123;list ? (        &lt;ol&gt;          &#123;list.map(item =&gt; (            &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;          ))&#125;        &lt;/ol&gt;      ) : (        &quot;加载中...&quot;      )&#125;    &lt;/div&gt;  );&#125;\n\n9. stale closures 过时闭包实际上描述了我们在使用 hook 函数的时候 函数中使用的 旧的引用值的问题\n看例子：\n12345678910111213141516171819202122function createIncrement(incBy) &#123;  let value = 0;  function increment() &#123;    value += incBy;    console.log(value);  &#125;  const message = `Current value is $&#123;value&#125;`;  function log() &#123;    console.log(message);  &#125;    return [increment, log];&#125;const [increment, log] = createIncrement(1);increment(); // logs 1increment(); // logs 2increment(); // logs 3// Does not work!log();       // logs &quot;Current value is 0&quot;  旧的引用\n\n上面代码在调用 log() 时只会打印 旧的值，因为 log 函数保存了 产生这个函数时的 value的值，闭包原理\n改进：\n12345678910111213141516171819202122function createIncrement(incBy) &#123;  let value = 0;  function increment() &#123;    value += incBy;    console.log(value);  &#125;  function log() &#123;    const message = `Current value is $&#123;value&#125;`;    // 直接使用 value    console.log(message);  &#125;    return [increment, log];&#125;const [increment, log] = createIncrement(1);increment(); // logs 1increment(); // logs 2increment(); // logs 3// Works!log();       // logs &quot;Current value is 3&quot;\n\nReact 中的体现   ———— useEffect()123456789101112131415161718function WatchCount() &#123;  const [count, setCount] = useState(0);  useEffect(function() &#123;    setInterval(function log() &#123;      console.log(`Count is: $&#123;count&#125;`);    &#125;, 2000);  &#125;, []);    // 只会打印 0   return (    &lt;div&gt;      &#123;count&#125;      &lt;button onClick=&#123;() =&gt; setCount(count + 1) &#125;&gt;        Increase      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n使用依赖改进\n123456789101112131415161718192021function WatchCount() &#123;  const [count, setCount] = useState(0);  useEffect(function() &#123;    const id = setInterval(function log() &#123;      console.log(`Count is: $&#123;count&#125;`);    &#125;, 2000);    return function() &#123;      clearInterval(id);    // 必须清除定时器    &#125;  &#125;, [count]);  // 依赖改进  return (    &lt;div&gt;      &#123;count&#125;      &lt;button onClick=&#123;() =&gt; setCount(count + 1) &#125;&gt;        Increase      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n\nReact 中的体现   ———— useState()12345678910111213141516function DelayedCount() &#123;  const [count, setCount] = useState(0);  function handleClickAsync() &#123;    setTimeout(function delay() &#123;      setCount(count + 1);    &#125;, 1000);  &#125;  return (    &lt;div&gt;      &#123;count&#125;      &lt;button onClick=&#123;handleClickAsync&#125;&gt;Increase async&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n每次点击时，setTimeout(delay, 1000)计划delay()在1秒后执行。delay()将变量捕获count为0。\n两个delay()闭包（因为已经进行了 2 次点击）都将状态更新为相同的值：setCount(count + 1) = setCount(0 + 1) = setCount(1)。\n全部是因为delay()第二次点击的关闭已捕获了过时的count变量as 0。\n改进：\n123456789101112131415161718192021function DelayedCount() &#123;  const [count, setCount] = useState(0);  function handleClickAsync() &#123;    setTimeout(function delay() &#123;      setCount(count =&gt; count + 1);    &#125;, 1000);  &#125;  function handleClickSync() &#123;    setCount(count + 1);  &#125;  return (    &lt;div&gt;      &#123;count&#125;      &lt;button onClick=&#123;handleClickAsync&#125;&gt;Increase async&lt;/button&gt;      &lt;button onClick=&#123;handleClickSync&#125;&gt;Increase sync&lt;/button&gt;    &lt;/div&gt;  );&#125;   // 单击快速增加异步2次。在counter显示正确的值2。\n\n解决陈旧闭包的有效方法是正确设置 React 钩子的依赖项。或者，在状态陈旧的情况下，使用函数方式来更新状态。\n","slug":"react/React Hooks","date":"2021-08-11T16:00:00.000Z","categories_index":"React","tags_index":"React,React Hooks","author_index":"MessageWall"}]